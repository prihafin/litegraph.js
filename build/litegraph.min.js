var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(p, r, t) {
  p != Array.prototype && p != Object.prototype && (p[r] = t.value);
};
$jscomp.getGlobal = function(p) {
  return "undefined" != typeof window && window === p ? p : "undefined" != typeof global && null != global ? global : p;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(p, r, t, h) {
  if (r) {
    t = $jscomp.global;
    p = p.split(".");
    for (h = 0; h < p.length - 1; h++) {
      var A = p[h];
      A in t || (t[A] = {});
      t = t[A];
    }
    p = p[p.length - 1];
    h = t[p];
    r = r(h);
    r != h && null != r && $jscomp.defineProperty(t, p, {configurable:!0, writable:!0, value:r});
  }
};
$jscomp.polyfill("Array.prototype.fill", function(p) {
  return p ? p : function(r, t, h) {
    var p = this.length || 0;
    0 > t && (t = Math.max(0, p + t));
    if (null == h || h > p) {
      h = p;
    }
    h = Number(h);
    0 > h && (h = Math.max(0, p + h));
    for (t = Number(t || 0); t < h; t++) {
      this[t] = r;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var p = 0;
  return function(r) {
    return $jscomp.SYMBOL_PREFIX + (r || "") + p++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var p = $jscomp.global.Symbol.iterator;
  p || (p = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[p] && $jscomp.defineProperty(Array.prototype, p, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(p) {
  var r = 0;
  return $jscomp.iteratorPrototype(function() {
    return r < p.length ? {done:!1, value:p[r++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(p) {
  $jscomp.initSymbolIterator();
  p = {next:p};
  p[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return p;
};
$jscomp.iteratorFromArray = function(p, r) {
  $jscomp.initSymbolIterator();
  p instanceof String && (p += "");
  var t = 0, h = {next:function() {
    if (t < p.length) {
      var A = t++;
      return {value:r(A, p[A]), done:!1};
    }
    h.next = function() {
      return {done:!0, value:void 0};
    };
    return h.next();
  }};
  h[Symbol.iterator] = function() {
    return h;
  };
  return h;
};
$jscomp.polyfill("Array.prototype.values", function(p) {
  return p ? p : function() {
    return $jscomp.iteratorFromArray(this, function(r, p) {
      return p;
    });
  };
}, "es8", "es3");
$jscomp.polyfill("Array.prototype.keys", function(p) {
  return p ? p : function() {
    return $jscomp.iteratorFromArray(this, function(r) {
      return r;
    });
  };
}, "es6", "es3");
(function(p) {
  function r(a) {
    d.debug && console.log("Graph created");
    this.list_of_graphcanvas = null;
    this.clear();
    a && this.configure(a);
  }
  function t(a, b, c, e, f, d) {
    this.id = a;
    this.type = b;
    this.origin_id = c;
    this.origin_slot = e;
    this.target_id = f;
    this.target_slot = d;
    this._data = null;
    this._pos = new Float32Array(2);
  }
  function h(a) {
    this._ctor(a);
  }
  function A(a) {
    this._ctor(a);
  }
  function B(a, b) {
    this.offset = new Float32Array([0, 0]);
    this.scale = 1;
    this.max_scale = 10;
    this.min_scale = 0.1;
    this.onredraw = null;
    this.enabled = !0;
    this.last_mouse = [0, 0];
    this.element = null;
    this.visible_area = new Float32Array(4);
    a && (this.element = a, b || this.bindEvents(a));
  }
  function k(a, b, c) {
    c = c || {};
    this.background_image = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
    a && a.constructor === String && (a = document.querySelector(a));
    this.ds = new B;
    this.zoom_modify_alpha = !0;
    this.title_text_font = "" + d.NODE_TEXT_SIZE + "px Arial";
    this.inner_text_font = "normal " + d.NODE_SUBTEXT_SIZE + "px Arial";
    this.node_title_color = d.NODE_TITLE_COLOR;
    this.default_link_color = d.LINK_COLOR;
    this.default_connection_color = {input_off:"#778", input_on:"#7F7", output_off:"#778", output_on:"#7F7"};
    this.highquality_render = !0;
    this.use_gradients = !1;
    this.editor_alpha = 1;
    this.pause_rendering = !1;
    this.clear_background = !0;
    this.read_only = !1;
    this.render_only_selected = !0;
    this.live_mode = !1;
    this.allow_searchbox = this.allow_interaction = this.allow_dragnodes = this.allow_dragcanvas = this.show_info = !0;
    this.drag_mode = this.allow_reconnect_links = !1;
    this.filter = this.dragging_rectangle = null;
    this.always_render_background = !1;
    this.render_canvas_border = this.render_shadows = !0;
    this.render_connections_shadows = !1;
    this.render_connections_border = !0;
    this.render_connection_arrows = this.render_curved_connections = !1;
    this.render_collapsed_slots = !0;
    this.render_execution_order = !1;
    this.render_link_tooltip = this.render_title_colored = !0;
    this.links_render_mode = d.SPLINE_LINK;
    this.canvas_mouse = [0, 0];
    this.onSelectionChange = this.onNodeMoved = this.onDrawLinkTooltip = this.onDrawOverlay = this.onDrawForeground = this.onDrawBackground = this.onMouse = this.onSearchBoxSelection = this.onSearchBox = null;
    this.connections_width = 3;
    this.round_radius = 8;
    this.over_link_center = this.node_widget = this.current_node = null;
    this.last_mouse_position = [0, 0];
    this.visible_area = this.ds.visible_area;
    this.visible_links = [];
    b && b.attachCanvas(this);
    this.setCanvas(a);
    this.clear();
    c.skip_render || this.startRendering();
    this.autoresize = c.autoresize;
  }
  function H(a, b) {
    return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));
  }
  function C(a, b, c, e, f, d) {
    return c < a && c + f > a && e < b && e + d > b ? !0 : !1;
  }
  function I(a, b) {
    var c = a[0] + a[2], e = a[1] + a[3], f = b[1] + b[3];
    return a[0] > b[0] + b[2] || a[1] > f || c < b[0] || e < b[1] ? !1 : !0;
  }
  function E(a, b) {
    function c(a) {
      var c = parseInt(f.style.top);
      f.style.top = (c + a.deltaY * b.scroll_speed).toFixed() + "px";
      a.preventDefault();
      return !0;
    }
    this.options = b = b || {};
    var e = this;
    b.parentMenu && (b.parentMenu.constructor !== this.constructor ? (console.error("parentMenu must be of class ContextMenu, ignoring it"), b.parentMenu = null) : (this.parentMenu = b.parentMenu, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this));
    b.event && b.event.constructor !== MouseEvent && b.event.constructor !== CustomEvent && b.event.constructor !== PointerEvent && (console.error("Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it."), b.event = null);
    var f = document.createElement("div");
    f.className = "litegraph litecontextmenu litemenubar-panel";
    b.className && (f.className += " " + b.className);
    f.style.minWidth = 100;
    f.style.minHeight = 100;
    f.style.pointerEvents = "none";
    setTimeout(function() {
      f.style.pointerEvents = "auto";
    }, 100);
    f.addEventListener("mouseup", function(a) {
      a.preventDefault();
      return !0;
    }, !0);
    f.addEventListener("contextmenu", function(a) {
      if (2 != a.button) {
        return !1;
      }
      a.preventDefault();
      return !1;
    }, !0);
    f.addEventListener("mousedown", function(a) {
      if (2 == a.button) {
        return e.close(), a.preventDefault(), !0;
      }
    }, !0);
    b.scroll_speed || (b.scroll_speed = 0.1);
    f.addEventListener("wheel", c, !0);
    f.addEventListener("mousewheel", c, !0);
    this.root = f;
    if (b.title) {
      var d = document.createElement("div");
      d.className = "litemenu-title";
      d.innerHTML = b.title;
      f.appendChild(d);
    }
    d = 0;
    for (var g in a) {
      var q = a.constructor == Array ? a[g] : g;
      null != q && q.constructor !== String && (q = void 0 === q.content ? String(q) : q.content);
      this.addItem(q, a[g], b);
      d++;
    }
    f.addEventListener("mouseleave", function(a) {
      e.lock || (f.closing_timer && clearTimeout(f.closing_timer), f.closing_timer = setTimeout(e.close.bind(e, a), 500));
    });
    f.addEventListener("mouseenter", function(a) {
      f.closing_timer && clearTimeout(f.closing_timer);
    });
    a = document;
    b.event && (a = b.event.target.ownerDocument);
    a || (a = document);
    a.fullscreenElement ? a.fullscreenElement.appendChild(f) : a.body.appendChild(f);
    g = b.left || 0;
    a = b.top || 0;
    b.event && (g = b.event.clientX - 10, a = b.event.clientY - 10, b.title && (a -= 20), b.parentMenu && (g = b.parentMenu.root.getBoundingClientRect(), g = g.left + g.width), d = document.body.getBoundingClientRect(), q = f.getBoundingClientRect(), g > d.width - q.width - 10 && (g = d.width - q.width - 10), a > d.height - q.height - 10 && (a = d.height - q.height - 10));
    f.style.left = g + "px";
    f.style.top = a + "px";
    b.scale && (f.style.transform = "scale(" + b.scale + ")");
  }
  function F(a) {
    this.points = a;
    this.nearest = this.selected = -1;
    this.size = null;
    this.must_update = !0;
    this.margin = 5;
  }
  var d = p.LiteGraph = {VERSION:0.4, CANVAS_GRID_SIZE:10, NODE_TITLE_HEIGHT:30, NODE_TITLE_TEXT_Y:20, NODE_SLOT_HEIGHT:20, NODE_WIDGET_HEIGHT:20, NODE_WIDTH:140, NODE_MIN_WIDTH:50, NODE_COLLAPSED_RADIUS:10, NODE_COLLAPSED_WIDTH:80, NODE_TITLE_COLOR:"#999", NODE_TEXT_SIZE:14, NODE_TEXT_COLOR:"#AAA", NODE_SUBTEXT_SIZE:12, NODE_DEFAULT_COLOR:"#333", NODE_DEFAULT_BGCOLOR:"#353535", NODE_DEFAULT_BOXCOLOR:"#666", NODE_DEFAULT_SHAPE:"box", DEFAULT_SHADOW_COLOR:"rgba(0,0,0,0.5)", DEFAULT_GROUP_FONT:24, 
  WIDGET_BGCOLOR:"#222", WIDGET_OUTLINE_COLOR:"#666", WIDGET_TEXT_COLOR:"#DDD", WIDGET_SECONDARY_TEXT_COLOR:"#999", LINK_COLOR:"#9A9", EVENT_LINK_COLOR:"#A86", CONNECTING_LINK_COLOR:"#AFA", MAX_NUMBER_OF_NODES:1000, DEFAULT_POSITION:[100, 100], VALID_SHAPES:["default", "box", "round", "card"], BOX_SHAPE:1, ROUND_SHAPE:2, CIRCLE_SHAPE:3, CARD_SHAPE:4, ARROW_SHAPE:5, INPUT:1, OUTPUT:2, EVENT:-1, ACTION:-1, ALWAYS:0, ON_EVENT:1, NEVER:2, ON_TRIGGER:3, UP:1, DOWN:2, LEFT:3, RIGHT:4, CENTER:5, STRAIGHT_LINK:0, 
  LINEAR_LINK:1, SPLINE_LINK:2, NORMAL_TITLE:0, NO_TITLE:1, TRANSPARENT_TITLE:2, AUTOHIDE_TITLE:3, proxy:null, node_images_path:"", debug:!1, catch_exceptions:!0, throw_errors:!0, allow_scripts:!1, registered_node_types:{}, node_types_by_file_extension:{}, Nodes:{}, searchbox_extras:{}, registerNodeType:function(a, b) {
    if (!b.prototype) {
      throw "Cannot register a simple object, it must be a class with a prototype";
    }
    b.type = a;
    d.debug && console.log("Node registered: " + a);
    a.split("/");
    var c = b.name, e = a.lastIndexOf("/");
    b.category = a.substr(0, e);
    b.title || (b.title = c);
    if (b.prototype) {
      for (var f in h.prototype) {
        b.prototype[f] || (b.prototype[f] = h.prototype[f]);
      }
    }
    Object.hasOwnProperty(b.prototype, "shape") || Object.defineProperty(b.prototype, "shape", {set:function(a) {
      switch(a) {
        case "default":
          delete this._shape;
          break;
        case "box":
          this._shape = d.BOX_SHAPE;
          break;
        case "round":
          this._shape = d.ROUND_SHAPE;
          break;
        case "circle":
          this._shape = d.CIRCLE_SHAPE;
          break;
        case "card":
          this._shape = d.CARD_SHAPE;
          break;
        default:
          this._shape = a;
      }
    }, get:function(a) {
      return this._shape;
    }, enumerable:!0});
    (e = this.registered_node_types[a]) && console.log("replacing node type: " + a);
    this.registered_node_types[a] = b;
    b.constructor.name && (this.Nodes[c] = b);
    if (d.onNodeTypeRegistered) {
      d.onNodeTypeRegistered(a, b);
    }
    if (e && d.onNodeTypeReplaced) {
      d.onNodeTypeReplaced(a, b, e);
    }
    b.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end");
    if (b.supported_extensions) {
      for (f in b.supported_extensions) {
        (a = b.supported_extensions[f]) && a.constructor === String && (this.node_types_by_file_extension[a.toLowerCase()] = b);
      }
    }
  }, wrapFunctionAsNode:function(a, b, c, e, f) {
    for (var n = Array(b.length), g = "", q = d.getParameterNames(b), l = 0; l < q.length; ++l) {
      g += "this.addInput('" + q[l] + "'," + (c && c[l] ? "'" + c[l] + "'" : "0") + ");\n";
    }
    g += "this.addOutput('out'," + (e ? "'" + e + "'" : 0) + ");\n";
    f && (g += "this.properties = " + JSON.stringify(f) + ";\n");
    c = Function(g);
    c.title = a.split("/").pop();
    c.desc = "Generated from " + b.name;
    c.prototype.onExecute = function() {
      for (var a = 0; a < n.length; ++a) {
        n[a] = this.getInputData(a);
      }
      a = b.apply(this, n);
      this.setOutputData(0, a);
    };
    this.registerNodeType(a, c);
  }, addNodeMethod:function(a, b) {
    h.prototype[a] = b;
    for (var c in this.registered_node_types) {
      var e = this.registered_node_types[c];
      e.prototype[a] && (e.prototype["_" + a] = e.prototype[a]);
      e.prototype[a] = b;
    }
  }, createNode:function(a, b, c) {
    var e = this.registered_node_types[a];
    if (!e) {
      return d.debug && console.log('GraphNode type "' + a + '" not registered.'), null;
    }
    b = b || e.title || a;
    var f = null;
    if (d.catch_exceptions) {
      try {
        f = new e(b);
      } catch (g) {
        return console.error(g), null;
      }
    } else {
      f = new e(b);
    }
    f.type = a;
    !f.title && b && (f.title = b);
    f.properties || (f.properties = {});
    f.properties_info || (f.properties_info = []);
    f.flags || (f.flags = {});
    f.size || (f.size = f.computeSize());
    f.pos || (f.pos = d.DEFAULT_POSITION.concat());
    f.mode || (f.mode = d.ALWAYS);
    if (c) {
      for (var n in c) {
        f[n] = c[n];
      }
    }
    return f;
  }, getNodeType:function(a) {
    return this.registered_node_types[a];
  }, getNodeTypesInCategory:function(a, b) {
    var c = [], e;
    for (e in this.registered_node_types) {
      var f = this.registered_node_types[e];
      b && f.filter && f.filter != b || ("" == a ? null == f.category && c.push(f) : f.category == a && c.push(f));
    }
    return c;
  }, getNodeTypesCategories:function(a) {
    var b = {"":1}, c;
    for (c in this.registered_node_types) {
      var e = this.registered_node_types[c];
      !e.category || e.skip_list || a && e.filter != a || (b[e.category] = 1);
    }
    a = [];
    for (c in b) {
      a.push(c);
    }
    return a;
  }, reloadNodes:function(a) {
    var b = document.getElementsByTagName("script"), c = [], e;
    for (e in b) {
      c.push(b[e]);
    }
    b = document.getElementsByTagName("head")[0];
    a = document.location.href + a;
    for (e in c) {
      var f = c[e].src;
      if (f && f.substr(0, a.length) == a) {
        try {
          d.debug && console.log("Reloading: " + f);
          var n = document.createElement("script");
          n.type = "text/javascript";
          n.src = f;
          b.appendChild(n);
          b.removeChild(c[e]);
        } catch (g) {
          if (d.throw_errors) {
            throw g;
          }
          d.debug && console.log("Error while reloading " + f);
        }
      }
    }
    d.debug && console.log("Nodes reloaded");
  }, cloneObject:function(a, b) {
    if (null == a) {
      return null;
    }
    a = JSON.parse(JSON.stringify(a));
    if (!b) {
      return a;
    }
    for (var c in a) {
      b[c] = a[c];
    }
    return b;
  }, isValidConnection:function(a, b) {
    if (!a || !b || a == b || a == d.EVENT && b == d.ACTION) {
      return !0;
    }
    a = String(a);
    b = String(b);
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (-1 == a.indexOf(",") && -1 == b.indexOf(",")) {
      return a == b;
    }
    a = a.split(",");
    b = b.split(",");
    for (var c = 0; c < a.length; ++c) {
      for (var e = 0; e < b.length; ++e) {
        if (a[c] == b[e]) {
          return !0;
        }
      }
    }
    return !1;
  }, registerSearchboxExtra:function(a, b, c) {
    this.searchbox_extras[b.toLowerCase()] = {type:a, desc:b, data:c};
  }};
  d.getTime = "undefined" != typeof performance ? performance.now.bind(performance) : "undefined" != typeof Date && Date.now ? Date.now.bind(Date) : "undefined" != typeof process ? function() {
    var a = process.hrtime();
    return 0.001 * a[0] + 1e-6 * a[1];
  } : function() {
    return (new Date).getTime();
  };
  p.LGraph = d.LGraph = r;
  r.supported_types = ["number", "string", "boolean"];
  r.prototype.getSupportedTypes = function() {
    return this.supported_types || r.supported_types;
  };
  r.STATUS_STOPPED = 1;
  r.STATUS_RUNNING = 2;
  r.prototype.clear = function() {
    this.stop();
    this.status = r.STATUS_STOPPED;
    this.last_link_id = this.last_node_id = 0;
    this._version = -1;
    if (this._nodes) {
      for (var a = 0; a < this._nodes.length; ++a) {
        var b = this._nodes[a];
        if (b.onRemoved) {
          b.onRemoved();
        }
      }
    }
    this._nodes = [];
    this._nodes_by_id = {};
    this._nodes_in_order = [];
    this._nodes_executable = null;
    this._groups = [];
    this.links = {};
    this.iteration = 0;
    this.config = {};
    this.vars = {};
    this.fixedtime = this.runningtime = this.globaltime = 0;
    this.elapsed_time = this.fixedtime_lapse = 0.01;
    this.starttime = this.last_update_time = 0;
    this.catch_errors = !0;
    this.inputs = {};
    this.outputs = {};
    this.change();
    this.sendActionToCanvas("clear");
  };
  r.prototype.attachCanvas = function(a) {
    if (a.constructor != k) {
      throw "attachCanvas expects a LGraphCanvas instance";
    }
    a.graph && a.graph != this && a.graph.detachCanvas(a);
    a.graph = this;
    this.list_of_graphcanvas || (this.list_of_graphcanvas = []);
    this.list_of_graphcanvas.push(a);
  };
  r.prototype.detachCanvas = function(a) {
    if (this.list_of_graphcanvas) {
      var b = this.list_of_graphcanvas.indexOf(a);
      -1 != b && (a.graph = null, this.list_of_graphcanvas.splice(b, 1));
    }
  };
  r.prototype.start = function(a) {
    if (this.status != r.STATUS_RUNNING) {
      this.status = r.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.last_update_time = this.starttime = d.getTime();
      a = a || 0;
      var b = this;
      if (0 == a && "undefined" != typeof window && window.requestAnimationFrame) {
        var c = function() {
          -1 == b.execution_timer_id && (window.requestAnimationFrame(c), b.runStep(1, !this.catch_errors));
        };
        this.execution_timer_id = -1;
        c();
      } else {
        this.execution_timer_id = setInterval(function() {
          b.runStep(1, !this.catch_errors);
        }, a);
      }
    }
  };
  r.prototype.stop = function() {
    if (this.status != r.STATUS_STOPPED) {
      this.status = r.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      null != this.execution_timer_id && (-1 != this.execution_timer_id && clearInterval(this.execution_timer_id), this.execution_timer_id = null);
      this.sendEventToAllNodes("onStop");
    }
  };
  r.prototype.runStep = function(a, b, c) {
    a = a || 1;
    var e = d.getTime();
    this.globaltime = 0.001 * (e - this.starttime);
    var f = this._nodes_executable ? this._nodes_executable : this._nodes;
    if (f) {
      c = c || f.length;
      if (b) {
        for (var n = 0; n < a; n++) {
          for (var g = 0; g < c; ++g) {
            var q = f[g];
            if (q.mode == d.ALWAYS && q.onExecute) {
              q.onExecute();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (n = 0; n < a; n++) {
            for (g = 0; g < c; ++g) {
              if (q = f[g], q.mode == d.ALWAYS && q.onExecute) {
                q.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = !1;
        } catch (y) {
          this.errors_in_execution = !0;
          if (d.throw_errors) {
            throw y;
          }
          d.debug && console.log("Error during execution: " + y);
          this.stop();
        }
      }
      a = d.getTime();
      e = a - e;
      0 == e && (e = 1);
      this.execution_time = 0.001 * e;
      this.globaltime += 0.001 * e;
      this.iteration += 1;
      this.elapsed_time = 0.001 * (a - this.last_update_time);
      this.last_update_time = a;
    }
  };
  r.prototype.updateExecutionOrder = function() {
    this._nodes_in_order = this.computeExecutionOrder(!1);
    this._nodes_executable = [];
    for (var a = 0; a < this._nodes_in_order.length; ++a) {
      this._nodes_in_order[a].onExecute && this._nodes_executable.push(this._nodes_in_order[a]);
    }
  };
  r.prototype.computeExecutionOrder = function(a, b) {
    for (var c = [], e = [], f = {}, n = {}, g = {}, q = 0, l = this._nodes.length; q < l; ++q) {
      var k = this._nodes[q];
      if (!a || k.onExecute) {
        f[k.id] = k;
        var u = 0;
        if (k.inputs) {
          for (var m = 0, h = k.inputs.length; m < h; m++) {
            k.inputs[m] && null != k.inputs[m].link && (u += 1);
          }
        }
        0 == u ? (e.push(k), b && (k._level = 1)) : (b && (k._level = 0), g[k.id] = u);
      }
    }
    for (; 0 != e.length;) {
      if (k = e.shift(), c.push(k), delete f[k.id], k.outputs) {
        for (q = 0; q < k.outputs.length; q++) {
          if (a = k.outputs[q], null != a && null != a.links && 0 != a.links.length) {
            for (m = 0; m < a.links.length; m++) {
              (l = this.links[a.links[m]]) && !n[l.id] && (u = this.getNodeById(l.target_id), null == u ? n[l.id] = !0 : (b && (!u._level || u._level <= k._level) && (u._level = k._level + 1), n[l.id] = !0, --g[u.id], 0 == g[u.id] && e.push(u)));
            }
          }
        }
      }
    }
    for (q in f) {
      c.push(f[q]);
    }
    c.length != this._nodes.length && d.debug && console.warn("something went wrong, nodes missing");
    l = c.length;
    for (q = 0; q < l; ++q) {
      c[q].order = q;
    }
    c = c.sort(function(a, b) {
      var c = a.constructor.priority || a.priority || 0, e = b.constructor.priority || b.priority || 0;
      return c == e ? a.order - b.order : c - e;
    });
    for (q = 0; q < l; ++q) {
      c[q].order = q;
    }
    return c;
  };
  r.prototype.getAncestors = function(a) {
    for (var b = [], c = [a], e = {}; c.length;) {
      var f = c.shift();
      if (f.inputs) {
        e[f.id] || f == a || (e[f.id] = !0, b.push(f));
        for (var d = 0; d < f.inputs.length; ++d) {
          var g = f.getInputNode(d);
          g && -1 == b.indexOf(g) && c.push(g);
        }
      }
    }
    b.sort(function(a, b) {
      return a.order - b.order;
    });
    return b;
  };
  r.prototype.arrange = function(a) {
    a = a || 100;
    for (var b = this.computeExecutionOrder(!1, !0), c = [], e = 0; e < b.length; ++e) {
      var f = b[e], n = f._level || 1;
      c[n] || (c[n] = []);
      c[n].push(f);
    }
    b = a;
    for (e = 0; e < c.length; ++e) {
      if (n = c[e]) {
        for (var g = 100, q = a + d.NODE_TITLE_HEIGHT, l = 0; l < n.length; ++l) {
          f = n[l], f.pos[0] = b, f.pos[1] = q, f.size[0] > g && (g = f.size[0]), q += f.size[1] + a + d.NODE_TITLE_HEIGHT;
        }
        b += g + a;
      }
    }
    this.setDirtyCanvas(!0, !0);
  };
  r.prototype.getTime = function() {
    return this.globaltime;
  };
  r.prototype.getFixedTime = function() {
    return this.fixedtime;
  };
  r.prototype.getElapsedTime = function() {
    return this.elapsed_time;
  };
  r.prototype.sendEventToAllNodes = function(a, b, c) {
    c = c || d.ALWAYS;
    var e = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (e) {
      for (var f = 0, n = e.length; f < n; ++f) {
        var g = e[f];
        if (g.constructor === d.Subgraph && "onExecute" != a) {
          g.mode == c && g.sendEventToAllNodes(a, b, c);
        } else {
          if (g[a] && g.mode == c) {
            if (void 0 === b) {
              g[a]();
            } else {
              if (b && b.constructor === Array) {
                g[a].apply(g, b);
              } else {
                g[a](b);
              }
            }
          }
        }
      }
    }
  };
  r.prototype.sendActionToCanvas = function(a, b) {
    if (this.list_of_graphcanvas) {
      for (var c = 0; c < this.list_of_graphcanvas.length; ++c) {
        var e = this.list_of_graphcanvas[c];
        e[a] && e[a].apply(e, b);
      }
    }
  };
  r.prototype.add = function(a, b) {
    if (a) {
      if (a.constructor === A) {
        this._groups.push(a), this.setDirtyCanvas(!0), this.change(), a.graph = this, this._version++;
      } else {
        -1 != a.id && null != this._nodes_by_id[a.id] && (console.warn("LiteGraph: there is already a node with this ID, changing it"), a.id = ++this.last_node_id);
        if (this._nodes.length >= d.MAX_NUMBER_OF_NODES) {
          throw "LiteGraph: max number of nodes in a graph reached";
        }
        null == a.id || -1 == a.id ? a.id = ++this.last_node_id : this.last_node_id < a.id && (this.last_node_id = a.id);
        a.graph = this;
        this._version++;
        this._nodes.push(a);
        this._nodes_by_id[a.id] = a;
        if (a.onAdded) {
          a.onAdded(this);
        }
        this.config.align_to_grid && a.alignToGrid();
        b || this.updateExecutionOrder();
        if (this.onNodeAdded) {
          this.onNodeAdded(a);
        }
        this.setDirtyCanvas(!0);
        this.change();
        return a;
      }
    }
  };
  r.prototype.remove = function(a) {
    if (a.constructor === d.LGraphGroup) {
      var b = this._groups.indexOf(a);
      -1 != b && this._groups.splice(b, 1);
      a.graph = null;
      this._version++;
      this.setDirtyCanvas(!0, !0);
      this.change();
    } else {
      if (null != this._nodes_by_id[a.id] && !a.ignore_remove) {
        if (a.inputs) {
          for (b = 0; b < a.inputs.length; b++) {
            var c = a.inputs[b];
            null != c.link && a.disconnectInput(b);
          }
        }
        if (a.outputs) {
          for (b = 0; b < a.outputs.length; b++) {
            c = a.outputs[b], null != c.links && c.links.length && a.disconnectOutput(b);
          }
        }
        if (a.onRemoved) {
          a.onRemoved();
        }
        a.graph = null;
        this._version++;
        if (this.list_of_graphcanvas) {
          for (b = 0; b < this.list_of_graphcanvas.length; ++b) {
            c = this.list_of_graphcanvas[b], c.selected_nodes[a.id] && delete c.selected_nodes[a.id], c.node_dragged == a && (c.node_dragged = null);
          }
        }
        b = this._nodes.indexOf(a);
        -1 != b && this._nodes.splice(b, 1);
        delete this._nodes_by_id[a.id];
        if (this.onNodeRemoved) {
          this.onNodeRemoved(a);
        }
        this.setDirtyCanvas(!0, !0);
        this.change();
        this.updateExecutionOrder();
      }
    }
  };
  r.prototype.getNodeById = function(a) {
    return null == a ? null : this._nodes_by_id[a];
  };
  r.prototype.findNodesByClass = function(a, b) {
    b = b || [];
    for (var c = b.length = 0, e = this._nodes.length; c < e; ++c) {
      this._nodes[c].constructor === a && b.push(this._nodes[c]);
    }
    return b;
  };
  r.prototype.findNodesByType = function(a, b) {
    a = a.toLowerCase();
    b = b || [];
    for (var c = b.length = 0, e = this._nodes.length; c < e; ++c) {
      this._nodes[c].type.toLowerCase() == a && b.push(this._nodes[c]);
    }
    return b;
  };
  r.prototype.findNodeByTitle = function(a) {
    for (var b = 0, c = this._nodes.length; b < c; ++b) {
      if (this._nodes[b].title == a) {
        return this._nodes[b];
      }
    }
    return null;
  };
  r.prototype.findNodesByTitle = function(a) {
    for (var b = [], c = 0, e = this._nodes.length; c < e; ++c) {
      this._nodes[c].title == a && b.push(this._nodes[c]);
    }
    return b;
  };
  r.prototype.getNodeOnPos = function(a, b, c, e) {
    c = c || this._nodes;
    for (var f = c.length - 1; 0 <= f; f--) {
      var d = c[f];
      if (d.isPointInside(a, b, e)) {
        return d;
      }
    }
    return null;
  };
  r.prototype.getGroupOnPos = function(a, b) {
    for (var c = this._groups.length - 1; 0 <= c; c--) {
      var e = this._groups[c];
      if (e.isPointInside(a, b, 2, !0)) {
        return e;
      }
    }
    return null;
  };
  r.prototype.checkNodeTypes = function() {
    for (var a = 0; a < this._nodes.length; a++) {
      var b = this._nodes[a];
      if (b.constructor != d.registered_node_types[b.type]) {
        console.log("node being replaced by newer version: " + b.type);
        var c = d.createNode(b.type);
        this._nodes[a] = c;
        c.configure(b.serialize());
        c.graph = this;
        this._nodes_by_id[c.id] = c;
        b.inputs && (c.inputs = b.inputs.concat());
        b.outputs && (c.outputs = b.outputs.concat());
      }
    }
    this.updateExecutionOrder();
  };
  r.prototype.onAction = function(a, b) {
    this._input_nodes = this.findNodesByClass(d.GraphInput, this._input_nodes);
    for (var c = 0; c < this._input_nodes.length; ++c) {
      var e = this._input_nodes[c];
      if (e.properties.name == a) {
        e.onAction(a, b);
        break;
      }
    }
  };
  r.prototype.trigger = function(a, b) {
    if (this.onTrigger) {
      this.onTrigger(a, b);
    }
  };
  r.prototype.addInput = function(a, b, c) {
    if (!this.inputs[a]) {
      this.inputs[a] = {name:a, type:b, value:c};
      this._version++;
      if (this.onInputAdded) {
        this.onInputAdded(a, b);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
  };
  r.prototype.setInputData = function(a, b) {
    if (a = this.inputs[a]) {
      a.value = b;
    }
  };
  r.prototype.getInputData = function(a) {
    return (a = this.inputs[a]) ? a.value : null;
  };
  r.prototype.renameInput = function(a, b) {
    if (b != a) {
      if (!this.inputs[a]) {
        return !1;
      }
      if (this.inputs[b]) {
        return console.error("there is already one input with that name"), !1;
      }
      this.inputs[b] = this.inputs[a];
      delete this.inputs[a];
      this._version++;
      if (this.onInputRenamed) {
        this.onInputRenamed(a, b);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
  };
  r.prototype.changeInputType = function(a, b) {
    if (!this.inputs[a]) {
      return !1;
    }
    if (!this.inputs[a].type || String(this.inputs[a].type).toLowerCase() != String(b).toLowerCase()) {
      if (this.inputs[a].type = b, this._version++, this.onInputTypeChanged) {
        this.onInputTypeChanged(a, b);
      }
    }
  };
  r.prototype.removeInput = function(a) {
    if (!this.inputs[a]) {
      return !1;
    }
    delete this.inputs[a];
    this._version++;
    if (this.onInputRemoved) {
      this.onInputRemoved(a);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
    return !0;
  };
  r.prototype.addOutput = function(a, b, c) {
    this.outputs[a] = {name:a, type:b, value:c};
    this._version++;
    if (this.onOutputAdded) {
      this.onOutputAdded(a, b);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
  };
  r.prototype.setOutputData = function(a, b) {
    if (a = this.outputs[a]) {
      a.value = b;
    }
  };
  r.prototype.getOutputData = function(a) {
    return (a = this.outputs[a]) ? a.value : null;
  };
  r.prototype.renameOutput = function(a, b) {
    if (!this.outputs[a]) {
      return !1;
    }
    if (this.outputs[b]) {
      return console.error("there is already one output with that name"), !1;
    }
    this.outputs[b] = this.outputs[a];
    delete this.outputs[a];
    this._version++;
    if (this.onOutputRenamed) {
      this.onOutputRenamed(a, b);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
  };
  r.prototype.changeOutputType = function(a, b) {
    if (!this.outputs[a]) {
      return !1;
    }
    if (!this.outputs[a].type || String(this.outputs[a].type).toLowerCase() != String(b).toLowerCase()) {
      if (this.outputs[a].type = b, this._version++, this.onOutputTypeChanged) {
        this.onOutputTypeChanged(a, b);
      }
    }
  };
  r.prototype.removeOutput = function(a) {
    if (!this.outputs[a]) {
      return !1;
    }
    delete this.outputs[a];
    this._version++;
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
    return !0;
  };
  r.prototype.triggerInput = function(a, b) {
    a = this.findNodesByTitle(a);
    for (var c = 0; c < a.length; ++c) {
      a[c].onTrigger(b);
    }
  };
  r.prototype.setCallback = function(a, b) {
    a = this.findNodesByTitle(a);
    for (var c = 0; c < a.length; ++c) {
      a[c].setTrigger(b);
    }
  };
  r.prototype.connectionChange = function(a, b) {
    this.updateExecutionOrder();
    if (this.onConnectionChange) {
      this.onConnectionChange(a);
    }
    this._version++;
    this.sendActionToCanvas("onConnectionChange");
  };
  r.prototype.isLive = function() {
    if (!this.list_of_graphcanvas) {
      return !1;
    }
    for (var a = 0; a < this.list_of_graphcanvas.length; ++a) {
      if (this.list_of_graphcanvas[a].live_mode) {
        return !0;
      }
    }
    return !1;
  };
  r.prototype.clearTriggeredSlots = function() {
    for (var a in this.links) {
      var b = this.links[a];
      b && b._last_time && (b._last_time = 0);
    }
  };
  r.prototype.change = function() {
    d.debug && console.log("Graph changed");
    this.sendActionToCanvas("setDirty", [!0, !0]);
    if (this.on_change) {
      this.on_change(this);
    }
  };
  r.prototype.setDirtyCanvas = function(a, b) {
    this.sendActionToCanvas("setDirty", [a, b]);
  };
  r.prototype.removeLink = function(a) {
    if (a = this.links[a]) {
      var b = this.getNodeById(a.target_id);
      b && b.disconnectInput(a.target_slot);
    }
  };
  r.prototype.serialize = function() {
    for (var a = [], b = 0, c = this._nodes.length; b < c; ++b) {
      a.push(this._nodes[b].serialize());
    }
    c = [];
    for (b in this.links) {
      var e = this.links[b];
      if (!e.serialize) {
        console.warn("weird LLink bug, link info is not a LLink but a regular object");
        var f = new t;
        for (b in e) {
          f[b] = e[b];
        }
        e = this.links[b] = f;
      }
      c.push(e.serialize());
    }
    e = [];
    for (b = 0; b < this._groups.length; ++b) {
      e.push(this._groups[b].serialize());
    }
    return {last_node_id:this.last_node_id, last_link_id:this.last_link_id, nodes:a, links:c, groups:e, config:this.config, version:d.VERSION};
  };
  r.prototype.configure = function(a, b) {
    if (a) {
      b || this.clear();
      b = a.nodes;
      if (a.links && a.links.constructor === Array) {
        for (var c = [], e = 0; e < a.links.length; ++e) {
          var f = a.links[e];
          if (f) {
            var n = new t;
            n.configure(f);
            c[n.id] = n;
          } else {
            console.warn("serialized graph link data contains errors, skipping.");
          }
        }
        a.links = c;
      }
      for (e in a) {
        "nodes" != e && "groups" != e && (this[e] = a[e]);
      }
      c = !1;
      this._nodes = [];
      if (b) {
        e = 0;
        for (f = b.length; e < f; ++e) {
          n = b[e];
          var g = d.createNode(n.type, n.title);
          g || (d.debug && console.log("Node not found or has errors: " + n.type), g = new h, g.last_serialization = n, c = g.has_errors = !0);
          g.id = n.id;
          this.add(g, !0);
        }
        e = 0;
        for (f = b.length; e < f; ++e) {
          n = b[e], (g = this.getNodeById(n.id)) && g.configure(n);
        }
      }
      this._groups.length = 0;
      if (a.groups) {
        for (e = 0; e < a.groups.length; ++e) {
          b = new d.LGraphGroup, b.configure(a.groups[e]), this.add(b);
        }
      }
      this.updateExecutionOrder();
      this._version++;
      this.setDirtyCanvas(!0, !0);
      return c;
    }
  };
  r.prototype.load = function(a) {
    var b = this, c = new XMLHttpRequest;
    c.open("GET", a, !0);
    c.send(null);
    c.onload = function(a) {
      200 !== c.status ? console.error("Error loading graph:", c.status, c.response) : (a = JSON.parse(c.response), b.configure(a));
    };
    c.onerror = function(a) {
      console.error("Error loading graph:", a);
    };
  };
  r.prototype.onNodeTrace = function(a, b, c) {
  };
  t.prototype.configure = function(a) {
    a.constructor === Array ? (this.id = a[0], this.origin_id = a[1], this.origin_slot = a[2], this.target_id = a[3], this.target_slot = a[4], this.type = a[5]) : (this.id = a.id, this.type = a.type, this.origin_id = a.origin_id, this.origin_slot = a.origin_slot, this.target_id = a.target_id, this.target_slot = a.target_slot);
  };
  t.prototype.serialize = function() {
    return [this.id, this.origin_id, this.origin_slot, this.target_id, this.target_slot, this.type];
  };
  d.LLink = t;
  p.LGraphNode = d.LGraphNode = h;
  h.prototype._ctor = function(a) {
    this.title = a || "Unnamed";
    this.size = [d.NODE_WIDTH, 60];
    this.graph = null;
    this._pos = new Float32Array(10, 10);
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    this.id = -1;
    this.type = null;
    this.inputs = [];
    this.outputs = [];
    this.connections = [];
    this.properties = {};
    this.properties_info = [];
    this.flags = {};
  };
  h.prototype.configure = function(a) {
    this.graph && this.graph._version++;
    for (var b in a) {
      if ("properties" == b) {
        for (var c in a.properties) {
          if (this.properties[c] = a.properties[c], this.onPropertyChanged) {
            this.onPropertyChanged(c, a.properties[c]);
          }
        }
      } else {
        null != a[b] && ("object" == typeof a[b] ? this[b] && this[b].configure ? this[b].configure(a[b]) : this[b] = d.cloneObject(a[b], this[b]) : this[b] = a[b]);
      }
    }
    a.title || (this.title = this.constructor.title);
    if (this.onConnectionsChange) {
      if (this.inputs) {
        for (c = 0; c < this.inputs.length; ++c) {
          b = this.inputs[c];
          var e = this.graph ? this.graph.links[b.link] : null;
          this.onConnectionsChange(d.INPUT, c, !0, e, b);
        }
      }
      if (this.outputs) {
        for (c = 0; c < this.outputs.length; ++c) {
          var f = this.outputs[c];
          if (f.links) {
            for (b = 0; b < f.links.length; ++b) {
              e = this.graph ? this.graph.links[f.links[b]] : null, this.onConnectionsChange(d.OUTPUT, c, !0, e, f);
            }
          }
        }
      }
    }
    if (this.widgets) {
      for (c = 0; c < this.widgets.length; ++c) {
        b = this.widgets[c], b.options && b.options.property && this.properties[b.options.property] && (b.value = JSON.parse(JSON.stringify(this.properties[b.options.property])));
      }
      if (a.widgets_values) {
        for (c = 0; c < a.widgets_values.length; ++c) {
          this.widgets[c] && (this.widgets[c].value = a.widgets_values[c]);
        }
      }
    }
    if (this.onConfigure) {
      this.onConfigure(a);
    }
  };
  h.prototype.serialize = function() {
    var a = {id:this.id, type:this.type, pos:this.pos, size:this.size, flags:d.cloneObject(this.flags), order:this.order, mode:this.mode};
    if (this.constructor === h && this.last_serialization) {
      return this.last_serialization;
    }
    this.inputs && (a.inputs = this.inputs);
    if (this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        delete this.outputs[b]._data;
      }
      a.outputs = this.outputs;
    }
    this.title && this.title != this.constructor.title && (a.title = this.title);
    this.properties && (a.properties = d.cloneObject(this.properties));
    if (this.widgets && this.serialize_widgets) {
      for (a.widgets_values = [], b = 0; b < this.widgets.length; ++b) {
        a.widgets_values[b] = this.widgets[b].value;
      }
    }
    a.type || (a.type = this.constructor.type);
    this.color && (a.color = this.color);
    this.bgcolor && (a.bgcolor = this.bgcolor);
    this.boxcolor && (a.boxcolor = this.boxcolor);
    this.shape && (a.shape = this.shape);
    this.onSerialize && this.onSerialize(a) && console.warn("node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter");
    return a;
  };
  h.prototype.clone = function() {
    var a = d.createNode(this.type);
    if (!a) {
      return null;
    }
    var b = d.cloneObject(this.serialize());
    if (b.inputs) {
      for (var c = 0; c < b.inputs.length; ++c) {
        b.inputs[c].link = null;
      }
    }
    if (b.outputs) {
      for (c = 0; c < b.outputs.length; ++c) {
        b.outputs[c].links && (b.outputs[c].links.length = 0);
      }
    }
    delete b.id;
    a.configure(b);
    return a;
  };
  h.prototype.toString = function() {
    return JSON.stringify(this.serialize());
  };
  h.prototype.getTitle = function() {
    return this.title || this.constructor.title;
  };
  h.prototype.setProperty = function(a, b) {
    this.properties || (this.properties = {});
    if (b !== this.properties[a]) {
      var c = this.properties[a];
      this.properties[a] = b;
      this.onPropertyChanged && !1 === this.onPropertyChanged(a, b, c) && (this.properties[a] = c);
    }
  };
  h.prototype.setOutputData = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var c = this.outputs[a];
      if (c && (c._data = b, this.outputs[a].links)) {
        for (c = 0; c < this.outputs[a].links.length; c++) {
          var e = this.graph.links[this.outputs[a].links[c]];
          e && (e.data = b);
        }
      }
    }
  };
  h.prototype.setOutputDataType = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var c = this.outputs[a];
      if (c && (c.type = b, this.outputs[a].links)) {
        for (c = 0; c < this.outputs[a].links.length; c++) {
          this.graph.links[this.outputs[a].links[c]].type = b;
        }
      }
    }
  };
  h.prototype.getInputData = function(a, b) {
    if (this.inputs && !(a >= this.inputs.length || null == this.inputs[a].link)) {
      a = this.graph.links[this.inputs[a].link];
      if (!a) {
        return null;
      }
      if (!b) {
        return a.data;
      }
      b = this.graph.getNodeById(a.origin_id);
      if (!b) {
        return a.data;
      }
      if (b.updateOutputData) {
        b.updateOutputData(a.origin_slot);
      } else {
        if (b.onExecute) {
          b.onExecute();
        }
      }
      return a.data;
    }
  };
  h.prototype.getInputDataType = function(a) {
    if (!this.inputs || a >= this.inputs.length || null == this.inputs[a].link) {
      return null;
    }
    a = this.graph.links[this.inputs[a].link];
    if (!a) {
      return null;
    }
    var b = this.graph.getNodeById(a.origin_id);
    return b ? (a = b.outputs[a.origin_slot]) ? a.type : null : a.type;
  };
  h.prototype.getInputDataByName = function(a, b) {
    a = this.findInputSlot(a);
    return -1 == a ? null : this.getInputData(a, b);
  };
  h.prototype.isInputConnected = function(a) {
    return this.inputs ? a < this.inputs.length && null != this.inputs[a].link : !1;
  };
  h.prototype.getInputInfo = function(a) {
    return this.inputs ? a < this.inputs.length ? this.inputs[a] : null : null;
  };
  h.prototype.getInputNode = function(a) {
    if (!this.inputs || a >= this.inputs.length) {
      return null;
    }
    a = this.inputs[a];
    return a && null !== a.link ? (a = this.graph.links[a.link]) ? this.graph.getNodeById(a.origin_id) : null : null;
  };
  h.prototype.getInputOrProperty = function(a) {
    if (!this.inputs || !this.inputs.length) {
      return this.properties ? this.properties[a] : null;
    }
    for (var b = 0, c = this.inputs.length; b < c; ++b) {
      var e = this.inputs[b];
      if (a == e.name && null != e.link && (e = this.graph.links[e.link])) {
        return e.data;
      }
    }
    return this.properties[a];
  };
  h.prototype.getOutputData = function(a) {
    return !this.outputs || a >= this.outputs.length ? null : this.outputs[a]._data;
  };
  h.prototype.getOutputInfo = function(a) {
    return this.outputs ? a < this.outputs.length ? this.outputs[a] : null : null;
  };
  h.prototype.isOutputConnected = function(a) {
    return this.outputs ? a < this.outputs.length && this.outputs[a].links && this.outputs[a].links.length : !1;
  };
  h.prototype.isAnyOutputConnected = function() {
    if (!this.outputs) {
      return !1;
    }
    for (var a = 0; a < this.outputs.length; ++a) {
      if (this.outputs[a].links && this.outputs[a].links.length) {
        return !0;
      }
    }
    return !1;
  };
  h.prototype.getOutputNodes = function(a) {
    if (!this.outputs || 0 == this.outputs.length || a >= this.outputs.length) {
      return null;
    }
    a = this.outputs[a];
    if (!a.links || 0 == a.links.length) {
      return null;
    }
    for (var b = [], c = 0; c < a.links.length; c++) {
      var e = this.graph.links[a.links[c]];
      e && (e = this.graph.getNodeById(e.target_id)) && b.push(e);
    }
    return b;
  };
  h.prototype.trigger = function(a, b) {
    if (this.outputs && this.outputs.length) {
      this.graph && (this.graph._last_trigger_time = d.getTime());
      for (var c = 0; c < this.outputs.length; ++c) {
        var e = this.outputs[c];
        !e || e.type !== d.EVENT || a && e.name != a || this.triggerSlot(c, b);
      }
    }
  };
  h.prototype.triggerSlot = function(a, b, c) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      this.graph && (this.graph._last_trigger_time = d.getTime());
      for (var e = 0; e < a.length; ++e) {
        var f = a[e];
        if (null == c || c == f) {
          var n = this.graph.links[a[e]];
          if (n && (n._last_time = d.getTime(), f = this.graph.getNodeById(n.target_id))) {
            if (n = f.inputs[n.target_slot], f.onAction) {
              f.onAction(n.name, b);
            } else {
              if (f.mode === d.ON_TRIGGER && f.onExecute) {
                f.onExecute(b);
              }
            }
          }
        }
      }
    }
  };
  h.prototype.clearTriggeredSlot = function(a, b) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      for (var c = 0; c < a.length; ++c) {
        var e = a[c];
        if (null == b || b == e) {
          if (e = this.graph.links[a[c]]) {
            e._last_time = 0;
          }
        }
      }
    }
  };
  h.prototype.addProperty = function(a, b, c, e) {
    c = {name:a, type:c, default_value:b};
    if (e) {
      for (var f in e) {
        c[f] = e[f];
      }
    }
    this.properties_info || (this.properties_info = []);
    this.properties_info.push(c);
    this.properties || (this.properties = {});
    this.properties[a] = b;
    return c;
  };
  h.prototype.addOutput = function(a, b, c) {
    a = {name:a, type:b, links:null};
    if (c) {
      for (var e in c) {
        a[e] = c[e];
      }
    }
    this.outputs || (this.outputs = []);
    this.outputs.push(a);
    if (this.onOutputAdded) {
      this.onOutputAdded(a);
    }
    this.size = this.computeSize();
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  h.prototype.addOutputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var c = a[b], e = {name:c[0], type:c[1], link:null};
      if (a[2]) {
        for (var f in c[2]) {
          e[f] = c[2][f];
        }
      }
      this.outputs || (this.outputs = []);
      this.outputs.push(e);
      if (this.onOutputAdded) {
        this.onOutputAdded(e);
      }
    }
    this.size = this.computeSize();
    this.setDirtyCanvas(!0, !0);
  };
  h.prototype.removeOutput = function(a) {
    this.disconnectOutput(a);
    this.outputs.splice(a, 1);
    for (var b = a; b < this.outputs.length; ++b) {
      if (this.outputs[b] && this.outputs[b].links) {
        for (var c = this.outputs[b].links, e = 0; e < c.length; ++e) {
          var f = this.graph.links[c[e]];
          f && --f.origin_slot;
        }
      }
    }
    this.size = this.computeSize();
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    this.setDirtyCanvas(!0, !0);
  };
  h.prototype.addInput = function(a, b, c) {
    a = {name:a, type:b || 0, link:null};
    if (c) {
      for (var e in c) {
        a[e] = c[e];
      }
    }
    this.inputs || (this.inputs = []);
    this.inputs.push(a);
    this.size = this.computeSize();
    if (this.onInputAdded) {
      this.onInputAdded(a);
    }
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  h.prototype.addInputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var c = a[b], e = {name:c[0], type:c[1], link:null};
      if (a[2]) {
        for (var f in c[2]) {
          e[f] = c[2][f];
        }
      }
      this.inputs || (this.inputs = []);
      this.inputs.push(e);
      if (this.onInputAdded) {
        this.onInputAdded(e);
      }
    }
    this.size = this.computeSize();
    this.setDirtyCanvas(!0, !0);
  };
  h.prototype.removeInput = function(a) {
    this.disconnectInput(a);
    this.inputs.splice(a, 1);
    for (var b = a; b < this.inputs.length; ++b) {
      if (this.inputs[b]) {
        var c = this.graph.links[this.inputs[b].link];
        c && --c.target_slot;
      }
    }
    this.size = this.computeSize();
    if (this.onInputRemoved) {
      this.onInputRemoved(a);
    }
    this.setDirtyCanvas(!0, !0);
  };
  h.prototype.addConnection = function(a, b, c, e) {
    a = {name:a, type:b, pos:c, direction:e, links:null};
    this.connections.push(a);
    return a;
  };
  h.prototype.computeSize = function(a, b) {
    function c(a) {
      return a ? e * a.length * 0.6 : 0;
    }
    if (this.constructor.size) {
      return this.constructor.size.concat();
    }
    a = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1);
    b = b || new Float32Array([0, 0]);
    a = Math.max(a, 1);
    var e = d.NODE_TEXT_SIZE;
    b[1] = (this.constructor.slot_start_y || 0) + a * d.NODE_SLOT_HEIGHT;
    a = 0;
    this.widgets && this.widgets.length && (a = this.widgets.length * (d.NODE_WIDGET_HEIGHT + 4) + 8);
    b[1] = this.widgets_up ? Math.max(b[1], a) : null != this.widgets_start_y ? Math.max(b[1], a + this.widgets_start_y) : b[1] + a;
    a = c(this.title);
    var f = 0, n = 0;
    if (this.inputs) {
      for (var g = 0, q = this.inputs.length; g < q; ++g) {
        var l = this.inputs[g];
        l = l.label || l.name || "";
        l = c(l);
        f < l && (f = l);
      }
    }
    if (this.outputs) {
      for (g = 0, q = this.outputs.length; g < q; ++g) {
        l = this.outputs[g], l = l.label || l.name || "", l = c(l), n < l && (n = l);
      }
    }
    b[0] = Math.max(f + n + 10, a);
    b[0] = Math.max(b[0], d.NODE_WIDTH);
    this.widgets && this.widgets.length && (b[0] = Math.max(b[0], 1.5 * d.NODE_WIDTH));
    if (this.onResize) {
      this.onResize(b);
    }
    this.constructor.min_height && b[1] < this.constructor.min_height && (b[1] = this.constructor.min_height);
    b[1] += 6;
    return b;
  };
  h.prototype.addWidget = function(a, b, c, e, f) {
    this.widgets || (this.widgets = []);
    !f && e && e.constructor === Object && (f = e, e = null);
    f && f.constructor === String && (f = {property:f});
    e && e.constructor === String && (f || (f = {}), f.property = e, e = null);
    e && e.constructor !== Function && (console.warn("addWidget: callback must be a function"), e = null);
    b = {type:a.toLowerCase(), name:b, value:c, callback:e, options:f || {}};
    void 0 !== b.options.y && (b.y = b.options.y);
    e || b.options.callback || b.options.property || console.warn("LiteGraph addWidget(...) without a callback or property assigned");
    if ("combo" == a && !b.options.values) {
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
    }
    this.widgets.push(b);
    this.size = this.computeSize();
    return b;
  };
  h.prototype.addCustomWidget = function(a) {
    this.widgets || (this.widgets = []);
    this.widgets.push(a);
    return a;
  };
  h.prototype.getBounding = function(a) {
    a = a || new Float32Array(4);
    a[0] = this.pos[0] - 4;
    a[1] = this.pos[1] - d.NODE_TITLE_HEIGHT;
    a[2] = this.size[0] + 4;
    a[3] = this.size[1] + d.NODE_TITLE_HEIGHT;
    if (this.onBounding) {
      this.onBounding(a);
    }
    return a;
  };
  h.prototype.isPointInside = function(a, b, c, e) {
    c = c || 0;
    var f = this.graph && this.graph.isLive() ? 0 : d.NODE_TITLE_HEIGHT;
    e && (f = 0);
    if (this.flags && this.flags.collapsed) {
      if (C(a, b, this.pos[0] - c, this.pos[1] - d.NODE_TITLE_HEIGHT - c, (this._collapsed_width || d.NODE_COLLAPSED_WIDTH) + 2 * c, d.NODE_TITLE_HEIGHT + 2 * c)) {
        return !0;
      }
    } else {
      if (this.pos[0] - 4 - c < a && this.pos[0] + this.size[0] + 4 + c > a && this.pos[1] - f - c < b && this.pos[1] + this.size[1] + c > b) {
        return !0;
      }
    }
    return !1;
  };
  h.prototype.getSlotInPosition = function(a, b) {
    var c = new Float32Array(2);
    if (this.inputs) {
      for (var e = 0, f = this.inputs.length; e < f; ++e) {
        var d = this.inputs[e];
        this.getConnectionPos(!0, e, c);
        if (C(a, b, c[0] - 10, c[1] - 5, 20, 10)) {
          return {input:d, slot:e, link_pos:c};
        }
      }
    }
    if (this.outputs) {
      for (e = 0, f = this.outputs.length; e < f; ++e) {
        if (d = this.outputs[e], this.getConnectionPos(!1, e, c), C(a, b, c[0] - 10, c[1] - 5, 20, 10)) {
          return {output:d, slot:e, link_pos:c};
        }
      }
    }
    return null;
  };
  h.prototype.findInputSlot = function(a) {
    if (!this.inputs) {
      return -1;
    }
    for (var b = 0, c = this.inputs.length; b < c; ++b) {
      if (a == this.inputs[b].name) {
        return b;
      }
    }
    return -1;
  };
  h.prototype.findOutputSlot = function(a) {
    if (!this.outputs) {
      return -1;
    }
    for (var b = 0, c = this.outputs.length; b < c; ++b) {
      if (a == this.outputs[b].name) {
        return b;
      }
    }
    return -1;
  };
  h.prototype.connect = function(a, b, c) {
    c = c || 0;
    if (!this.graph) {
      return console.log("Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."), null;
    }
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return d.debug && console.log("Connect: Error, no slot of name " + a), null;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return d.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    b && b.constructor === Number && (b = this.graph.getNodeById(b));
    if (!b) {
      throw "target node is null";
    }
    if (b == this) {
      return null;
    }
    if (c.constructor === String) {
      if (c = b.findInputSlot(c), -1 == c) {
        return d.debug && console.log("Connect: Error, no slot of name " + c), null;
      }
    } else {
      if (c === d.EVENT) {
        return null;
      }
      if (!b.inputs || c >= b.inputs.length) {
        return d.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    null != b.inputs[c].link && b.disconnectInput(c);
    var e = this.outputs[a];
    if (b.onConnectInput && !1 === b.onConnectInput(c, e.type, e)) {
      return null;
    }
    var f = b.inputs[c], n = null;
    if (d.isValidConnection(e.type, f.type)) {
      n = new t(++this.graph.last_link_id, f.type, this.id, a, b.id, c);
      this.graph.links[n.id] = n;
      null == e.links && (e.links = []);
      e.links.push(n.id);
      b.inputs[c].link = n.id;
      this.graph && this.graph._version++;
      if (this.onConnectionsChange) {
        this.onConnectionsChange(d.OUTPUT, a, !0, n, e);
      }
      if (b.onConnectionsChange) {
        b.onConnectionsChange(d.INPUT, c, !0, n, f);
      }
      this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(d.INPUT, b, c, this, a), this.graph.onNodeConnectionChange(d.OUTPUT, this, a, b, c));
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this, n);
    return n;
  };
  h.prototype.disconnectOutput = function(a, b) {
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return d.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return d.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var c = this.outputs[a];
    if (!c || !c.links || 0 == c.links.length) {
      return !1;
    }
    if (b) {
      b.constructor === Number && (b = this.graph.getNodeById(b));
      if (!b) {
        throw "Target Node not found";
      }
      for (var e = 0, f = c.links.length; e < f; e++) {
        var n = c.links[e], g = this.graph.links[n];
        if (g.target_id == b.id) {
          c.links.splice(e, 1);
          var q = b.inputs[g.target_slot];
          q.link = null;
          delete this.graph.links[n];
          this.graph && this.graph._version++;
          if (b.onConnectionsChange) {
            b.onConnectionsChange(d.INPUT, g.target_slot, !1, g, q);
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(d.OUTPUT, a, !1, g, c);
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(d.OUTPUT, this, a);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(d.OUTPUT, this, a), this.graph.onNodeConnectionChange(d.INPUT, b, g.target_slot));
          break;
        }
      }
    } else {
      e = 0;
      for (f = c.links.length; e < f; e++) {
        if (n = c.links[e], g = this.graph.links[n]) {
          b = this.graph.getNodeById(g.target_id);
          this.graph && this.graph._version++;
          if (b) {
            q = b.inputs[g.target_slot];
            q.link = null;
            if (b.onConnectionsChange) {
              b.onConnectionsChange(d.INPUT, g.target_slot, !1, g, q);
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(d.INPUT, b, g.target_slot);
            }
          }
          delete this.graph.links[n];
          if (this.onConnectionsChange) {
            this.onConnectionsChange(d.OUTPUT, a, !1, g, c);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(d.OUTPUT, this, a), this.graph.onNodeConnectionChange(d.INPUT, b, g.target_slot));
        }
      }
      c.links = null;
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  h.prototype.disconnectInput = function(a) {
    if (a.constructor === String) {
      if (a = this.findInputSlot(a), -1 == a) {
        return d.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.inputs || a >= this.inputs.length) {
        return d.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var b = this.inputs[a];
    if (!b) {
      return !1;
    }
    var c = this.inputs[a].link;
    this.inputs[a].link = null;
    var e = this.graph.links[c];
    if (e) {
      var f = this.graph.getNodeById(e.origin_id);
      if (!f) {
        return !1;
      }
      var n = f.outputs[e.origin_slot];
      if (!n || !n.links || 0 == n.links.length) {
        return !1;
      }
      for (var g = 0, q = n.links.length; g < q; g++) {
        if (n.links[g] == c) {
          n.links.splice(g, 1);
          break;
        }
      }
      delete this.graph.links[c];
      this.graph && this.graph._version++;
      if (this.onConnectionsChange) {
        this.onConnectionsChange(d.INPUT, a, !1, e, b);
      }
      if (f.onConnectionsChange) {
        f.onConnectionsChange(d.OUTPUT, g, !1, e, n);
      }
      this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(d.OUTPUT, f, g), this.graph.onNodeConnectionChange(d.INPUT, this, a));
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  h.prototype.getConnectionPos = function(a, b, c) {
    c = c || new Float32Array(2);
    var e = 0;
    a && this.inputs && (e = this.inputs.length);
    !a && this.outputs && (e = this.outputs.length);
    var f = 0.5 * d.NODE_SLOT_HEIGHT;
    if (this.flags.collapsed) {
      return b = this._collapsed_width || d.NODE_COLLAPSED_WIDTH, this.horizontal ? (c[0] = this.pos[0] + 0.5 * b, c[1] = a ? this.pos[1] - d.NODE_TITLE_HEIGHT : this.pos[1]) : (c[0] = a ? this.pos[0] : this.pos[0] + b, c[1] = this.pos[1] - 0.5 * d.NODE_TITLE_HEIGHT), c;
    }
    if (a && -1 == b) {
      return c[0] = this.pos[0] + 0.5 * d.NODE_TITLE_HEIGHT, c[1] = this.pos[1] + 0.5 * d.NODE_TITLE_HEIGHT, c;
    }
    if (a && e > b && this.inputs[b].pos) {
      return c[0] = this.pos[0] + this.inputs[b].pos[0], c[1] = this.pos[1] + this.inputs[b].pos[1], c;
    }
    if (!a && e > b && this.outputs[b].pos) {
      return c[0] = this.pos[0] + this.outputs[b].pos[0], c[1] = this.pos[1] + this.outputs[b].pos[1], c;
    }
    if (this.horizontal) {
      return c[0] = this.pos[0] + this.size[0] / e * (b + 0.5), c[1] = a ? this.pos[1] - d.NODE_TITLE_HEIGHT : this.pos[1] + this.size[1], c;
    }
    c[0] = a ? this.pos[0] + f : this.pos[0] + this.size[0] + 1 - f;
    c[1] = this.pos[1] + (b + 0.7) * d.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
    return c;
  };
  h.prototype.alignToGrid = function() {
    this.pos[0] = d.CANVAS_GRID_SIZE * Math.round(this.pos[0] / d.CANVAS_GRID_SIZE);
    this.pos[1] = d.CANVAS_GRID_SIZE * Math.round(this.pos[1] / d.CANVAS_GRID_SIZE);
  };
  h.prototype.trace = function(a) {
    this.console || (this.console = []);
    this.console.push(a);
    this.console.length > h.MAX_CONSOLE && this.console.shift();
    this.graph.onNodeTrace(this, a);
  };
  h.prototype.setDirtyCanvas = function(a, b) {
    this.graph && this.graph.sendActionToCanvas("setDirty", [a, b]);
  };
  h.prototype.loadImage = function(a) {
    var b = new Image;
    b.src = d.node_images_path + a;
    b.ready = !1;
    var c = this;
    b.onload = function() {
      this.ready = !0;
      c.setDirtyCanvas(!0);
    };
    return b;
  };
  h.prototype.captureInput = function(a) {
    if (this.graph && this.graph.list_of_graphcanvas) {
      for (var b = this.graph.list_of_graphcanvas, c = 0; c < b.length; ++c) {
        var e = b[c];
        if (a || e.node_capturing_input == this) {
          e.node_capturing_input = a ? this : null;
        }
      }
    }
  };
  h.prototype.collapse = function(a) {
    this.graph._version++;
    if (!1 !== this.constructor.collapsable || a) {
      this.flags.collapsed = this.flags.collapsed ? !1 : !0, this.setDirtyCanvas(!0, !0);
    }
  };
  h.prototype.pin = function(a) {
    this.graph._version++;
    this.flags.pinned = void 0 === a ? !this.flags.pinned : a;
  };
  h.prototype.localToScreen = function(a, b, c) {
    return [(a + this.pos[0]) * c.scale + c.offset[0], (b + this.pos[1]) * c.scale + c.offset[1]];
  };
  p.LGraphGroup = d.LGraphGroup = A;
  A.prototype._ctor = function(a) {
    this.title = a || "Group";
    this.font_size = 24;
    this.color = k.node_colors.pale_blue ? k.node_colors.pale_blue.groupcolor : "#AAA";
    this._bounding = new Float32Array([10, 10, 140, 80]);
    this._pos = this._bounding.subarray(0, 2);
    this._size = this._bounding.subarray(2, 4);
    this._nodes = [];
    this.graph = null;
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    Object.defineProperty(this, "size", {set:function(a) {
      !a || 2 > a.length || (this._size[0] = Math.max(140, a[0]), this._size[1] = Math.max(80, a[1]));
    }, get:function() {
      return this._size;
    }, enumerable:!0});
  };
  A.prototype.configure = function(a) {
    this.title = a.title;
    this._bounding.set(a.bounding);
    this.color = a.color;
    this.font = a.font;
  };
  A.prototype.serialize = function() {
    var a = this._bounding;
    return {title:this.title, bounding:[Math.round(a[0]), Math.round(a[1]), Math.round(a[2]), Math.round(a[3])], color:this.color, font:this.font};
  };
  A.prototype.move = function(a, b, c) {
    this._pos[0] += a;
    this._pos[1] += b;
    if (!c) {
      for (c = 0; c < this._nodes.length; ++c) {
        var e = this._nodes[c];
        e.pos[0] += a;
        e.pos[1] += b;
      }
    }
  };
  A.prototype.recomputeInsideNodes = function() {
    this._nodes.length = 0;
    for (var a = this.graph._nodes, b = new Float32Array(4), c = 0; c < a.length; ++c) {
      var e = a[c];
      e.getBounding(b);
      I(this._bounding, b) && this._nodes.push(e);
    }
  };
  A.prototype.isPointInside = h.prototype.isPointInside;
  A.prototype.setDirtyCanvas = h.prototype.setDirtyCanvas;
  d.DragAndScale = B;
  B.prototype.bindEvents = function(a) {
    this.last_mouse = new Float32Array(2);
    this._binded_mouse_callback = this.onMouse.bind(this);
    a.addEventListener("mousedown", this._binded_mouse_callback);
    a.addEventListener("mousemove", this._binded_mouse_callback);
    a.addEventListener("mousewheel", this._binded_mouse_callback, !1);
    a.addEventListener("wheel", this._binded_mouse_callback, !1);
  };
  B.prototype.computeVisibleArea = function() {
    if (this.element) {
      var a = -this.offset[0], b = -this.offset[1], c = a + this.element.width / this.scale, e = b + this.element.height / this.scale;
      this.visible_area[0] = a;
      this.visible_area[1] = b;
      this.visible_area[2] = c - a;
      this.visible_area[3] = e - b;
    } else {
      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
    }
  };
  B.prototype.onMouse = function(a) {
    if (this.enabled) {
      var b = this.element, c = b.getBoundingClientRect(), e = a.clientX - c.left;
      c = a.clientY - c.top;
      a.canvasx = e;
      a.canvasy = c;
      a.dragging = this.dragging;
      var f = !1;
      this.onmouse && (f = this.onmouse(a));
      if ("mousedown" == a.type) {
        this.dragging = !0, b.removeEventListener("mousemove", this._binded_mouse_callback), document.body.addEventListener("mousemove", this._binded_mouse_callback), document.body.addEventListener("mouseup", this._binded_mouse_callback);
      } else {
        if ("mousemove" == a.type) {
          f || (b = e - this.last_mouse[0], f = c - this.last_mouse[1], this.dragging && this.mouseDrag(b, f));
        } else {
          if ("mouseup" == a.type) {
            this.dragging = !1, document.body.removeEventListener("mousemove", this._binded_mouse_callback), document.body.removeEventListener("mouseup", this._binded_mouse_callback), b.addEventListener("mousemove", this._binded_mouse_callback);
          } else {
            if ("mousewheel" == a.type || "wheel" == a.type || "DOMMouseScroll" == a.type) {
              a.eventType = "mousewheel", a.wheel = "wheel" == a.type ? -a.deltaY : null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail, a.delta = a.wheelDelta ? a.wheelDelta / 40 : a.deltaY ? -a.deltaY / 3 : 0, this.changeDeltaScale(1.0 + 0.05 * a.delta);
            }
          }
        }
      }
      this.last_mouse[0] = e;
      this.last_mouse[1] = c;
      a.preventDefault();
      a.stopPropagation();
      return !1;
    }
  };
  B.prototype.toCanvasContext = function(a) {
    a.scale(this.scale, this.scale);
    a.translate(this.offset[0], this.offset[1]);
  };
  B.prototype.convertOffsetToCanvas = function(a) {
    return [(a[0] + this.offset[0]) * this.scale, (a[1] + this.offset[1]) * this.scale];
  };
  B.prototype.convertCanvasToOffset = function(a, b) {
    b = b || [0, 0];
    b[0] = a[0] / this.scale - this.offset[0];
    b[1] = a[1] / this.scale - this.offset[1];
    return b;
  };
  B.prototype.mouseDrag = function(a, b) {
    this.offset[0] += a / this.scale;
    this.offset[1] += b / this.scale;
    if (this.onredraw) {
      this.onredraw(this);
    }
  };
  B.prototype.changeScale = function(a, b) {
    a < this.min_scale ? a = this.min_scale : a > this.max_scale && (a = this.max_scale);
    if (a != this.scale && this.element) {
      var c = this.element.getBoundingClientRect();
      if (c && (b = b || [0.5 * c.width, 0.5 * c.height], c = this.convertCanvasToOffset(b), this.scale = a, 0.01 > Math.abs(this.scale - 1) && (this.scale = 1), a = this.convertCanvasToOffset(b), a = [a[0] - c[0], a[1] - c[1]], this.offset[0] += a[0], this.offset[1] += a[1], this.onredraw)) {
        this.onredraw(this);
      }
    }
  };
  B.prototype.changeDeltaScale = function(a, b) {
    this.changeScale(this.scale * a, b);
  };
  B.prototype.reset = function() {
    this.scale = 1;
    this.offset[0] = 0;
    this.offset[1] = 0;
  };
  p.LGraphCanvas = d.LGraphCanvas = k;
  k.link_type_colors = {"-1":d.EVENT_LINK_COLOR, number:"#AAA", node:"#DCA"};
  k.gradients = {};
  k.prototype.clear = function() {
    this.fps = this.render_time = this.last_draw_time = this.frame = 0;
    this.dragging_rectangle = null;
    this.selected_nodes = {};
    this.selected_group = null;
    this.visible_nodes = [];
    this.connecting_node = this.node_capturing_input = this.node_over = this.node_dragged = null;
    this.highlighted_links = {};
    this.dirty_bgcanvas = this.dirty_canvas = !0;
    this.node_widget = this.node_in_panel = this.dirty_area = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    this.visible_area.set([0, 0, 0, 0]);
    if (this.onClear) {
      this.onClear();
    }
  };
  k.prototype.setGraph = function(a, b) {
    this.graph != a && (b || this.clear(), !a && this.graph ? this.graph.detachCanvas(this) : (a.attachCanvas(this), this.setDirty(!0, !0)));
  };
  k.prototype.openSubgraph = function(a) {
    if (!a) {
      throw "graph cannot be null";
    }
    if (this.graph == a) {
      throw "graph cannot be the same";
    }
    this.clear();
    this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph));
    a.attachCanvas(this);
    this.setDirty(!0, !0);
  };
  k.prototype.closeSubgraph = function() {
    if (this._graph_stack && 0 != this._graph_stack.length) {
      var a = this.graph._subgraph_node, b = this._graph_stack.pop();
      this.selected_nodes = {};
      this.highlighted_links = {};
      b.attachCanvas(this);
      this.setDirty(!0, !0);
      a && (this.centerOnNode(a), this.selectNodes([a]));
    }
  };
  k.prototype.getCurrentGraph = function() {
    return this.graph;
  };
  k.prototype.setCanvas = function(a, b) {
    if (a && a.constructor === String && (a = document.getElementById(a), !a)) {
      throw "Error creating LiteGraph canvas: Canvas not found";
    }
    if (a !== this.canvas && (!a && this.canvas && (b || this.unbindEvents()), this.canvas = a, this.ds.element = a)) {
      a.className += " lgraphcanvas";
      a.data = this;
      a.tabindex = "1";
      this.bgcanvas = null;
      this.bgcanvas || (this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height);
      if (null == a.getContext) {
        if ("canvas" != a.localName) {
          throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + a.localName;
        }
        throw "This browser doesn't support Canvas";
      }
      null == (this.ctx = a.getContext("2d")) && (a.webgl_enabled || console.warn("This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL());
      this._mousemove_callback = this.processMouseMove.bind(this);
      this._mouseup_callback = this.processMouseUp.bind(this);
      b || this.bindEvents();
    }
  };
  k.prototype._doNothing = function(a) {
    a.preventDefault();
    return !1;
  };
  k.prototype._doReturnTrue = function(a) {
    a.preventDefault();
    return !0;
  };
  k.prototype.bindEvents = function() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
    } else {
      var a = this.canvas, b = this.getCanvasWindow().document;
      this._mousedown_callback = this.processMouseDown.bind(this);
      this._mousewheel_callback = this.processMouseWheel.bind(this);
      a.addEventListener("mousedown", this._mousedown_callback, !0);
      a.addEventListener("mousemove", this._mousemove_callback);
      a.addEventListener("mousewheel", this._mousewheel_callback, !1);
      a.addEventListener("contextmenu", this._doNothing);
      a.addEventListener("DOMMouseScroll", this._mousewheel_callback, !1);
      a.addEventListener("touchstart", this.touchHandler, !0);
      a.addEventListener("touchmove", this.touchHandler, !0);
      a.addEventListener("touchend", this.touchHandler, !0);
      a.addEventListener("touchcancel", this.touchHandler, !0);
      this._key_callback = this.processKey.bind(this);
      a.addEventListener("keydown", this._key_callback, !0);
      b.addEventListener("keyup", this._key_callback, !0);
      this._ondrop_callback = this.processDrop.bind(this);
      a.addEventListener("dragover", this._doNothing, !1);
      a.addEventListener("dragend", this._doNothing, !1);
      a.addEventListener("drop", this._ondrop_callback, !1);
      a.addEventListener("dragenter", this._doReturnTrue, !1);
      this._events_binded = !0;
    }
  };
  k.prototype.unbindEvents = function() {
    if (this._events_binded) {
      var a = this.getCanvasWindow().document;
      this.canvas.removeEventListener("mousedown", this._mousedown_callback);
      this.canvas.removeEventListener("mousewheel", this._mousewheel_callback);
      this.canvas.removeEventListener("DOMMouseScroll", this._mousewheel_callback);
      this.canvas.removeEventListener("keydown", this._key_callback);
      a.removeEventListener("keyup", this._key_callback);
      this.canvas.removeEventListener("contextmenu", this._doNothing);
      this.canvas.removeEventListener("drop", this._ondrop_callback);
      this.canvas.removeEventListener("dragenter", this._doReturnTrue);
      this.canvas.removeEventListener("touchstart", this.touchHandler);
      this.canvas.removeEventListener("touchmove", this.touchHandler);
      this.canvas.removeEventListener("touchend", this.touchHandler);
      this.canvas.removeEventListener("touchcancel", this.touchHandler);
      this._ondrop_callback = this._key_callback = this._mousewheel_callback = this._mousedown_callback = null;
      this._events_binded = !1;
    } else {
      console.warn("LGraphCanvas: no events binded");
    }
  };
  k.getFileExtension = function(a) {
    var b = a.indexOf("?");
    -1 != b && (a = a.substr(0, b));
    b = a.lastIndexOf(".");
    return -1 == b ? "" : a.substr(b + 1).toLowerCase();
  };
  k.prototype.enableWebGL = function() {
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = !0;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
    this.canvas.webgl_enabled = !0;
  };
  k.prototype.setDirty = function(a, b) {
    a && (this.dirty_canvas = !0);
    b && (this.dirty_bgcanvas = !0);
  };
  k.prototype.getCanvasWindow = function() {
    if (!this.canvas) {
      return window;
    }
    var a = this.canvas.ownerDocument;
    return a.defaultView || a.parentWindow;
  };
  k.prototype.startRendering = function() {
    function a() {
      this.pause_rendering || this.draw();
      var b = this.getCanvasWindow();
      this.is_rendering && b.requestAnimationFrame(a.bind(this));
    }
    this.is_rendering || (this.is_rendering = !0, a.call(this));
  };
  k.prototype.stopRendering = function() {
    this.is_rendering = !1;
  };
  k.prototype.processMouseDown = function(a) {
    if (this.graph) {
      this.adjustMouseEvent(a);
      var b = this.getCanvasWindow();
      k.active_canvas = this;
      this.canvas.removeEventListener("mousemove", this._mousemove_callback);
      b.document.addEventListener("mousemove", this._mousemove_callback, !0);
      b.document.addEventListener("mouseup", this._mouseup_callback, !0);
      var c = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes, 5), e = !1, f = 300 > d.getTime() - this.last_mouseclick;
      this.canvas_mouse[0] = a.canvasX;
      this.canvas_mouse[1] = a.canvasY;
      this.canvas.focus();
      d.closeAllContextMenus(b);
      if (!this.onMouse || 1 != this.onMouse(a)) {
        if (1 == a.which) {
          a.ctrlKey && (this.dragging_rectangle = new Float32Array(4), this.dragging_rectangle[0] = a.canvasX, this.dragging_rectangle[1] = a.canvasY, this.dragging_rectangle[2] = 1, this.dragging_rectangle[3] = 1, e = !0);
          var n = !1;
          if (c && this.allow_interaction && !e && !this.read_only) {
            this.live_mode || c.flags.pinned || this.bringToFront(c);
            if (!this.connecting_node && !c.flags.collapsed && !this.live_mode) {
              if (!e && !1 !== c.resizable && C(a.canvasX, a.canvasY, c.pos[0] + c.size[0] - 5, c.pos[1] + c.size[1] - 5, 10, 10)) {
                this.resizing_node = c, this.canvas.style.cursor = "se-resize", e = !0;
              } else {
                if (c.outputs) {
                  for (var g = 0, q = c.outputs.length; g < q; ++g) {
                    var l = c.outputs[g], x = c.getConnectionPos(!1, g);
                    if (C(a.canvasX, a.canvasY, x[0] - 15, x[1] - 10, 30, 20)) {
                      this.connecting_node = c;
                      this.connecting_output = l;
                      this.connecting_pos = c.getConnectionPos(!1, g);
                      this.connecting_slot = g;
                      a.shiftKey && c.disconnectOutput(g);
                      if (f) {
                        if (c.onOutputDblClick) {
                          c.onOutputDblClick(g, a);
                        }
                      } else {
                        if (c.onOutputClick) {
                          c.onOutputClick(g, a);
                        }
                      }
                      e = !0;
                      break;
                    }
                  }
                }
                if (c.inputs) {
                  for (g = 0, q = c.inputs.length; g < q; ++g) {
                    if (l = c.inputs[g], x = c.getConnectionPos(!0, g), C(a.canvasX, a.canvasY, x[0] - 15, x[1] - 10, 30, 20)) {
                      if (f) {
                        if (c.onInputDblClick) {
                          c.onInputDblClick(g, a);
                        }
                      } else {
                        if (c.onInputClick) {
                          c.onInputClick(g, a);
                        }
                      }
                      if (null !== l.link) {
                        e = this.graph.links[l.link];
                        c.disconnectInput(g);
                        if (this.allow_reconnect_links || a.shiftKey) {
                          this.connecting_node = this.graph._nodes_by_id[e.origin_id], this.connecting_slot = e.origin_slot, this.connecting_output = this.connecting_node.outputs[this.connecting_slot], this.connecting_pos = this.connecting_node.getConnectionPos(!1, this.connecting_slot);
                        }
                        e = this.dirty_bgcanvas = !0;
                      }
                    }
                  }
                }
              }
            }
            if (!e) {
              g = !1;
              if (q = this.processNodeWidgets(c, this.canvas_mouse, a)) {
                g = !0, this.node_widget = [c, q];
              }
              if (f && this.selected_nodes[c.id]) {
                if (c.onDblClick) {
                  c.onDblClick(a, [a.canvasX - c.pos[0], a.canvasY - c.pos[1]], this);
                }
                this.processNodeDblClicked(c);
                g = !0;
              }
              c.onMouseDown && c.onMouseDown(a, [a.canvasX - c.pos[0], a.canvasY - c.pos[1]], this) ? g = !0 : this.live_mode && (g = n = !0);
              g || (this.allow_dragnodes && (this.node_dragged = c), this.selected_nodes[c.id] || this.processNodeSelected(c, a));
              this.dirty_canvas = !0;
            }
          } else {
            if (!this.read_only) {
              for (g = 0; g < this.visible_links.length; ++g) {
                if (c = this.visible_links[g], n = c._pos, !(!n || a.canvasX < n[0] - 4 || a.canvasX > n[0] + 4 || a.canvasY < n[1] - 4 || a.canvasY > n[1] + 4)) {
                  this.showLinkMenu(c, a);
                  this.over_link_center = null;
                  break;
                }
              }
            }
            this.selected_group = this.graph.getGroupOnPos(a.canvasX, a.canvasY);
            this.selected_group_resizing = !1;
            this.selected_group && !this.read_only && (a.ctrlKey && (this.dragging_rectangle = null), 10 > H([a.canvasX, a.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]) * this.ds.scale ? this.selected_group_resizing = !0 : this.selected_group.recomputeInsideNodes());
            f && !this.read_only && this.allow_searchbox && this.showSearchBox(a);
            n = !0;
          }
          !e && n && this.allow_dragcanvas && (this.dragging_canvas = !0);
        } else {
          2 != a.which && 3 == a.which && (this.read_only || this.processContextMenu(c, a));
        }
        this.last_mouse[0] = a.localX;
        this.last_mouse[1] = a.localY;
        this.last_mouseclick = d.getTime();
        this.last_mouse_dragging = !0;
        this.graph.change();
        (!b.document.activeElement || "input" != b.document.activeElement.nodeName.toLowerCase() && "textarea" != b.document.activeElement.nodeName.toLowerCase()) && a.preventDefault();
        a.stopPropagation();
        if (this.onMouseDown) {
          this.onMouseDown(a);
        }
        return !1;
      }
    }
  };
  k.prototype.processMouseMove = function(a) {
    this.autoresize && this.resize();
    if (this.graph) {
      k.active_canvas = this;
      this.adjustMouseEvent(a);
      var b = [a.localX, a.localY], c = [b[0] - this.last_mouse[0], b[1] - this.last_mouse[1]];
      this.last_mouse = b;
      this.canvas_mouse[0] = a.canvasX;
      this.canvas_mouse[1] = a.canvasY;
      a.dragging = this.last_mouse_dragging;
      this.node_widget && (this.processNodeWidgets(this.node_widget[0], this.canvas_mouse, a, this.node_widget[1]), this.dirty_canvas = !0);
      if (this.dragging_rectangle) {
        this.dragging_rectangle[2] = a.canvasX - this.dragging_rectangle[0], this.dragging_rectangle[3] = a.canvasY - this.dragging_rectangle[1], this.dirty_canvas = !0;
      } else {
        if (this.selected_group && !this.read_only) {
          this.selected_group_resizing ? this.selected_group.size = [a.canvasX - this.selected_group.pos[0], a.canvasY - this.selected_group.pos[1]] : (this.selected_group.move(c[0] / this.ds.scale, c[1] / this.ds.scale, a.ctrlKey), this.selected_group._nodes.length && (this.dirty_canvas = !0)), this.dirty_bgcanvas = !0;
        } else {
          if (this.dragging_canvas) {
            this.ds.offset[0] += c[0] / this.ds.scale, this.ds.offset[1] += c[1] / this.ds.scale, this.dirty_bgcanvas = this.dirty_canvas = !0;
          } else {
            if (this.allow_interaction && !this.read_only) {
              this.connecting_node && (this.dirty_canvas = !0);
              var e = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
              b = 0;
              for (var f = this.graph._nodes.length; b < f; ++b) {
                if (this.graph._nodes[b].mouseOver && e != this.graph._nodes[b]) {
                  this.graph._nodes[b].mouseOver = !1;
                  if (this.node_over && this.node_over.onMouseLeave) {
                    this.node_over.onMouseLeave(a);
                  }
                  this.node_over = null;
                  this.dirty_canvas = !0;
                }
              }
              if (e) {
                if (!e.mouseOver && (e.mouseOver = !0, this.node_over = e, this.dirty_canvas = !0, e.onMouseEnter)) {
                  e.onMouseEnter(a);
                }
                if (e.onMouseMove) {
                  e.onMouseMove(a, [a.canvasX - e.pos[0], a.canvasY - e.pos[1]], this);
                }
                if (this.connecting_node && (f = this._highlight_input || [0, 0], !this.isOverNodeBox(e, a.canvasX, a.canvasY))) {
                  var n = this.isOverNodeInput(e, a.canvasX, a.canvasY, f);
                  -1 != n && e.inputs[n] ? d.isValidConnection(this.connecting_output.type, e.inputs[n].type) && (this._highlight_input = f) : this._highlight_input = null;
                }
                this.canvas && (C(a.canvasX, a.canvasY, e.pos[0] + e.size[0] - 5, e.pos[1] + e.size[1] - 5, 5, 5) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = "crosshair");
              } else {
                f = null;
                for (b = 0; b < this.visible_links.length; ++b) {
                  n = this.visible_links[b];
                  var g = n._pos;
                  if (!(!g || a.canvasX < g[0] - 4 || a.canvasX > g[0] + 4 || a.canvasY < g[1] - 4 || a.canvasY > g[1] + 4)) {
                    f = n;
                    break;
                  }
                }
                f != this.over_link_center && (this.over_link_center = f, this.dirty_canvas = !0);
                this.canvas && (this.canvas.style.cursor = "");
              }
              if (this.node_capturing_input && this.node_capturing_input != e && this.node_capturing_input.onMouseMove) {
                this.node_capturing_input.onMouseMove(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]], this);
              }
              if (this.node_dragged && !this.live_mode) {
                for (b in this.selected_nodes) {
                  e = this.selected_nodes[b], e.pos[0] += c[0] / this.ds.scale, e.pos[1] += c[1] / this.ds.scale;
                }
                this.dirty_bgcanvas = this.dirty_canvas = !0;
              }
              this.resizing_node && !this.live_mode && (this.resizing_node.size[0] = a.canvasX - this.resizing_node.pos[0], this.resizing_node.size[1] = a.canvasY - this.resizing_node.pos[1], c = Math.max(this.resizing_node.inputs ? this.resizing_node.inputs.length : 0, this.resizing_node.outputs ? this.resizing_node.outputs.length : 0) * d.NODE_SLOT_HEIGHT + (this.resizing_node.widgets ? this.resizing_node.widgets.length : 0) * (d.NODE_WIDGET_HEIGHT + 4) + 4, this.resizing_node.size[1] < c && (this.resizing_node.size[1] = 
              c), this.resizing_node.size[0] < d.NODE_MIN_WIDTH && (this.resizing_node.size[0] = d.NODE_MIN_WIDTH), this.canvas.style.cursor = "se-resize", this.dirty_bgcanvas = this.dirty_canvas = !0);
            }
          }
        }
      }
      a.preventDefault();
      return !1;
    }
  };
  k.prototype.processMouseUp = function(a) {
    if (this.graph) {
      var b = this.getCanvasWindow().document;
      k.active_canvas = this;
      b.removeEventListener("mousemove", this._mousemove_callback, !0);
      this.canvas.addEventListener("mousemove", this._mousemove_callback, !0);
      b.removeEventListener("mouseup", this._mouseup_callback, !0);
      this.adjustMouseEvent(a);
      b = d.getTime();
      a.click_time = b - this.last_mouseclick;
      this.last_mouse_dragging = !1;
      if (1 == a.which) {
        if (this.node_widget = null, this.selected_group && (this.selected_group.move(this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]), a.ctrlKey), this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]), this.selected_group._nodes.length && (this.dirty_canvas = !0), this.selected_group = null), this.selected_group_resizing = !1, 
        this.dragging_rectangle) {
          if (this.graph) {
            b = this.graph._nodes;
            var c = new Float32Array(4);
            this.deselectAllNodes();
            var e = Math.abs(this.dragging_rectangle[2]), f = Math.abs(this.dragging_rectangle[3]), n = 0 > this.dragging_rectangle[3] ? this.dragging_rectangle[1] - f : this.dragging_rectangle[1];
            this.dragging_rectangle[0] = 0 > this.dragging_rectangle[2] ? this.dragging_rectangle[0] - e : this.dragging_rectangle[0];
            this.dragging_rectangle[1] = n;
            this.dragging_rectangle[2] = e;
            this.dragging_rectangle[3] = f;
            f = [];
            for (n = 0; n < b.length; ++n) {
              e = b[n], e.getBounding(c), I(this.dragging_rectangle, c) && f.push(e);
            }
            f.length && this.selectNodes(f);
          }
          this.dragging_rectangle = null;
        } else {
          if (this.connecting_node) {
            this.dirty_bgcanvas = this.dirty_canvas = !0;
            if (e = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes)) {
              this.connecting_output.type == d.EVENT && this.isOverNodeBox(e, a.canvasX, a.canvasY) ? this.connecting_node.connect(this.connecting_slot, e, d.EVENT) : (b = this.isOverNodeInput(e, a.canvasX, a.canvasY), -1 != b ? this.connecting_node.connect(this.connecting_slot, e, b) : (b = e.getInputInfo(0), this.connecting_output.type == d.EVENT ? this.connecting_node.connect(this.connecting_slot, e, d.EVENT) : b && !b.link && d.isValidConnection(b.type && this.connecting_output.type) && this.connecting_node.connect(this.connecting_slot, 
              e, 0)));
            }
            this.connecting_node = this.connecting_pos = this.connecting_output = null;
            this.connecting_slot = -1;
          } else {
            if (this.resizing_node) {
              this.dirty_bgcanvas = this.dirty_canvas = !0, this.resizing_node = null;
            } else {
              if (this.node_dragged) {
                (e = this.node_dragged) && 300 > a.click_time && C(a.canvasX, a.canvasY, e.pos[0], e.pos[1] - d.NODE_TITLE_HEIGHT, d.NODE_TITLE_HEIGHT, d.NODE_TITLE_HEIGHT) && e.collapse();
                this.dirty_bgcanvas = this.dirty_canvas = !0;
                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
                this.graph.config.align_to_grid && this.node_dragged.alignToGrid();
                if (this.onNodeMoved) {
                  this.onNodeMoved(this.node_dragged);
                }
                this.node_dragged = null;
              } else {
                e = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
                !e && 300 > a.click_time && this.deselectAllNodes();
                this.dirty_canvas = !0;
                this.dragging_canvas = !1;
                if (this.node_over && this.node_over.onMouseUp) {
                  this.node_over.onMouseUp(a, [a.canvasX - this.node_over.pos[0], a.canvasY - this.node_over.pos[1]], this);
                }
                if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
                  this.node_capturing_input.onMouseUp(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]]);
                }
              }
            }
          }
        }
      } else {
        2 == a.which ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : 3 == a.which && (this.dirty_canvas = !0, this.dragging_canvas = !1);
      }
      this.graph.change();
      a.stopPropagation();
      a.preventDefault();
      return !1;
    }
  };
  k.prototype.processMouseWheel = function(a) {
    if (this.graph && this.allow_dragcanvas) {
      var b = null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail;
      this.adjustMouseEvent(a);
      var c = this.ds.scale;
      0 < b ? c *= 1.1 : 0 > b && (c *= 1 / 1.1);
      this.ds.changeScale(c, [a.localX, a.localY]);
      this.graph.change();
      a.preventDefault();
      return !1;
    }
  };
  k.prototype.isOverNodeBox = function(a, b, c) {
    var e = d.NODE_TITLE_HEIGHT;
    return C(b, c, a.pos[0] + 2, a.pos[1] + 2 - e, e - 4, e - 4) ? !0 : !1;
  };
  k.prototype.isOverNodeInput = function(a, b, c, e) {
    if (a.inputs) {
      for (var f = 0, d = a.inputs.length; f < d; ++f) {
        var g = a.getConnectionPos(!0, f);
        if (a.horizontal ? C(b, c, g[0] - 5, g[1] - 10, 10, 20) : C(b, c, g[0] - 10, g[1] - 5, 40, 10)) {
          return e && (e[0] = g[0], e[1] = g[1]), f;
        }
      }
    }
    return -1;
  };
  k.prototype.processKey = function(a) {
    if (this.graph) {
      var b = !1;
      if ("input" != a.target.localName) {
        if ("keydown" == a.type) {
          if (32 == a.keyCode && (b = this.dragging_canvas = !0), 65 == a.keyCode && a.ctrlKey && (this.selectNodes(), b = !0), "KeyC" == a.code && (a.metaKey || a.ctrlKey) && !a.shiftKey && this.selected_nodes && (this.copyToClipboard(), b = !0), "KeyV" != a.code || !a.metaKey && !a.ctrlKey || a.shiftKey || this.pasteFromClipboard(), 46 != a.keyCode && 8 != a.keyCode || "input" == a.target.localName || "textarea" == a.target.localName || (this.deleteSelectedNodes(), b = !0), this.selected_nodes) {
            for (var c in this.selected_nodes) {
              if (this.selected_nodes[c].onKeyDown) {
                this.selected_nodes[c].onKeyDown(a);
              }
            }
          }
        } else {
          if ("keyup" == a.type && (32 == a.keyCode && (this.dragging_canvas = !1), this.selected_nodes)) {
            for (c in this.selected_nodes) {
              if (this.selected_nodes[c].onKeyUp) {
                this.selected_nodes[c].onKeyUp(a);
              }
            }
          }
        }
        this.graph.change();
        if (b) {
          return a.preventDefault(), a.stopImmediatePropagation(), !1;
        }
      }
    }
  };
  k.prototype.copyToClipboard = function() {
    var a = {nodes:[], links:[]}, b = 0, c = [], e;
    for (e in this.selected_nodes) {
      var f = this.selected_nodes[e];
      f._relative_id = b;
      c.push(f);
      b += 1;
    }
    for (e = 0; e < c.length; ++e) {
      if (f = c[e], b = f.clone()) {
        if (a.nodes.push(b.serialize()), f.inputs && f.inputs.length) {
          for (b = 0; b < f.inputs.length; ++b) {
            var d = f.inputs[b];
            if (d && null != d.link && (d = this.graph.links[d.link])) {
              var g = this.graph.getNodeById(d.origin_id);
              g && this.selected_nodes[g.id] && a.links.push([g._relative_id, d.origin_slot, f._relative_id, d.target_slot]);
            }
          }
        }
      } else {
        console.warn("node type not found: " + f.type);
      }
    }
    localStorage.setItem("litegrapheditor_clipboard", JSON.stringify(a));
  };
  k.prototype.pasteFromClipboard = function() {
    var a = localStorage.getItem("litegrapheditor_clipboard");
    if (a) {
      a = JSON.parse(a);
      for (var b = [], c = 0; c < a.nodes.length; ++c) {
        var e = a.nodes[c], f = d.createNode(e.type);
        f && (f.configure(e), f.pos[0] += 5, f.pos[1] += 5, this.graph.add(f), b.push(f));
      }
      for (c = 0; c < a.links.length; ++c) {
        e = a.links[c];
        f = b[e[0]];
        var n = b[e[2]];
        f && n ? f.connect(e[1], n, e[3]) : console.warn("Warning, nodes missing on pasting");
      }
      this.selectNodes(b);
    }
  };
  k.prototype.processDrop = function(a) {
    a.preventDefault();
    this.adjustMouseEvent(a);
    var b = [a.canvasX, a.canvasY], c = this.graph.getNodeOnPos(b[0], b[1]);
    if (c) {
      if ((c.onDropFile || c.onDropData) && (b = a.dataTransfer.files) && b.length) {
        for (var e = 0; e < b.length; e++) {
          var f = a.dataTransfer.files[0], d = f.name;
          k.getFileExtension(d);
          if (c.onDropFile) {
            c.onDropFile(f);
          }
          if (c.onDropData) {
            var g = new FileReader;
            g.onload = function(a) {
              c.onDropData(a.target.result, d, f);
            };
            var q = f.type.split("/")[0];
            "text" == q || "" == q ? g.readAsText(f) : "image" == q ? g.readAsDataURL(f) : g.readAsArrayBuffer(f);
          }
        }
      }
      return c.onDropItem && c.onDropItem(event) ? !0 : this.onDropItem ? this.onDropItem(event) : !1;
    }
    b = null;
    this.onDropItem && (b = this.onDropItem(event));
    b || this.checkDropItem(a);
  };
  k.prototype.checkDropItem = function(a) {
    if (a.dataTransfer.files.length) {
      var b = a.dataTransfer.files[0], c = k.getFileExtension(b.name).toLowerCase();
      if (c = d.node_types_by_file_extension[c]) {
        if (c = d.createNode(c.type), c.pos = [a.canvasX, a.canvasY], this.graph.add(c), c.onDropFile) {
          c.onDropFile(b);
        }
      }
    }
  };
  k.prototype.processNodeDblClicked = function(a) {
    if (this.onShowNodePanel) {
      this.onShowNodePanel(a);
    }
    if (this.onNodeDblClicked) {
      this.onNodeDblClicked(a);
    }
    this.setDirty(!0);
  };
  k.prototype.processNodeSelected = function(a, b) {
    this.selectNode(a, b && b.shiftKey);
    if (this.onNodeSelected) {
      this.onNodeSelected(a);
    }
  };
  k.prototype.selectNode = function(a, b) {
    null == a ? this.deselectAllNodes() : this.selectNodes([a], b);
  };
  k.prototype.selectNodes = function(a, b) {
    b || this.deselectAllNodes();
    a = a || this.graph._nodes;
    for (b = 0; b < a.length; ++b) {
      var c = a[b];
      if (!c.is_selected) {
        if (!c.is_selected && c.onSelected) {
          c.onSelected();
        }
        c.is_selected = !0;
        this.selected_nodes[c.id] = c;
        if (c.inputs) {
          for (var e = 0; e < c.inputs.length; ++e) {
            this.highlighted_links[c.inputs[e].link] = !0;
          }
        }
        if (c.outputs) {
          for (e = 0; e < c.outputs.length; ++e) {
            var f = c.outputs[e];
            if (f.links) {
              for (var d = 0; d < f.links.length; ++d) {
                this.highlighted_links[f.links[d]] = !0;
              }
            }
          }
        }
      }
    }
    if (this.onSelectionChange) {
      this.onSelectionChange(this.selected_nodes);
    }
    this.setDirty(!0);
  };
  k.prototype.deselectNode = function(a) {
    if (a.is_selected) {
      if (a.onDeselected) {
        a.onDeselected();
      }
      a.is_selected = !1;
      if (this.onNodeDeselected) {
        this.onNodeDeselected(a);
      }
      if (a.inputs) {
        for (var b = 0; b < a.inputs.length; ++b) {
          delete this.highlighted_links[a.inputs[b].link];
        }
      }
      if (a.outputs) {
        for (b = 0; b < a.outputs.length; ++b) {
          var c = a.outputs[b];
          if (c.links) {
            for (var e = 0; e < c.links.length; ++e) {
              delete this.highlighted_links[c.links[e]];
            }
          }
        }
      }
    }
  };
  k.prototype.deselectAllNodes = function() {
    if (this.graph) {
      for (var a = this.graph._nodes, b = 0, c = a.length; b < c; ++b) {
        var e = a[b];
        if (e.is_selected) {
          if (e.onDeselected) {
            e.onDeselected();
          }
          e.is_selected = !1;
          if (this.onNodeDeselected) {
            this.onNodeDeselected(e);
          }
        }
      }
      this.selected_nodes = {};
      this.current_node = null;
      this.highlighted_links = {};
      if (this.onSelectionChange) {
        this.onSelectionChange(this.selected_nodes);
      }
      this.setDirty(!0);
    }
  };
  k.prototype.deleteSelectedNodes = function() {
    for (var a in this.selected_nodes) {
      var b = this.selected_nodes[a];
      if (b.inputs && b.inputs.length && b.outputs && b.outputs.length && d.isValidConnection(b.inputs[0].type, b.outputs[0].type) && b.inputs[0].link && b.outputs[0].links && b.outputs[0].links.length) {
        var c = b.graph.links[b.inputs[0].link], e = b.graph.links[b.outputs[0].links[0]], f = b.getInputNode(0), n = b.getOutputNodes(0)[0];
        f && n && f.connect(c.origin_slot, n, e.target_slot);
      }
      this.graph.remove(b);
      if (this.onNodeDeselected) {
        this.onNodeDeselected(b);
      }
    }
    this.selected_nodes = {};
    this.current_node = null;
    this.highlighted_links = {};
    this.setDirty(!0);
  };
  k.prototype.centerOnNode = function(a) {
    this.ds.offset[0] = -a.pos[0] - 0.5 * a.size[0] + 0.5 * this.canvas.width / this.ds.scale;
    this.ds.offset[1] = -a.pos[1] - 0.5 * a.size[1] + 0.5 * this.canvas.height / this.ds.scale;
    this.setDirty(!0, !0);
  };
  k.prototype.adjustMouseEvent = function(a) {
    if (this.canvas) {
      var b = this.canvas.getBoundingClientRect();
      a.localX = a.clientX - b.left;
      a.localY = a.clientY - b.top;
    } else {
      a.localX = a.clientX, a.localY = a.clientY;
    }
    a.deltaX = a.localX - this.last_mouse_position[0];
    a.deltaY = a.localY - this.last_mouse_position[1];
    this.last_mouse_position[0] = a.localX;
    this.last_mouse_position[1] = a.localY;
    a.canvasX = a.localX / this.ds.scale - this.ds.offset[0];
    a.canvasY = a.localY / this.ds.scale - this.ds.offset[1];
  };
  k.prototype.setZoom = function(a, b) {
    this.ds.changeScale(a, b);
    this.dirty_bgcanvas = this.dirty_canvas = !0;
  };
  k.prototype.convertOffsetToCanvas = function(a, b) {
    return this.ds.convertOffsetToCanvas(a, b);
  };
  k.prototype.convertCanvasToOffset = function(a, b) {
    return this.ds.convertCanvasToOffset(a, b);
  };
  k.prototype.convertEventToCanvasOffset = function(a) {
    var b = this.canvas.getBoundingClientRect();
    return this.convertCanvasToOffset([a.clientX - b.left, a.clientY - b.top]);
  };
  k.prototype.bringToFront = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.push(a));
  };
  k.prototype.sendToBack = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.unshift(a));
  };
  var J = new Float32Array(4);
  k.prototype.computeVisibleNodes = function(a, b) {
    b = b || [];
    b.length = 0;
    a = a || this.graph._nodes;
    for (var c = 0, e = a.length; c < e; ++c) {
      var f = a[c];
      (!this.live_mode || f.onDrawBackground || f.onDrawForeground) && I(this.visible_area, f.getBounding(J)) && b.push(f);
    }
    return b;
  };
  k.prototype.draw = function(a, b) {
    if (this.canvas) {
      var c = d.getTime();
      this.render_time = 0.001 * (c - this.last_draw_time);
      this.last_draw_time = c;
      this.graph && this.ds.computeVisibleArea();
      (this.dirty_bgcanvas || b || this.always_render_background || this.graph && this.graph._last_trigger_time && 1000 > c - this.graph._last_trigger_time) && this.drawBackCanvas();
      (this.dirty_canvas || a) && this.drawFrontCanvas();
      this.fps = this.render_time ? 1.0 / this.render_time : 0;
      this.frame += 1;
    }
  };
  k.prototype.drawFrontCanvas = function() {
    this.dirty_canvas = !1;
    this.ctx || (this.ctx = this.bgcanvas.getContext("2d"));
    var a = this.ctx;
    if (a) {
      a.start2D && a.start2D();
      var b = this.canvas;
      a.restore();
      a.setTransform(1, 0, 0, 1, 0, 0);
      this.dirty_area && (a.save(), a.beginPath(), a.rect(this.dirty_area[0], this.dirty_area[1], this.dirty_area[2], this.dirty_area[3]), a.clip());
      this.clear_background && a.clearRect(0, 0, b.width, b.height);
      this.bgcanvas == this.canvas ? this.drawBackCanvas() : a.drawImage(this.bgcanvas, 0, 0);
      if (this.onRender) {
        this.onRender(b, a);
      }
      this.show_info && this.renderInfo(a);
      if (this.graph) {
        a.save();
        this.ds.toCanvasContext(a);
        b = this.computeVisibleNodes(null, this.visible_nodes);
        for (var c = 0; c < b.length; ++c) {
          var e = b[c];
          a.save();
          a.translate(e.pos[0], e.pos[1]);
          this.drawNode(e, a);
          a.restore();
        }
        this.render_execution_order && this.drawExecutionOrder(a);
        this.graph.config.links_ontop && (this.live_mode || this.drawConnections(a));
        if (null != this.connecting_pos) {
          a.lineWidth = this.connections_width;
          switch(this.connecting_output.type) {
            case d.EVENT:
              b = d.EVENT_LINK_COLOR;
              break;
            default:
              b = d.CONNECTING_LINK_COLOR;
          }
          this.renderLink(a, this.connecting_pos, [this.canvas_mouse[0], this.canvas_mouse[1]], null, !1, null, b, this.connecting_output.dir || (this.connecting_node.horizontal ? d.DOWN : d.RIGHT), d.CENTER);
          a.beginPath();
          this.connecting_output.type === d.EVENT || this.connecting_output.shape === d.BOX_SHAPE ? a.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10) : a.arc(this.connecting_pos[0], this.connecting_pos[1], 4, 0, 2 * Math.PI);
          a.fill();
          a.fillStyle = "#ffcc00";
          this._highlight_input && (a.beginPath(), a.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, 2 * Math.PI), a.fill());
        }
        this.dragging_rectangle && (a.strokeStyle = "#FFF", a.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3]));
        if (this.over_link_center && this.render_link_tooltip) {
          this.drawLinkTooltip(a, this.over_link_center);
        } else {
          if (this.onDrawLinkTooltip) {
            this.onDrawLinkTooltip(a, null);
          }
        }
        if (this.onDrawForeground) {
          this.onDrawForeground(a, this.visible_rect);
        }
        a.restore();
      }
      if (this.onDrawOverlay) {
        this.onDrawOverlay(a);
      }
      this.dirty_area && a.restore();
      a.finish2D && a.finish2D();
    }
  };
  k.prototype.renderInfo = function(a, b, c) {
    b = b || 0;
    c = c || 0;
    a.save();
    a.translate(b, c);
    a.font = "10px Arial";
    a.fillStyle = "#888";
    this.graph ? (a.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), a.fillText("I: " + this.graph.iteration, 5, 26), a.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 39), a.fillText("V: " + this.graph._version, 5, 52), a.fillText("FPS:" + this.fps.toFixed(2), 5, 65)) : a.fillText("No graph selected", 5, 13);
    a.restore();
  };
  k.prototype.drawBackCanvas = function() {
    var a = this.bgcanvas;
    if (a.width != this.canvas.width || a.height != this.canvas.height) {
      a.width = this.canvas.width, a.height = this.canvas.height;
    }
    this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d"));
    var b = this.bgctx;
    b.start && b.start();
    this.clear_background && b.clearRect(0, 0, a.width, a.height);
    if (this._graph_stack && this._graph_stack.length) {
      b.save();
      var c = this.graph._subgraph_node;
      b.strokeStyle = c.bgcolor;
      b.lineWidth = 10;
      b.strokeRect(1, 1, a.width - 2, a.height - 2);
      b.lineWidth = 1;
      b.font = "40px Arial";
      b.textAlign = "center";
      b.fillStyle = c.bgcolor || "#AAA";
      for (var e = "", f = 1; f < this._graph_stack.length; ++f) {
        e += this._graph_stack[f]._subgraph_node.getTitle() + " >> ";
      }
      b.fillText(e + c.getTitle(), 0.5 * a.width, 40);
      b.restore();
    }
    c = !1;
    this.onRenderBackground && (c = this.onRenderBackground(a, b));
    b.restore();
    b.setTransform(1, 0, 0, 1, 0, 0);
    this.visible_links.length = 0;
    if (this.graph) {
      b.save();
      this.ds.toCanvasContext(b);
      if (this.background_image && 0.5 < this.ds.scale && !c) {
        b.globalAlpha = this.zoom_modify_alpha ? (1.0 - 0.5 / this.ds.scale) * this.editor_alpha : this.editor_alpha;
        b.imageSmoothingEnabled = b.mozImageSmoothingEnabled = b.imageSmoothingEnabled = !1;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image;
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          var d = this;
          this._bg_img.onload = function() {
            d.draw(!0, !0);
          };
        }
        c = null;
        null == this._pattern && 0 < this._bg_img.width ? (c = b.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = c) : c = this._pattern;
        c && (b.fillStyle = c, b.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]), b.fillStyle = "transparent");
        b.globalAlpha = 1.0;
        b.imageSmoothingEnabled = b.mozImageSmoothingEnabled = b.imageSmoothingEnabled = !0;
      }
      this.graph._groups.length && !this.live_mode && this.drawGroups(a, b);
      if (this.onDrawBackground) {
        this.onDrawBackground(b, this.visible_area);
      }
      this.onBackgroundRender && (console.error("WARNING! onBackgroundRender deprecated, now is named onDrawBackground "), this.onBackgroundRender = null);
      this.render_canvas_border && (b.strokeStyle = "#235", b.strokeRect(0, 0, a.width, a.height));
      this.render_connections_shadows ? (b.shadowColor = "#000", b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = 6) : b.shadowColor = "rgba(0,0,0,0)";
      this.live_mode || this.drawConnections(b);
      b.shadowColor = "rgba(0,0,0,0)";
      b.restore();
    }
    b.finish && b.finish();
    this.dirty_bgcanvas = !1;
    this.dirty_canvas = !0;
  };
  var D = new Float32Array(2);
  k.prototype.drawNode = function(a, b) {
    this.current_node = a;
    var c = a.color || a.constructor.color || d.NODE_DEFAULT_COLOR, e = a.bgcolor || a.constructor.bgcolor || d.NODE_DEFAULT_BGCOLOR, f = 0.6 > this.ds.scale;
    if (this.live_mode) {
      if (!a.flags.collapsed && (b.shadowColor = "transparent", a.onDrawForeground)) {
        a.onDrawForeground(b, this, this.canvas);
      }
    } else {
      var n = this.editor_alpha;
      b.globalAlpha = n;
      this.render_shadows && !f ? (b.shadowColor = d.DEFAULT_SHADOW_COLOR, b.shadowOffsetX = 2 * this.ds.scale, b.shadowOffsetY = 2 * this.ds.scale, b.shadowBlur = 3 * this.ds.scale) : b.shadowColor = "transparent";
      if (!a.flags.collapsed || !a.onDrawCollapsed || 1 != a.onDrawCollapsed(b, this)) {
        var g = a._shape || d.BOX_SHAPE;
        D.set(a.size);
        var q = a.horizontal;
        if (a.flags.collapsed) {
          b.font = this.inner_text_font;
          var l = a.getTitle ? a.getTitle() : a.title;
          null != l && (a._collapsed_width = Math.min(a.size[0], b.measureText(l).width + 2 * d.NODE_TITLE_HEIGHT), D[0] = a._collapsed_width, D[1] = 0);
        }
        a.clip_area && (b.save(), b.beginPath(), g == d.BOX_SHAPE ? b.rect(0, 0, D[0], D[1]) : g == d.ROUND_SHAPE ? b.roundRect(0, 0, D[0], D[1], 10) : g == d.CIRCLE_SHAPE && b.arc(0.5 * D[0], 0.5 * D[1], 0.5 * D[0], 0, 2 * Math.PI), b.clip());
        a.has_errors && (e = "red");
        this.drawNodeShape(a, b, D, c, e, a.is_selected, a.mouseOver);
        b.shadowColor = "transparent";
        if (a.onDrawForeground) {
          a.onDrawForeground(b, this, this.canvas);
        }
        b.textAlign = q ? "center" : "left";
        b.font = this.inner_text_font;
        e = !f;
        g = this.connecting_output;
        b.lineWidth = 1;
        l = 0;
        var k = new Float32Array(2);
        if (!a.flags.collapsed) {
          if (a.inputs) {
            for (c = 0; c < a.inputs.length; c++) {
              var u = a.inputs[c];
              b.globalAlpha = n;
              this.connecting_node && !d.isValidConnection(u.type, g.type) && (b.globalAlpha = 0.4 * n);
              b.fillStyle = null != u.link ? u.color_on || this.default_connection_color.input_on : u.color_off || this.default_connection_color.input_off;
              var m = a.getConnectionPos(!0, c, k);
              m[0] -= a.pos[0];
              m[1] -= a.pos[1];
              l < m[1] + 0.5 * d.NODE_SLOT_HEIGHT && (l = m[1] + 0.5 * d.NODE_SLOT_HEIGHT);
              b.beginPath();
              u.type === d.EVENT || u.shape === d.BOX_SHAPE ? q ? b.rect(m[0] - 5 + 0.5, m[1] - 8 + 0.5, 10, 14) : b.rect(m[0] - 6 + 0.5, m[1] - 5 + 0.5, 14, 10) : u.shape === d.ARROW_SHAPE ? (b.moveTo(m[0] + 8, m[1] + 0.5), b.lineTo(m[0] - 4, m[1] + 6 + 0.5), b.lineTo(m[0] - 4, m[1] - 6 + 0.5), b.closePath()) : f ? b.rect(m[0] - 4, m[1] - 4, 8, 8) : b.arc(m[0], m[1], 4, 0, 2 * Math.PI);
              b.fill();
              if (e) {
                var h = null != u.label ? u.label : u.name;
                h && (b.fillStyle = d.NODE_TEXT_COLOR, q || u.dir == d.UP ? b.fillText(h, m[0], m[1] - 10) : b.fillText(h, m[0] + 10, m[1] + 5));
              }
            }
          }
          this.connecting_node && (b.globalAlpha = 0.4 * n);
          b.textAlign = q ? "center" : "right";
          b.strokeStyle = "black";
          if (a.outputs) {
            for (c = 0; c < a.outputs.length; c++) {
              if (u = a.outputs[c], m = a.getConnectionPos(!1, c, k), m[0] -= a.pos[0], m[1] -= a.pos[1], l < m[1] + 0.5 * d.NODE_SLOT_HEIGHT && (l = m[1] + 0.5 * d.NODE_SLOT_HEIGHT), b.fillStyle = u.links && u.links.length ? u.color_on || this.default_connection_color.output_on : u.color_off || this.default_connection_color.output_off, b.beginPath(), u.type === d.EVENT || u.shape === d.BOX_SHAPE ? q ? b.rect(m[0] - 5 + 0.5, m[1] - 8 + 0.5, 10, 14) : b.rect(m[0] - 6 + 0.5, m[1] - 5 + 0.5, 14, 10) : 
              u.shape === d.ARROW_SHAPE ? (b.moveTo(m[0] + 8, m[1] + 0.5), b.lineTo(m[0] - 4, m[1] + 6 + 0.5), b.lineTo(m[0] - 4, m[1] - 6 + 0.5), b.closePath()) : f ? b.rect(m[0] - 4, m[1] - 4, 8, 8) : b.arc(m[0], m[1], 4, 0, 2 * Math.PI), b.fill(), f || b.stroke(), e && (h = null != u.label ? u.label : u.name)) {
                b.fillStyle = d.NODE_TEXT_COLOR, q || u.dir == d.DOWN ? b.fillText(h, m[0], m[1] - 8) : b.fillText(h, m[0] - 10, m[1] + 5);
              }
            }
          }
          b.textAlign = "left";
          b.globalAlpha = 1;
          if (a.widgets) {
            u = l;
            if (q || a.widgets_up) {
              u = 2;
            }
            null != a.widgets_start_y && (u = a.widgets_start_y);
            this.drawNodeWidgets(a, u, b, this.node_widget && this.node_widget[0] == a ? this.node_widget[1] : null);
          }
        } else {
          if (this.render_collapsed_slots) {
            f = n = null;
            if (a.inputs) {
              for (c = 0; c < a.inputs.length; c++) {
                if (u = a.inputs[c], null != u.link) {
                  n = u;
                  break;
                }
              }
            }
            if (a.outputs) {
              for (c = 0; c < a.outputs.length; c++) {
                u = a.outputs[c], u.links && u.links.length && (f = u);
              }
            }
            n && (n = 0, c = -0.5 * d.NODE_TITLE_HEIGHT, q && (n = 0.5 * a._collapsed_width, c = -d.NODE_TITLE_HEIGHT), b.fillStyle = "#686", b.beginPath(), u.type === d.EVENT || u.shape === d.BOX_SHAPE ? b.rect(n - 7 + 0.5, c - 4, 14, 8) : u.shape === d.ARROW_SHAPE ? (b.moveTo(n + 8, c), b.lineTo(n + -4, c - 4), b.lineTo(n + -4, c + 4), b.closePath()) : b.arc(n, c, 4, 0, 2 * Math.PI), b.fill());
            f && (n = a._collapsed_width, c = -0.5 * d.NODE_TITLE_HEIGHT, q && (n = 0.5 * a._collapsed_width, c = 0), b.fillStyle = "#686", b.strokeStyle = "black", b.beginPath(), u.type === d.EVENT || u.shape === d.BOX_SHAPE ? b.rect(n - 7 + 0.5, c - 4, 14, 8) : u.shape === d.ARROW_SHAPE ? (b.moveTo(n + 6, c), b.lineTo(n - 6, c - 4), b.lineTo(n - 6, c + 4), b.closePath()) : b.arc(n, c, 4, 0, 2 * Math.PI), b.fill());
          }
        }
        a.clip_area && b.restore();
        b.globalAlpha = 1.0;
      }
    }
  };
  k.prototype.drawLinkTooltip = function(a, b) {
    var c = b._pos;
    a.fillStyle = "black";
    a.beginPath();
    a.arc(c[0], c[1], 3, 0, 2 * Math.PI);
    a.fill();
    if (null != b.data && (!this.onDrawLinkTooltip || 1 != this.onDrawLinkTooltip(a, b, this)) && (b = b.data, b = b.constructor === Number ? b.toFixed(2) : b.constructor === String ? '"' + b + '"' : b.constructor === Boolean ? String(b) : b.toToolTip ? b.toToolTip() : "[" + b.constructor.name + "]", null != b)) {
      a.font = "14px Courier New";
      var e = a.measureText(b).width + 20;
      a.shadowColor = "black";
      a.shadowOffsetX = 2;
      a.shadowOffsetY = 2;
      a.shadowBlur = 3;
      a.fillStyle = "#454";
      a.beginPath();
      a.roundRect(c[0] - 0.5 * e, c[1] - 15 - 24, e, 24, 3, 3);
      a.moveTo(c[0] - 10, c[1] - 15);
      a.lineTo(c[0] + 10, c[1] - 15);
      a.lineTo(c[0], c[1] - 5);
      a.fill();
      a.shadowColor = "transparent";
      a.textAlign = "center";
      a.fillStyle = "#CEC";
      a.fillText(b, c[0], c[1] - 15 - 24 * 0.3);
    }
  };
  var w = new Float32Array(4);
  k.prototype.drawNodeShape = function(a, b, c, e, f, n, g) {
    b.strokeStyle = e;
    b.fillStyle = f;
    f = d.NODE_TITLE_HEIGHT;
    var l = 0.5 > this.ds.scale, y = a._shape || a.constructor.shape || d.ROUND_SHAPE, x = a.constructor.title_mode, u = !0;
    x == d.TRANSPARENT_TITLE ? u = !1 : x == d.AUTOHIDE_TITLE && g && (u = !0);
    w[0] = 0;
    w[1] = u ? -f : 0;
    w[2] = c[0] + 1;
    w[3] = u ? c[1] + f : c[1];
    g = b.globalAlpha;
    b.beginPath();
    y == d.BOX_SHAPE || l ? b.fillRect(w[0], w[1], w[2], w[3]) : y == d.ROUND_SHAPE || y == d.CARD_SHAPE ? b.roundRect(w[0], w[1], w[2], w[3], this.round_radius, y == d.CARD_SHAPE ? 0 : this.round_radius) : y == d.CIRCLE_SHAPE && b.arc(0.5 * c[0], 0.5 * c[1], 0.5 * c[0], 0, 2 * Math.PI);
    b.fill();
    a.flags.collapsed || (b.shadowColor = "transparent", b.fillStyle = "rgba(0,0,0,0.2)", b.fillRect(0, -1, w[2], 2));
    b.shadowColor = "transparent";
    if (a.onDrawBackground) {
      a.onDrawBackground(b, this, this.canvas);
    }
    if (u || x == d.TRANSPARENT_TITLE) {
      if (a.onDrawTitleBar) {
        a.onDrawTitleBar(b, f, c, this.ds.scale, e);
      } else {
        if (x != d.TRANSPARENT_TITLE && (a.constructor.title_color || this.render_title_colored)) {
          u = a.constructor.title_color || e;
          a.flags.collapsed && (b.shadowColor = d.DEFAULT_SHADOW_COLOR);
          if (this.use_gradients) {
            var m = k.gradients[u];
            m || (m = k.gradients[u] = b.createLinearGradient(0, 0, 400, 0), m.addColorStop(0, u), m.addColorStop(1, "#000"));
            b.fillStyle = m;
          } else {
            b.fillStyle = u;
          }
          b.beginPath();
          y == d.BOX_SHAPE || l ? b.rect(0, -f, c[0] + 1, f) : (y == d.ROUND_SHAPE || y == d.CARD_SHAPE) && b.roundRect(0, -f, c[0] + 1, f, this.round_radius, a.flags.collapsed ? this.round_radius : 0);
          b.fill();
          b.shadowColor = "transparent";
        }
      }
      if (a.onDrawTitleBox) {
        a.onDrawTitleBox(b, f, c, this.ds.scale);
      } else {
        y == d.ROUND_SHAPE || y == d.CIRCLE_SHAPE || y == d.CARD_SHAPE ? (l && (b.fillStyle = "black", b.beginPath(), b.arc(0.5 * f, -0.5 * f, 6, 0, 2 * Math.PI), b.fill()), b.fillStyle = a.boxcolor || d.NODE_DEFAULT_BOXCOLOR, l ? b.fillRect(0.5 * f - 5, -0.5 * f - 5, 10, 10) : (b.beginPath(), b.arc(0.5 * f, -0.5 * f, 5, 0, 2 * Math.PI), b.fill())) : (l && (b.fillStyle = "black", b.fillRect(0.5 * (f - 10) - 1, -0.5 * (f + 10) - 1, 12, 12)), b.fillStyle = a.boxcolor || d.NODE_DEFAULT_BOXCOLOR, b.fillRect(0.5 * 
        (f - 10), -0.5 * (f + 10), 10, 10));
      }
      b.globalAlpha = g;
      if (a.onDrawTitleText) {
        a.onDrawTitleText(b, f, c, this.ds.scale, this.title_text_font, n);
      }
      !l && (b.font = this.title_text_font, l = a.getTitle()) && (b.fillStyle = n ? "white" : a.constructor.title_text_color || this.node_title_color, a.flags.collapsed ? (b.textAlign = "center", g = b.measureText(l), b.fillText(l, f + 0.5 * g.width, d.NODE_TITLE_TEXT_Y - f), b.textAlign = "left") : (b.textAlign = "left", b.fillText(l, f, d.NODE_TITLE_TEXT_Y - f)));
      if (a.onDrawTitle) {
        a.onDrawTitle(b);
      }
    }
    if (n) {
      if (a.onBounding) {
        a.onBounding(w);
      }
      x == d.TRANSPARENT_TITLE && (w[1] -= f, w[3] += f);
      b.lineWidth = 1;
      b.globalAlpha = 0.8;
      b.beginPath();
      y == d.BOX_SHAPE ? b.rect(-6 + w[0], -6 + w[1], 12 + w[2], 12 + w[3]) : y == d.ROUND_SHAPE || y == d.CARD_SHAPE && a.flags.collapsed ? b.roundRect(-6 + w[0], -6 + w[1], 12 + w[2], 12 + w[3], 2 * this.round_radius) : y == d.CARD_SHAPE ? b.roundRect(-6 + w[0], -6 + w[1], 12 + w[2], 12 + w[3], 2 * this.round_radius, 2) : y == d.CIRCLE_SHAPE && b.arc(0.5 * c[0], 0.5 * c[1], 0.5 * c[0] + 6, 0, 2 * Math.PI);
      b.strokeStyle = "#FFF";
      b.stroke();
      b.strokeStyle = e;
      b.globalAlpha = 1;
    }
  };
  var G = new Float32Array(4), z = new Float32Array(4), v = new Float32Array(2), l = new Float32Array(2);
  k.prototype.drawConnections = function(a) {
    var b = d.getTime(), c = this.visible_area;
    G[0] = c[0] - 20;
    G[1] = c[1] - 20;
    G[2] = c[2] + 40;
    G[3] = c[3] + 40;
    a.lineWidth = this.connections_width;
    a.fillStyle = "#AAA";
    a.strokeStyle = "#AAA";
    a.globalAlpha = this.editor_alpha;
    c = this.graph._nodes;
    for (var e = 0, f = c.length; e < f; ++e) {
      var n = c[e];
      if (n.inputs && n.inputs.length) {
        for (var g = 0; g < n.inputs.length; ++g) {
          var q = n.inputs[g];
          if (q && null != q.link && (q = this.graph.links[q.link])) {
            var k = this.graph.getNodeById(q.origin_id);
            if (null != k) {
              var x = q.origin_slot;
              var u = -1 == x ? [k.pos[0] + 10, k.pos[1] + 10] : k.getConnectionPos(!1, x, v);
              var m = n.getConnectionPos(!0, g, l);
              z[0] = u[0];
              z[1] = u[1];
              z[2] = m[0] - u[0];
              z[3] = m[1] - u[1];
              0 > z[2] && (z[0] += z[2], z[2] = Math.abs(z[2]));
              0 > z[3] && (z[1] += z[3], z[3] = Math.abs(z[3]));
              if (I(z, G)) {
                var h = k.outputs[x];
                x = n.inputs[g];
                if (h && x && (k = h.dir || (k.horizontal ? d.DOWN : d.RIGHT), x = x.dir || (n.horizontal ? d.UP : d.LEFT), this.renderLink(a, u, m, q, !1, 0, null, k, x), q && q._last_time && 1000 > b - q._last_time)) {
                  h = 2.0 - 0.002 * (b - q._last_time);
                  var r = a.globalAlpha;
                  a.globalAlpha = r * h;
                  this.renderLink(a, u, m, q, !0, h, "white", k, x);
                  a.globalAlpha = r;
                }
              }
            }
          }
        }
      }
    }
    a.globalAlpha = 1;
  };
  k.prototype.renderLink = function(a, b, c, e, f, n, g, l, y, x) {
    e && this.visible_links.push(e);
    !g && e && (g = e.color || k.link_type_colors[e.type]);
    g || (g = this.default_link_color);
    null != e && this.highlighted_links[e.id] && (g = "#FFF");
    l = l || d.RIGHT;
    y = y || d.LEFT;
    var q = H(b, c);
    this.render_connections_border && 0.6 < this.ds.scale && (a.lineWidth = this.connections_width + 4);
    a.lineJoin = "round";
    x = x || 1;
    1 < x && (a.lineWidth = 0.5);
    a.beginPath();
    for (var m = 0; m < x; m += 1) {
      var h = 5 * (m - 0.5 * (x - 1));
      if (this.links_render_mode == d.SPLINE_LINK) {
        a.moveTo(b[0], b[1] + h);
        var r = 0, p = 0, t = 0, K = 0;
        switch(l) {
          case d.LEFT:
            r = -0.25 * q;
            break;
          case d.RIGHT:
            r = 0.25 * q;
            break;
          case d.UP:
            p = -0.25 * q;
            break;
          case d.DOWN:
            p = 0.25 * q;
        }
        switch(y) {
          case d.LEFT:
            t = -0.25 * q;
            break;
          case d.RIGHT:
            t = 0.25 * q;
            break;
          case d.UP:
            K = -0.25 * q;
            break;
          case d.DOWN:
            K = 0.25 * q;
        }
        a.bezierCurveTo(b[0] + r, b[1] + p + h, c[0] + t, c[1] + K + h, c[0], c[1] + h);
      } else {
        if (this.links_render_mode == d.LINEAR_LINK) {
          a.moveTo(b[0], b[1] + h);
          K = t = p = r = 0;
          switch(l) {
            case d.LEFT:
              r = -1;
              break;
            case d.RIGHT:
              r = 1;
              break;
            case d.UP:
              p = -1;
              break;
            case d.DOWN:
              p = 1;
          }
          switch(y) {
            case d.LEFT:
              t = -1;
              break;
            case d.RIGHT:
              t = 1;
              break;
            case d.UP:
              K = -1;
              break;
            case d.DOWN:
              K = 1;
          }
          a.lineTo(b[0] + 15 * r, b[1] + 15 * p + h);
          a.lineTo(c[0] + 15 * t, c[1] + 15 * K + h);
          a.lineTo(c[0], c[1] + h);
        } else {
          if (this.links_render_mode == d.STRAIGHT_LINK) {
            a.moveTo(b[0], b[1]), h = b[0], r = b[1], p = c[0], t = c[1], l == d.RIGHT ? h += 10 : r += 10, y == d.LEFT ? p -= 10 : t -= 10, a.lineTo(h, r), a.lineTo(0.5 * (h + p), r), a.lineTo(0.5 * (h + p), t), a.lineTo(p, t), a.lineTo(c[0], c[1]);
          } else {
            return;
          }
        }
      }
    }
    this.render_connections_border && 0.6 < this.ds.scale && !f && (a.strokeStyle = "rgba(0,0,0,0.5)", a.stroke());
    a.lineWidth = this.connections_width;
    a.fillStyle = a.strokeStyle = g;
    a.stroke();
    f = this.computeConnectionPoint(b, c, 0.5, l, y);
    e && e._pos && (e._pos[0] = f[0], e._pos[1] = f[1]);
    0.6 <= this.ds.scale && this.highquality_render && y != d.CENTER && (this.render_connection_arrows && (m = this.computeConnectionPoint(b, c, 0.25, l, y), q = this.computeConnectionPoint(b, c, 0.26, l, y), e = this.computeConnectionPoint(b, c, 0.75, l, y), x = this.computeConnectionPoint(b, c, 0.76, l, y), this.render_curved_connections ? (q = -Math.atan2(q[0] - m[0], q[1] - m[1]), x = -Math.atan2(x[0] - e[0], x[1] - e[1])) : x = q = c[1] > b[1] ? 0 : Math.PI, a.save(), a.translate(m[0], m[1]), 
    a.rotate(q), a.beginPath(), a.moveTo(-5, -3), a.lineTo(0, 7), a.lineTo(5, -3), a.fill(), a.restore(), a.save(), a.translate(e[0], e[1]), a.rotate(x), a.beginPath(), a.moveTo(-5, -3), a.lineTo(0, 7), a.lineTo(5, -3), a.fill(), a.restore()), a.beginPath(), a.arc(f[0], f[1], 5, 0, 2 * Math.PI), a.fill());
    if (n) {
      for (a.fillStyle = g, m = 0; 5 > m; ++m) {
        n = (0.001 * d.getTime() + 0.2 * m) % 1, f = this.computeConnectionPoint(b, c, n, l, y), a.beginPath(), a.arc(f[0], f[1], 5, 0, 2 * Math.PI), a.fill();
      }
    }
  };
  k.prototype.computeConnectionPoint = function(a, b, c, e, f) {
    e = e || d.RIGHT;
    f = f || d.LEFT;
    var n = H(a, b), g = [a[0], a[1]], l = [b[0], b[1]];
    switch(e) {
      case d.LEFT:
        g[0] += -0.25 * n;
        break;
      case d.RIGHT:
        g[0] += 0.25 * n;
        break;
      case d.UP:
        g[1] += -0.25 * n;
        break;
      case d.DOWN:
        g[1] += 0.25 * n;
    }
    switch(f) {
      case d.LEFT:
        l[0] += -0.25 * n;
        break;
      case d.RIGHT:
        l[0] += 0.25 * n;
        break;
      case d.UP:
        l[1] += -0.25 * n;
        break;
      case d.DOWN:
        l[1] += 0.25 * n;
    }
    e = (1 - c) * (1 - c) * (1 - c);
    f = 3 * (1 - c) * (1 - c) * c;
    n = 3 * (1 - c) * c * c;
    c *= c * c;
    return [e * a[0] + f * g[0] + n * l[0] + c * b[0], e * a[1] + f * g[1] + n * l[1] + c * b[1]];
  };
  k.prototype.drawExecutionOrder = function(a) {
    a.shadowColor = "transparent";
    a.globalAlpha = 0.25;
    a.textAlign = "center";
    a.strokeStyle = "white";
    a.globalAlpha = 0.75;
    for (var b = this.visible_nodes, c = 0; c < b.length; ++c) {
      var e = b[c];
      a.fillStyle = "black";
      a.fillRect(e.pos[0] - d.NODE_TITLE_HEIGHT, e.pos[1] - d.NODE_TITLE_HEIGHT, d.NODE_TITLE_HEIGHT, d.NODE_TITLE_HEIGHT);
      0 == e.order && a.strokeRect(e.pos[0] - d.NODE_TITLE_HEIGHT + 0.5, e.pos[1] - d.NODE_TITLE_HEIGHT + 0.5, d.NODE_TITLE_HEIGHT, d.NODE_TITLE_HEIGHT);
      a.fillStyle = "#FFF";
      a.fillText(e.order, e.pos[0] + -0.5 * d.NODE_TITLE_HEIGHT, e.pos[1] - 6);
    }
    a.globalAlpha = 1;
  };
  k.prototype.drawNodeWidgets = function(a, b, c, e) {
    if (!a.widgets || !a.widgets.length) {
      return 0;
    }
    var f = a.size[0], l = a.widgets;
    b += 2;
    var g = d.NODE_WIDGET_HEIGHT, q = 0.5 < this.ds.scale;
    c.save();
    c.globalAlpha = this.editor_alpha;
    for (var k = d.WIDGET_OUTLINE_COLOR, h = d.WIDGET_BGCOLOR, u = d.WIDGET_TEXT_COLOR, m = d.WIDGET_SECONDARY_TEXT_COLOR, r = 0; r < l.length; ++r) {
      var p = l[r], t = b;
      p.y && (t = p.y);
      p.last_y = t;
      c.strokeStyle = k;
      c.fillStyle = "#222";
      c.textAlign = "left";
      p.disabled && (c.globalAlpha *= 0.5);
      switch(p.type) {
        case "button":
          p.clicked && (c.fillStyle = "#AAA", p.clicked = !1, this.dirty_canvas = !0);
          c.fillRect(15, t, f - 30, g);
          q && c.strokeRect(15, t, f - 30, g);
          q && (c.textAlign = "center", c.fillStyle = u, c.fillText(p.name, 0.5 * f, t + 0.7 * g));
          break;
        case "toggle":
          c.textAlign = "left";
          c.strokeStyle = k;
          c.fillStyle = h;
          c.beginPath();
          q ? c.roundRect(15, b, f - 30, g, 0.5 * g) : c.rect(15, b, f - 30, g);
          c.fill();
          q && c.stroke();
          c.fillStyle = p.value ? "#89A" : "#333";
          c.beginPath();
          c.arc(f - 30, t + 0.5 * g, 0.36 * g, 0, 2 * Math.PI);
          c.fill();
          q && (c.fillStyle = m, null != p.name && c.fillText(p.name, 30, t + 0.7 * g), c.fillStyle = p.value ? u : m, c.textAlign = "right", c.fillText(p.value ? p.options.on || "true" : p.options.off || "false", f - 40, t + 0.7 * g));
          break;
        case "slider":
          c.fillStyle = h;
          c.fillRect(15, t, f - 30, g);
          var v = p.options.max - p.options.min, K = (p.value - p.options.min) / v;
          c.fillStyle = e == p ? "#89A" : "#678";
          c.fillRect(15, t, K * (f - 30), g);
          q && c.strokeRect(15, t, f - 30, g);
          p.marker && (v = (p.marker - p.options.min) / v, c.fillStyle = "#AA9", c.fillRect(15 + v * (f - 30), t, 2, g));
          q && (c.textAlign = "center", c.fillStyle = u, c.fillText(p.name + "  " + Number(p.value).toFixed(3), 0.5 * f, t + 0.7 * g));
          break;
        case "number":
        case "combo":
          c.textAlign = "left";
          c.strokeStyle = k;
          c.fillStyle = h;
          c.beginPath();
          q ? c.roundRect(15, b, f - 30, g, 0.5 * g) : c.rect(15, b, f - 30, g);
          c.fill();
          q && (c.stroke(), c.fillStyle = u, c.beginPath(), c.moveTo(31, b + 5), c.lineTo(21, b + 0.5 * g), c.lineTo(31, b + g - 5), c.fill(), c.beginPath(), c.moveTo(f - 15 - 16, b + 5), c.lineTo(f - 15 - 6, b + 0.5 * g), c.lineTo(f - 15 - 16, b + g - 5), c.fill(), c.fillStyle = m, c.fillText(p.name, 35, t + 0.7 * g), c.fillStyle = u, c.textAlign = "right", "number" == p.type ? c.fillText(Number(p.value).toFixed(void 0 !== p.options.precision ? p.options.precision : 3), f - 30 - 20, t + 0.7 * g) : 
          c.fillText(p.value, f - 30 - 20, t + 0.7 * g));
          break;
        case "string":
        case "text":
          c.textAlign = "left";
          c.strokeStyle = k;
          c.fillStyle = h;
          c.beginPath();
          q ? c.roundRect(15, b, f - 30, g, 0.5 * g) : c.rect(15, b, f - 30, g);
          c.fill();
          q && (c.stroke(), c.fillStyle = m, null != p.name && c.fillText(p.name, 30, t + 0.7 * g), c.fillStyle = u, c.textAlign = "right", c.fillText(p.value, f - 30, t + 0.7 * g));
          break;
        default:
          p.draw && p.draw(c, a, p, t, g);
      }
      b += g + 4;
      c.globalAlpha = this.editor_alpha;
    }
    c.restore();
    c.textAlign = "left";
  };
  k.prototype.processNodeWidgets = function(a, b, c, e) {
    function f(f, e) {
      f.value = e;
      f.options && f.options.property && void 0 !== a.properties[f.options.property] && a.setProperty(f.options.property, e);
      f.callback && f.callback(f.value, k, a, b, c);
    }
    if (!a.widgets || !a.widgets.length) {
      return null;
    }
    for (var l = b[0] - a.pos[0], g = b[1] - a.pos[1], q = a.size[0], k = this, h = this.getCanvasWindow(), u = 0; u < a.widgets.length; ++u) {
      var m = a.widgets[u];
      if (!m.disabled && (m == e || 6 < l && l < q - 12 && g > m.last_y && g < m.last_y + d.NODE_WIDGET_HEIGHT)) {
        switch(m.type) {
          case "button":
            if ("mousemove" === c.type) {
              break;
            }
            m.callback && setTimeout(function() {
              m.callback(m, k, a, b, c);
            }, 20);
            this.dirty_canvas = m.clicked = !0;
            break;
          case "slider":
            h = Math.clamp((l - 10) / (q - 20), 0, 1);
            m.value = m.options.min + (m.options.max - m.options.min) * h;
            m.callback && setTimeout(function() {
              f(m, m.value);
            }, 20);
            this.dirty_canvas = !0;
            break;
          case "number":
          case "combo":
            e = m.value;
            "mousemove" == c.type && "number" == m.type ? (m.value += 0.1 * c.deltaX * (m.options.step || 1), null != m.options.min && m.value < m.options.min && (m.value = m.options.min), null != m.options.max && m.value > m.options.max && (m.value = m.options.max)) : "mousedown" == c.type && ((g = m.options.values) && g.constructor === Function && (g = m.options.values(m, a)), l = 40 > l ? -1 : l > q - 40 ? 1 : 0, "number" == m.type ? (m.value += 0.1 * l * (m.options.step || 1), null != m.options.min && 
            m.value < m.options.min && (m.value = m.options.min), null != m.options.max && m.value > m.options.max && (m.value = m.options.max)) : l ? (h = g.indexOf(m.value) + l, h >= g.length && (h = 0), 0 > h && (h = g.length - 1), m.value = g[h]) : new d.ContextMenu(g, {scale:Math.max(1, this.ds.scale), event:c, className:"dark", callback:function(a, b, c) {
              this.value = a;
              f(this, a);
              k.dirty_canvas = !0;
              return !1;
            }.bind(m)}, h));
            e != m.value && setTimeout(function() {
              f(this, this.value);
            }.bind(m), 20);
            this.dirty_canvas = !0;
            break;
          case "toggle":
            "mousedown" == c.type && (m.value = !m.value, setTimeout(function() {
              f(m, m.value);
            }, 20));
            break;
          case "string":
          case "text":
            "mousedown" == c.type && this.prompt("Value", m.value, function(a) {
              this.value = a;
              f(this, a);
            }.bind(m), c);
            break;
          default:
            m.mouse && m.mouse(ctx, c, [l, g], a);
        }
        return m;
      }
    }
    return null;
  };
  k.prototype.drawGroups = function(a, b) {
    if (this.graph) {
      a = this.graph._groups;
      b.save();
      b.globalAlpha = 0.5 * this.editor_alpha;
      for (var c = 0; c < a.length; ++c) {
        var e = a[c];
        if (I(this.visible_area, e._bounding)) {
          b.fillStyle = e.color || "#335";
          b.strokeStyle = e.color || "#335";
          var f = e._pos, l = e._size;
          b.globalAlpha = 0.25 * this.editor_alpha;
          b.beginPath();
          b.rect(f[0] + 0.5, f[1] + 0.5, l[0], l[1]);
          b.fill();
          b.globalAlpha = this.editor_alpha;
          b.stroke();
          b.beginPath();
          b.moveTo(f[0] + l[0], f[1] + l[1]);
          b.lineTo(f[0] + l[0] - 10, f[1] + l[1]);
          b.lineTo(f[0] + l[0], f[1] + l[1] - 10);
          b.fill();
          l = e.font_size || d.DEFAULT_GROUP_FONT_SIZE;
          b.font = l + "px Arial";
          b.fillText(e.title, f[0] + 4, f[1] + l);
        }
      }
      b.restore();
    }
  };
  k.prototype.adjustNodesSize = function() {
    for (var a = this.graph._nodes, b = 0; b < a.length; ++b) {
      a[b].size = a[b].computeSize();
    }
    this.setDirty(!0, !0);
  };
  k.prototype.resize = function(a, b) {
    a || b || (b = this.canvas.parentNode, a = b.offsetWidth, b = b.offsetHeight);
    if (this.canvas.width != a || this.canvas.height != b) {
      this.canvas.width = a, this.canvas.height = b, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0);
    }
  };
  k.prototype.switchLiveMode = function(a) {
    if (a) {
      var b = this, c = this.live_mode ? 1.1 : 0.9;
      this.live_mode && (this.live_mode = !1, this.editor_alpha = 0.1);
      var e = setInterval(function() {
        b.editor_alpha *= c;
        b.dirty_canvas = !0;
        b.dirty_bgcanvas = !0;
        1 > c && 0.01 > b.editor_alpha && (clearInterval(e), 1 > c && (b.live_mode = !0));
        1 < c && 0.99 < b.editor_alpha && (clearInterval(e), b.editor_alpha = 1);
      }, 1);
    } else {
      this.live_mode = !this.live_mode, this.dirty_bgcanvas = this.dirty_canvas = !0;
    }
  };
  k.prototype.onNodeSelectionChange = function(a) {
  };
  k.prototype.touchHandler = function(a) {
    var b = a.changedTouches[0];
    switch(a.type) {
      case "touchstart":
        var c = "mousedown";
        break;
      case "touchmove":
        c = "mousemove";
        break;
      case "touchend":
        c = "mouseup";
        break;
      default:
        return;
    }
    var e = this.getCanvasWindow(), f = e.document.createEvent("MouseEvent");
    f.initMouseEvent(c, !0, !0, e, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null);
    b.target.dispatchEvent(f);
    a.preventDefault();
  };
  k.onGroupAdd = function(a, b, c) {
    a = k.active_canvas;
    a.getCanvasWindow();
    b = new d.LGraphGroup;
    b.pos = a.convertEventToCanvasOffset(c);
    a.graph.add(b);
  };
  k.onMenuAdd = function(a, b, c, e, f) {
    function l(a, b) {
      b = e.getFirstEvent();
      if (a = d.createNode(a.value)) {
        a.pos = g.convertEventToCanvasOffset(b), g.graph.add(a);
      }
      f && f(a);
    }
    var g = k.active_canvas, q = g.getCanvasWindow();
    a = d.getNodeTypesCategories(g.filter);
    b = [];
    for (var h in a) {
      a[h] && b.push({value:a[h], content:a[h], has_submenu:!0});
    }
    var p = new d.ContextMenu(b, {event:c, callback:function(a, b, c) {
      a = d.getNodeTypesInCategory(a.value, g.filter);
      b = [];
      for (var f in a) {
        a[f].skip_list || b.push({content:a[f].title, value:a[f].type});
      }
      new d.ContextMenu(b, {event:c, callback:l, parentMenu:p}, q);
      return !1;
    }, parentMenu:e}, q);
    return !1;
  };
  k.onMenuCollapseAll = function() {
  };
  k.onMenuNodeEdit = function() {
  };
  k.showMenuNodeOptionalInputs = function(a, b, c, e, f) {
    if (f) {
      var l = this;
      a = k.active_canvas.getCanvasWindow();
      b = f.optional_inputs;
      f.onGetInputs && (b = f.onGetInputs());
      var g = [];
      if (b) {
        for (var q in b) {
          var h = b[q];
          if (h) {
            var p = h[0];
            h[2] && h[2].label && (p = h[2].label);
            p = {content:p, value:h};
            h[1] == d.ACTION && (p.className = "event");
            g.push(p);
          } else {
            g.push(null);
          }
        }
      }
      this.onMenuNodeInputs && (g = this.onMenuNodeInputs(g));
      if (g.length) {
        return new d.ContextMenu(g, {event:c, callback:function(a, b, c) {
          f && (a.callback && a.callback.call(l, f, a, b, c), a.value && (f.addInput(a.value[0], a.value[1], a.value[2]), f.setDirtyCanvas(!0, !0)));
        }, parentMenu:e, node:f}, a), !1;
      }
    }
  };
  k.showMenuNodeOptionalOutputs = function(a, b, c, e, f) {
    function l(a, b, c) {
      if (f && (a.callback && a.callback.call(g, f, a, b, c), a.value)) {
        if (c = a.value[1], !c || c.constructor !== Object && c.constructor !== Array) {
          f.addOutput(a.value[0], a.value[1], a.value[2]), f.setDirtyCanvas(!0, !0);
        } else {
          a = [];
          for (var n in c) {
            a.push({content:n, value:c[n]});
          }
          new d.ContextMenu(a, {event:b, callback:l, parentMenu:e, node:f});
          return !1;
        }
      }
    }
    if (f) {
      var g = this;
      a = k.active_canvas.getCanvasWindow();
      b = f.optional_outputs;
      f.onGetOutputs && (b = f.onGetOutputs());
      var q = [];
      if (b) {
        for (var h in b) {
          var p = b[h];
          if (!p) {
            q.push(null);
          } else {
            if (!f.flags || !f.flags.skip_repeated_outputs || -1 == f.findOutputSlot(p[0])) {
              var u = p[0];
              p[2] && p[2].label && (u = p[2].label);
              u = {content:u, value:p};
              p[1] == d.EVENT && (u.className = "event");
              q.push(u);
            }
          }
        }
      }
      this.onMenuNodeOutputs && (q = this.onMenuNodeOutputs(q));
      if (q.length) {
        return new d.ContextMenu(q, {event:c, callback:l, parentMenu:e, node:f}, a), !1;
      }
    }
  };
  k.onShowMenuNodeProperties = function(a, b, c, e, f) {
    if (f && f.properties) {
      var l = k.active_canvas;
      b = l.getCanvasWindow();
      var g = [], q;
      for (q in f.properties) {
        a = void 0 !== f.properties[q] ? f.properties[q] : " ", "object" == typeof a && (a = JSON.stringify(a)), a = k.decodeHTML(a), g.push({content:"<span class='property_name'>" + q + "</span><span class='property_value'>" + a + "</span>", value:q});
      }
      if (g.length) {
        return new d.ContextMenu(g, {event:c, callback:function(a, b, c, e) {
          f && (b = this.getBoundingClientRect(), l.showEditPropertyValue(f, a.value, {position:[b.left, b.top]}));
        }, parentMenu:e, allow_html:!0, node:f}, b), !1;
      }
    }
  };
  k.decodeHTML = function(a) {
    var b = document.createElement("div");
    b.innerText = a;
    return b.innerHTML;
  };
  k.onResizeNode = function(a, b, c, e, f) {
    f && (f.size = f.computeSize(), f.setDirtyCanvas(!0, !0));
  };
  k.prototype.showLinkMenu = function(a, b) {
    var c = this;
    console.log(a);
    var e = new d.ContextMenu(["Add Node", null, "Delete"], {event:b, title:null != a.data ? a.data.constructor.name : null, callback:function(b, d, g) {
      switch(b) {
        case "Add Node":
          k.onMenuAdd(null, null, g, e, function(b) {
            console.log("node autoconnect");
            var f = c.graph.getNodeById(a.origin_id), e = c.graph.getNodeById(a.target_id);
            b.inputs && b.inputs.length && b.outputs && b.outputs.length && f.outputs[a.origin_slot].type == b.inputs[0].type && b.outputs[0].type == e.inputs[0].type && (f.connect(a.origin_slot, b, 0), b.connect(0, e, a.target_slot), b.pos[0] -= 0.5 * b.size[0]);
          });
          break;
        case "Delete":
          c.graph.removeLink(a.id);
      }
    }});
    return !1;
  };
  k.onShowPropertyEditor = function(a, b, c, e, f) {
    function d() {
      var b = h.value;
      "Number" == a.type ? b = Number(b) : "Boolean" == a.type && (b = !!b);
      f[g] = b;
      l.parentNode && l.parentNode.removeChild(l);
      f.setDirtyCanvas(!0, !0);
    }
    var g = a.property || "title";
    b = f[g];
    var l = document.createElement("div");
    l.className = "graphdialog";
    l.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
    l.querySelector(".name").innerText = g;
    var h = l.querySelector("input");
    h && (h.value = b, h.addEventListener("blur", function(a) {
      this.focus();
    }), h.addEventListener("keydown", function(a) {
      13 == a.keyCode && (d(), a.preventDefault(), a.stopPropagation());
    }));
    b = k.active_canvas.canvas;
    c = b.getBoundingClientRect();
    var p = e = -20;
    c && (e -= c.left, p -= c.top);
    event ? (l.style.left = event.clientX + e + "px", l.style.top = event.clientY + p + "px") : (l.style.left = 0.5 * b.width + e + "px", l.style.top = 0.5 * b.height + p + "px");
    l.querySelector("button").addEventListener("click", d);
    b.parentNode.appendChild(l);
  };
  k.prototype.prompt = function(a, b, c, e) {
    var f = this;
    a = a || "";
    var d = !1, g = document.createElement("div");
    g.className = "graphdialog rounded";
    g.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
    g.close = function() {
      f.prompt_box = null;
      g.parentNode && g.parentNode.removeChild(g);
    };
    1 < this.ds.scale && (g.style.transform = "scale(" + this.ds.scale + ")");
    g.addEventListener("mouseleave", function(a) {
      d || g.close();
    });
    f.prompt_box && f.prompt_box.close();
    f.prompt_box = g;
    g.querySelector(".name").innerText = a;
    g.querySelector(".value").value = b;
    var l = g.querySelector("input");
    l.addEventListener("keydown", function(a) {
      d = !0;
      if (27 == a.keyCode) {
        g.close();
      } else {
        if (13 == a.keyCode) {
          c && c(this.value), g.close();
        } else {
          return;
        }
      }
      a.preventDefault();
      a.stopPropagation();
    });
    g.querySelector("button").addEventListener("click", function(a) {
      c && c(l.value);
      f.setDirty(!0);
      g.close();
    });
    a = k.active_canvas.canvas;
    b = a.getBoundingClientRect();
    var h = -20, p = -20;
    b && (h -= b.left, p -= b.top);
    e ? (g.style.left = e.clientX + h + "px", g.style.top = e.clientY + p + "px") : (g.style.left = 0.5 * a.width + h + "px", g.style.top = 0.5 * a.height + p + "px");
    a.parentNode.appendChild(g);
    setTimeout(function() {
      l.focus();
    }, 10);
    return g;
  };
  k.search_limit = -1;
  k.prototype.showSearchBox = function(a) {
    function b(b) {
      if (b) {
        if (f.onSearchBoxSelection) {
          f.onSearchBoxSelection(b, a, l);
        } else {
          var c = d.searchbox_extras[b.toLowerCase()];
          c && (b = c.type);
          if (b = d.createNode(b)) {
            b.pos = l.convertEventToCanvasOffset(a), l.graph.add(b);
          }
          if (c && c.data) {
            if (c.data.properties) {
              for (var e in c.data.properties) {
                b.addProperty(e, c.data.properties[e]);
              }
            }
            if (c.data.inputs) {
              for (e in b.inputs = [], c.data.inputs) {
                b.addOutput(c.data.inputs[e][0], c.data.inputs[e][1]);
              }
            }
            if (c.data.outputs) {
              for (e in b.outputs = [], c.data.outputs) {
                b.addOutput(c.data.outputs[e][0], c.data.outputs[e][1]);
              }
            }
            c.data.title && (b.title = c.data.title);
            c.data.json && b.configure(c.data.json);
          }
        }
      }
      h.close();
    }
    function c(a) {
      var b = t;
      t && t.classList.remove("selected");
      t ? (t = a ? t.nextSibling : t.previousSibling) || (t = b) : t = a ? u.childNodes[0] : u.childNodes[u.childNodes.length];
      t && (t.classList.add("selected"), t.scrollIntoView({block:"end", behavior:"smooth"}));
    }
    function e() {
      function a(a, c) {
        var e = document.createElement("div");
        m || (m = a);
        e.innerText = a;
        e.dataset.type = escape(a);
        e.className = "litegraph lite-search-item";
        c && (e.className += " " + c);
        e.addEventListener("click", function(a) {
          b(unescape(this.dataset.type));
        });
        u.appendChild(e);
      }
      r = null;
      var c = v.value;
      m = null;
      u.innerHTML = "";
      if (c) {
        if (f.onSearchBox) {
          var e = f.onSearchBox(u, c, l);
          if (e) {
            for (var g = 0; g < e.length; ++g) {
              a(e[g]);
            }
          }
        } else {
          e = function(a) {
            var b = d.registered_node_types[a];
            return q && b.filter != q ? !1 : -1 !== a.toLowerCase().indexOf(c);
          };
          var n = 0;
          c = c.toLowerCase();
          var q = l.filter || l.graph.filter;
          for (g in d.searchbox_extras) {
            var h = d.searchbox_extras[g];
            if (-1 !== h.desc.toLowerCase().indexOf(c)) {
              var p = d.registered_node_types[h.type];
              if (!p || !p.filter || p.filter == q) {
                if (a(h.desc, "searchbox_extra"), -1 !== k.search_limit && n++ > k.search_limit) {
                  break;
                }
              }
            }
          }
          h = null;
          if (Array.prototype.filter) {
            h = Object.keys(d.registered_node_types).filter(e);
          } else {
            for (g in h = [], d.registered_node_types) {
              e(g) && h.push(g);
            }
          }
          for (g = 0; g < h.length && !(a(h[g]), -1 !== k.search_limit && n++ > k.search_limit); g++) {
          }
        }
      }
    }
    var f = this, l = k.active_canvas, g = l.canvas, q = g.ownerDocument || document, h = document.createElement("div");
    h.className = "litegraph litesearchbox graphdialog rounded";
    h.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>";
    h.close = function() {
      f.search_box = null;
      q.body.focus();
      q.body.style.overflow = "";
      setTimeout(function() {
        f.canvas.focus();
      }, 20);
      h.parentNode && h.parentNode.removeChild(h);
    };
    var p = null;
    1 < this.ds.scale && (h.style.transform = "scale(" + this.ds.scale + ")");
    h.addEventListener("mouseenter", function(a) {
      p && (clearTimeout(p), p = null);
    });
    h.addEventListener("mouseleave", function(a) {
      p = setTimeout(function() {
        h.close();
      }, 500);
    });
    f.search_box && f.search_box.close();
    f.search_box = h;
    var u = h.querySelector(".helper"), m = null, r = null, t = null, v = h.querySelector("input");
    v && (v.addEventListener("blur", function(a) {
      this.focus();
    }), v.addEventListener("keydown", function(a) {
      if (38 == a.keyCode) {
        c(!1);
      } else {
        if (40 == a.keyCode) {
          c(!0);
        } else {
          if (27 == a.keyCode) {
            h.close();
          } else {
            if (13 == a.keyCode) {
              t ? b(t.innerHTML) : m ? b(m) : h.close();
            } else {
              r && clearInterval(r);
              r = setTimeout(e, 10);
              return;
            }
          }
        }
      }
      a.preventDefault();
      a.stopPropagation();
      a.stopImmediatePropagation();
      return !0;
    }));
    q.fullscreenElement ? q.fullscreenElement.appendChild(h) : (q.body.appendChild(h), q.body.style.overflow = "hidden");
    g = g.getBoundingClientRect();
    var w = (a ? a.clientY : g.top + 0.5 * g.height) - 20;
    h.style.left = (a ? a.clientX : g.left + 0.5 * g.width) - 80 + "px";
    h.style.top = w + "px";
    a.layerY > g.height - 200 && (u.style.maxHeight = g.height - a.layerY - 20 + "px");
    v.focus();
    return h;
  };
  k.prototype.showEditPropertyValue = function(a, b, c) {
    function e() {
      f(m.value);
    }
    function f(c) {
      "number" == typeof a.properties[b] && (c = Number(c));
      if ("array" == d || "object" == d) {
        c = JSON.parse(c);
      }
      a.properties[b] = c;
      a._graph && a._graph._version++;
      if (a.onPropertyChanged) {
        a.onPropertyChanged(b, c);
      }
      p.close();
      a.setDirtyCanvas(!0, !0);
    }
    if (a && void 0 !== a.properties[b]) {
      c = c || {};
      var d = "string";
      null !== a.properties[b] && (d = typeof a.properties[b]);
      var g = null;
      a.getPropertyInfo && (g = a.getPropertyInfo(b));
      if (a.properties_info) {
        for (var l = 0; l < a.properties_info.length; ++l) {
          if (a.properties_info[l].name == b) {
            g = a.properties_info[l];
            break;
          }
        }
      }
      void 0 !== g && null !== g && g.type && (d = g.type);
      var h = "";
      if ("string" == d || "number" == d || "array" == d || "object" == d) {
        h = "<input autofocus type='text' class='value'/>";
      } else {
        if ("enum" == d && g.values) {
          h = "<select autofocus type='text' class='value'>";
          for (l in g.values) {
            var k = g.values.constructor === Array ? g.values[l] : l;
            h += "<option value='" + k + "' " + (k == a.properties[b] ? "selected" : "") + ">" + g.values[l] + "</option>";
          }
          h += "</select>";
        } else {
          if ("boolean" == d) {
            h = "<input autofocus type='checkbox' class='value' " + (a.properties[b] ? "checked" : "") + "/>";
          } else {
            console.warn("unknown type: " + d);
            return;
          }
        }
      }
      var p = this.createDialog("<span class='name'>" + b + "</span>" + h + "<button>OK</button>", c);
      if ("enum" == d && g.values) {
        var m = p.querySelector("select");
        m.addEventListener("change", function(a) {
          f(a.target.value);
        });
      } else {
        if ("boolean" == d) {
          (m = p.querySelector("input")) && m.addEventListener("click", function(a) {
            f(!!m.checked);
          });
        } else {
          if (m = p.querySelector("input")) {
            m.addEventListener("blur", function(a) {
              this.focus();
            }), k = void 0 !== a.properties[b] ? a.properties[b] : "", k = JSON.stringify(k), m.value = k, m.addEventListener("keydown", function(a) {
              13 == a.keyCode && (e(), a.preventDefault(), a.stopPropagation());
            });
          }
        }
      }
      p.querySelector("button").addEventListener("click", e);
    }
  };
  k.prototype.createDialog = function(a, b) {
    b = b || {};
    var c = document.createElement("div");
    c.className = "graphdialog";
    c.innerHTML = a;
    a = this.canvas.getBoundingClientRect();
    var e = -20, f = -20;
    a && (e -= a.left, f -= a.top);
    b.position ? (e += b.position[0], f += b.position[1]) : b.event ? (e += b.event.clientX, f += b.event.clientY) : (e += 0.5 * this.canvas.width, f += 0.5 * this.canvas.height);
    c.style.left = e + "px";
    c.style.top = f + "px";
    this.canvas.parentNode.appendChild(c);
    c.close = function() {
      this.parentNode && this.parentNode.removeChild(this);
    };
    return c;
  };
  k.onMenuNodeCollapse = function(a, b, c, e, f) {
    f.collapse();
  };
  k.onMenuNodePin = function(a, b, c, e, f) {
    f.pin();
  };
  k.onMenuNodeMode = function(a, b, c, e, f) {
    new d.ContextMenu(["Always", "On Event", "On Trigger", "Never"], {event:c, callback:function(a) {
      if (f) {
        switch(a) {
          case "On Event":
            f.mode = d.ON_EVENT;
            break;
          case "On Trigger":
            f.mode = d.ON_TRIGGER;
            break;
          case "Never":
            f.mode = d.NEVER;
            break;
          default:
            f.mode = d.ALWAYS;
        }
      }
    }, parentMenu:e, node:f});
    return !1;
  };
  k.onMenuNodeColors = function(a, b, c, e, f) {
    if (!f) {
      throw "no node for color";
    }
    b = [];
    b.push({value:null, content:"<span style='display: block; padding-left: 4px;'>No color</span>"});
    for (var l in k.node_colors) {
      a = k.node_colors[l], a = {value:l, content:"<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + a.color + "; background-color:" + a.bgcolor + "'>" + l + "</span>"}, b.push(a);
    }
    new d.ContextMenu(b, {event:c, callback:function(a) {
      f && ((a = a.value ? k.node_colors[a.value] : null) ? f.constructor === d.LGraphGroup ? f.color = a.groupcolor : (f.color = a.color, f.bgcolor = a.bgcolor) : (delete f.color, delete f.bgcolor), f.setDirtyCanvas(!0, !0));
    }, parentMenu:e, node:f});
    return !1;
  };
  k.onMenuNodeShapes = function(a, b, c, e, f) {
    if (!f) {
      throw "no node passed";
    }
    new d.ContextMenu(d.VALID_SHAPES, {event:c, callback:function(a) {
      f && (f.shape = a, f.setDirtyCanvas(!0));
    }, parentMenu:e, node:f});
    return !1;
  };
  k.onMenuNodeRemove = function(a, b, c, e, f) {
    if (!f) {
      throw "no node passed";
    }
    !1 !== f.removable && (f.graph.remove(f), f.setDirtyCanvas(!0, !0));
  };
  k.onMenuNodeClone = function(a, b, c, e, f) {
    0 != f.clonable && (a = f.clone()) && (a.pos = [f.pos[0] + 5, f.pos[1] + 5], f.graph.add(a), f.setDirtyCanvas(!0, !0));
  };
  k.node_colors = {red:{color:"#322", bgcolor:"#533", groupcolor:"#A88"}, brown:{color:"#332922", bgcolor:"#593930", groupcolor:"#b06634"}, green:{color:"#232", bgcolor:"#353", groupcolor:"#8A8"}, blue:{color:"#223", bgcolor:"#335", groupcolor:"#88A"}, pale_blue:{color:"#2a363b", bgcolor:"#3f5159", groupcolor:"#3f789e"}, cyan:{color:"#233", bgcolor:"#355", groupcolor:"#8AA"}, purple:{color:"#323", bgcolor:"#535", groupcolor:"#a1309b"}, yellow:{color:"#432", bgcolor:"#653", groupcolor:"#b58b2a"}, 
  black:{color:"#222", bgcolor:"#000", groupcolor:"#444"}};
  k.prototype.getCanvasMenuOptions = function() {
    if (this.getMenuOptions) {
      var a = this.getMenuOptions();
    } else {
      a = [{content:"Add Node", has_submenu:!0, callback:k.onMenuAdd}, {content:"Add Group", callback:k.onGroupAdd}], this._graph_stack && 0 < this._graph_stack.length && a.push(null, {content:"Close subgraph", callback:this.closeSubgraph.bind(this)});
    }
    if (this.getExtraMenuOptions) {
      var b = this.getExtraMenuOptions(this, a);
      b && (a = a.concat(b));
    }
    return a;
  };
  k.prototype.getNodeMenuOptions = function(a) {
    var b = a.getMenuOptions ? a.getMenuOptions(this) : [{content:"Inputs", has_submenu:!0, disabled:!0, callback:k.showMenuNodeOptionalInputs}, {content:"Outputs", has_submenu:!0, disabled:!0, callback:k.showMenuNodeOptionalOutputs}, null, {content:"Properties", has_submenu:!0, callback:k.onShowMenuNodeProperties}, null, {content:"Title", callback:k.onShowPropertyEditor}, {content:"Mode", has_submenu:!0, callback:k.onMenuNodeMode}, {content:"Resize", callback:k.onResizeNode}, {content:"Collapse", 
    callback:k.onMenuNodeCollapse}, {content:"Pin", callback:k.onMenuNodePin}, {content:"Colors", has_submenu:!0, callback:k.onMenuNodeColors}, {content:"Shapes", has_submenu:!0, callback:k.onMenuNodeShapes}, null];
    if (a.onGetInputs) {
      var c = a.onGetInputs();
      c && c.length && (b[0].disabled = !1);
    }
    a.onGetOutputs && (c = a.onGetOutputs()) && c.length && (b[1].disabled = !1);
    a.getExtraMenuOptions && (c = a.getExtraMenuOptions(this)) && (c.push(null), b = c.concat(b));
    !1 !== a.clonable && b.push({content:"Clone", callback:k.onMenuNodeClone});
    !1 !== a.removable && b.push(null, {content:"Remove", callback:k.onMenuNodeRemove});
    if (a.graph && a.graph.onGetNodeMenuOptions) {
      a.graph.onGetNodeMenuOptions(b, a);
    }
    return b;
  };
  k.prototype.getGroupMenuOptions = function(a) {
    return [{content:"Title", callback:k.onShowPropertyEditor}, {content:"Color", has_submenu:!0, callback:k.onMenuNodeColors}, {content:"Font size", property:"font_size", type:"Number", callback:k.onShowPropertyEditor}, null, {content:"Remove", callback:k.onMenuNodeRemove}];
  };
  k.prototype.processContextMenu = function(a, b) {
    var c = this, e = k.active_canvas.getCanvasWindow(), f = null, l = {event:b, callback:function(b, e, f) {
      if (b) {
        if ("Remove Slot" == b.content) {
          b = b.slot, b.input ? a.removeInput(b.slot) : b.output && a.removeOutput(b.slot);
        } else {
          if ("Disconnect Links" == b.content) {
            b = b.slot, b.output ? a.disconnectOutput(b.slot) : b.input && a.disconnectInput(b.slot);
          } else {
            if ("Rename Slot" == b.content) {
              b = b.slot;
              var d = b.input ? a.getInputInfo(b.slot) : a.getOutputInfo(b.slot), g = c.createDialog("<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>", e), l = g.querySelector("input");
              l && d && (l.value = d.label || "");
              g.querySelector("button").addEventListener("click", function(a) {
                l.value && (d && (d.label = l.value), c.setDirty(!0));
                g.close();
              });
            }
          }
        }
      }
    }, extra:a};
    a && (l.title = a.type);
    var g = null;
    a && (g = a.getSlotInPosition(b.canvasX, b.canvasY), k.active_node = a);
    g ? (f = [], g && g.output && g.output.links && g.output.links.length && f.push({content:"Disconnect Links", slot:g}), b = g.input || g.output, f.push(b.locked ? "Cannot remove" : {content:"Remove Slot", slot:g}), f.push(b.nameLocked ? "Cannot rename" : {content:"Rename Slot", slot:g}), l.title = (g.input ? g.input.type : g.output.type) || "*", g.input && g.input.type == d.ACTION && (l.title = "Action"), g.output && g.output.type == d.EVENT && (l.title = "Event")) : a ? f = this.getNodeMenuOptions(a) : 
    (f = this.getCanvasMenuOptions(), (g = this.graph.getGroupOnPos(b.canvasX, b.canvasY)) && f.push(null, {content:"Edit Group", has_submenu:!0, submenu:{title:"Group", extra:g, options:this.getGroupMenuOptions(g)}}));
    f && new d.ContextMenu(f, l, e);
  };
  this.CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.roundRect = function(a, b, c, e, f, d) {
    void 0 === f && (f = 5);
    void 0 === d && (d = f);
    this.moveTo(a + f, b);
    this.lineTo(a + c - f, b);
    this.quadraticCurveTo(a + c, b, a + c, b + f);
    this.lineTo(a + c, b + e - d);
    this.quadraticCurveTo(a + c, b + e, a + c - d, b + e);
    this.lineTo(a + d, b + e);
    this.quadraticCurveTo(a, b + e, a, b + e - d);
    this.lineTo(a, b + f);
    this.quadraticCurveTo(a, b, a + f, b);
  });
  d.compareObjects = function(a, b) {
    for (var c in a) {
      if (a[c] != b[c]) {
        return !1;
      }
    }
    return !0;
  };
  d.distance = H;
  d.colorToString = function(a) {
    return "rgba(" + Math.round(255 * a[0]).toFixed() + "," + Math.round(255 * a[1]).toFixed() + "," + Math.round(255 * a[2]).toFixed() + "," + (4 == a.length ? a[3].toFixed(2) : "1.0") + ")";
  };
  d.isInsideRectangle = C;
  d.growBounding = function(a, b, c) {
    b < a[0] ? a[0] = b : b > a[2] && (a[2] = b);
    c < a[1] ? a[1] = c : c > a[3] && (a[3] = c);
  };
  d.isInsideBounding = function(a, b) {
    return a[0] < b[0][0] || a[1] < b[0][1] || a[0] > b[1][0] || a[1] > b[1][1] ? !1 : !0;
  };
  d.overlapBounding = I;
  d.hex2num = function(a) {
    "#" == a.charAt(0) && (a = a.slice(1));
    a = a.toUpperCase();
    for (var b = Array(3), c = 0, e, f, d = 0; 6 > d; d += 2) {
      e = "0123456789ABCDEF".indexOf(a.charAt(d)), f = "0123456789ABCDEF".indexOf(a.charAt(d + 1)), b[c] = 16 * e + f, c++;
    }
    return b;
  };
  d.num2hex = function(a) {
    for (var b = "#", c, e, f = 0; 3 > f; f++) {
      c = a[f] / 16, e = a[f] % 16, b += "0123456789ABCDEF".charAt(c) + "0123456789ABCDEF".charAt(e);
    }
    return b;
  };
  E.prototype.addItem = function(a, b, c) {
    function e(a) {
      var b = this.value;
      b && b.has_submenu && f.call(this, a);
    }
    function f(a) {
      var b = this.value, e = !0;
      d.current_submenu && d.current_submenu.close(a);
      if (c.callback) {
        var f = c.callback.call(this, b, c, a, d, c.node);
        !0 === f && (e = !1);
      }
      if (b && (b.callback && !c.ignore_item_callbacks && !0 !== b.disabled && (f = b.callback.call(this, b, c, a, d, c.extra), !0 === f && (e = !1)), b.submenu)) {
        if (!b.submenu.options) {
          throw "ContextMenu submenu needs options";
        }
        new d.constructor(b.submenu.options, {callback:b.submenu.callback, event:a, parentMenu:d, ignore_item_callbacks:b.submenu.ignore_item_callbacks, title:b.submenu.title, extra:b.submenu.extra, autoopen:c.autoopen});
        e = !1;
      }
      e && !d.lock && d.close();
    }
    var d = this;
    c = c || {};
    var g = document.createElement("div");
    g.className = "litemenu-entry submenu";
    var l = !1;
    if (null === b) {
      g.classList.add("separator");
    } else {
      g.innerHTML = b && b.title ? b.title : a;
      if (g.value = b) {
        b.disabled && (l = !0, g.classList.add("disabled")), (b.submenu || b.has_submenu) && g.classList.add("has_submenu");
      }
      "function" == typeof b ? (g.dataset.value = a, g.onclick_callback = b) : g.dataset.value = b;
      b.className && (g.className += " " + b.className);
    }
    this.root.appendChild(g);
    l || g.addEventListener("click", f);
    c.autoopen && g.addEventListener("mouseenter", e);
    return g;
  };
  E.prototype.close = function(a, b) {
    this.root.parentNode && this.root.parentNode.removeChild(this.root);
    this.parentMenu && !b && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, void 0 === a ? this.parentMenu.close() : a && !E.isCursorOverElement(a, this.parentMenu.root) && E.trigger(this.parentMenu.root, "mouseleave", a));
    this.current_submenu && this.current_submenu.close(a, !0);
    this.root.closing_timer && clearTimeout(this.root.closing_timer);
  };
  E.trigger = function(a, b, c, e) {
    var f = document.createEvent("CustomEvent");
    f.initCustomEvent(b, !0, !0, c);
    f.srcElement = e;
    a.dispatchEvent ? a.dispatchEvent(f) : a.__events && a.__events.dispatchEvent(f);
    return f;
  };
  E.prototype.getTopMenu = function() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this;
  };
  E.prototype.getFirstEvent = function() {
    return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event;
  };
  E.isCursorOverElement = function(a, b) {
    var c = a.clientX;
    a = a.clientY;
    return (b = b.getBoundingClientRect()) ? a > b.top && a < b.top + b.height && c > b.left && c < b.left + b.width ? !0 : !1 : !1;
  };
  d.ContextMenu = E;
  d.closeAllContextMenus = function(a) {
    a = a || window;
    a = a.document.querySelectorAll(".litecontextmenu");
    if (a.length) {
      for (var b = [], c = 0; c < a.length; c++) {
        b.push(a[c]);
      }
      for (c in b) {
        b[c].close ? b[c].close() : b[c].parentNode && b[c].parentNode.removeChild(b[c]);
      }
    }
  };
  d.extendClass = function(a, b) {
    for (var c in b) {
      a.hasOwnProperty(c) || (a[c] = b[c]);
    }
    if (b.prototype) {
      for (c in b.prototype) {
        b.prototype.hasOwnProperty(c) && !a.prototype.hasOwnProperty(c) && (b.prototype.__lookupGetter__(c) ? a.prototype.__defineGetter__(c, b.prototype.__lookupGetter__(c)) : a.prototype[c] = b.prototype[c], b.prototype.__lookupSetter__(c) && a.prototype.__defineSetter__(c, b.prototype.__lookupSetter__(c)));
      }
    }
  };
  F.sampleCurve = function(a, b) {
    if (b) {
      for (var c = 0; c < b.length - 1; ++c) {
        var e = b[c], f = b[c + 1];
        if (!(f[0] < a)) {
          b = f[0] - e[0];
          if (0.00001 > Math.abs(b)) {
            return e[1];
          }
          a = (a - e[0]) / b;
          return e[1] * (1.0 - a) + f[1] * a;
        }
      }
      return 0;
    }
  };
  F.prototype.draw = function(a, b, c, e, f, d) {
    if (c = this.points) {
      this.size = b;
      var l = b[0] - 2 * this.margin;
      b = b[1] - 2 * this.margin;
      f = f || "#666";
      a.save();
      a.translate(this.margin, this.margin);
      e && (a.fillStyle = "#111", a.fillRect(0, 0, l, b), a.fillStyle = "#222", a.fillRect(0.5 * l, 0, 1, b), a.strokeStyle = "#333", a.strokeRect(0, 0, l, b));
      a.strokeStyle = f;
      d && (a.globalAlpha = 0.5);
      a.beginPath();
      for (e = 0; e < c.length; ++e) {
        f = c[e], a.lineTo(f[0] * l, (1.0 - f[1]) * b);
      }
      a.stroke();
      a.globalAlpha = 1;
      if (!d) {
        for (e = 0; e < c.length; ++e) {
          f = c[e], a.fillStyle = this.selected == e ? "#FFF" : this.nearest == e ? "#DDD" : "#AAA", a.beginPath(), a.arc(f[0] * l, (1.0 - f[1]) * b, 2, 0, 2 * Math.PI), a.fill();
        }
      }
      a.restore();
    }
  };
  F.prototype.onMouseDown = function(a, b) {
    var c = this.points;
    if (c && !(0 > a[1])) {
      var e = this.size[0] - 2 * this.margin, f = this.size[1] - 2 * this.margin, d = a[0] - this.margin;
      a = a[1] - this.margin;
      this.selected = this.getCloserPoint([d, a], 30 / b.ds.scale);
      -1 == this.selected && (b = [d / e, 1 - a / f], c.push(b), c.sort(function(a, b) {
        return a[0] - b[0];
      }), this.selected = c.indexOf(b), this.must_update = !0);
      if (-1 != this.selected) {
        return !0;
      }
    }
  };
  F.prototype.onMouseMove = function(a, b) {
    var c = this.points;
    if (c) {
      var e = this.selected;
      if (!(0 > e)) {
        var f = (a[0] - this.margin) / (this.size[0] - 2 * this.margin), d = (a[1] - this.margin) / (this.size[1] - 2 * this.margin);
        this._nearest = this.getCloserPoint([a[0] - this.margin, a[1] - this.margin], 30 / b.ds.scale);
        if (b = c[e]) {
          var l = 0 == e || e == c.length - 1;
          !l && (-10 > a[0] || a[0] > this.size[0] + 10 || -10 > a[1] || a[1] > this.size[1] + 10) ? (c.splice(e, 1), this.selected = -1) : (b[0] = l ? 0 == e ? 0 : 1 : Math.clamp(f, 0, 1), b[1] = 1.0 - Math.clamp(d, 0, 1), c.sort(function(a, b) {
            return a[0] - b[0];
          }), this.selected = c.indexOf(b), this.must_update = !0);
        }
      }
    }
  };
  F.prototype.onMouseUp = function(a, b) {
    this.selected = -1;
    return !1;
  };
  F.prototype.getCloserPoint = function(a, b) {
    var c = this.points;
    if (!c) {
      return -1;
    }
    b = b || 30;
    for (var e = this.size[0] - 2 * this.margin, f = this.size[1] - 2 * this.margin, d = c.length, l = [0, 0], h = 1000000, k = -1, p = 0; p < d; ++p) {
      var r = c[p];
      l[0] = r[0] * e;
      l[1] = (1.0 - r[1]) * f;
      r = vec2.distance(a, l);
      r > h || r > b || (k = p, h = r);
    }
    return k;
  };
  d.CurveEditor = F;
  d.getParameterNames = function(a) {
    return (a + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  };
  Math.clamp = function(a, b, c) {
    return b > a ? b : c < a ? c : a;
  };
  "undefined" == typeof window || window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
    window.setTimeout(a, 1000 / 60);
  });
})(this);
"undefined" != typeof exports && (exports.LiteGraph = this.LiteGraph);
(function(p) {
  function r() {
    this.addOutput("in ms", "number");
    this.addOutput("in sec", "number");
  }
  function t() {
    this.size = [140, 80];
    this.properties = {enabled:!0};
    this.enabled = !0;
    this.subgraph = new v.LGraph;
    this.subgraph._subgraph_node = this;
    this.subgraph._is_subgraph = !0;
    this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);
    this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);
    this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);
    this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);
    this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);
    this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);
    this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);
    this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);
    this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
  }
  function h() {
    this.addOutput("", "number");
    this.name_in_graph = "";
    this.properties = {name:"", type:"number", value:0};
    var d = this;
    this.name_widget = this.addWidget("text", "Name", this.properties.name, function(a) {
      a && d.setProperty("name", a);
    });
    this.type_widget = this.addWidget("text", "Type", this.properties.type, function(a) {
      d.setProperty("type", a);
    });
    this.value_widget = this.addWidget("number", "Value", this.properties.value, function(a) {
      d.setProperty("value", a);
    });
    this.widgets_up = !0;
    this.size = [180, 90];
  }
  function A() {
    this.addInput("", "");
    this.name_in_graph = "";
    this.properties = {};
    var d = this;
    Object.defineProperty(this.properties, "name", {get:function() {
      return d.name_in_graph;
    }, set:function(a) {
      "" != a && a != d.name_in_graph && (d.name_in_graph ? d.graph.renameOutput(d.name_in_graph, a) : d.graph.addOutput(a, d.properties.type), d.name_widget.value = a, d.name_in_graph = a);
    }, enumerable:!0});
    Object.defineProperty(this.properties, "type", {get:function() {
      return d.inputs[0].type;
    }, set:function(a) {
      if ("action" == a || "event" == a) {
        a = v.ACTION;
      }
      d.inputs[0].type = a;
      d.name_in_graph && d.graph.changeOutputType(d.name_in_graph, d.inputs[0].type);
      d.type_widget.value = a || "";
    }, enumerable:!0});
    this.name_widget = this.addWidget("text", "Name", this.properties.name, function(a) {
      a && (d.properties.name = a);
    });
    this.type_widget = this.addWidget("text", "Type", this.properties.type, function(a) {
      d.properties.type = a || "";
    });
    this.widgets_up = !0;
    this.size = [180, 60];
  }
  function B() {
    this.addOutput("value", "number");
    this.addProperty("value", 1.0);
  }
  function k() {
    this.addOutput("", "string");
    this.addProperty("value", "");
    this.widget = this.addWidget("text", "value", "", this.setValue.bind(this));
    this.widgets_up = !0;
    this.size = [100, 30];
  }
  function H() {
    this.addOutput("", "");
    this.addProperty("value", "");
    this.widget = this.addWidget("text", "json", "", this.setValue.bind(this));
    this.widgets_up = !0;
    this.size = [140, 30];
    this._value = null;
  }
  function C() {
    this.addInput("obj", "");
    this.addOutput("", "");
    this.addProperty("value", "");
    this.widget = this.addWidget("text", "prop.", "", this.setValue.bind(this));
    this.widgets_up = !0;
    this.size = [140, 30];
    this._value = null;
  }
  function I() {
    this.addInput("obj", "");
    this.addOutput("keys", "array");
    this.size = [140, 30];
  }
  function E() {
    this.addInput("A", "object");
    this.addInput("B", "object");
    this.addOutput("", "object");
    this._result = {};
    var d = this;
    this.addWidget("button", "clear", "", function() {
      d._result = {};
    });
    this.size = this.computeSize();
  }
  function F() {
    this.size = [60, 30];
    this.addInput("in");
    this.addOutput("out");
    this.properties = {varname:"myname", global:!1};
    this.value = null;
  }
  function d() {
    this.size = [60, 30];
    this.addInput("data", 0);
    this.addInput("download", v.ACTION);
    this.properties = {filename:"data.json"};
    this.value = null;
    var d = this;
    this.addWidget("button", "Download", "", function(a) {
      d.value && d.downloadAsFile();
    });
  }
  function J() {
    this.size = [60, 30];
    this.addInput("value", 0, {label:""});
    this.value = 0;
  }
  function D() {
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.size = [40, 30];
  }
  function w() {
    this.mode = v.ON_EVENT;
    this.size = [80, 30];
    this.addProperty("msg", "");
    this.addInput("log", v.EVENT);
    this.addInput("msg", 0);
  }
  function G() {
    this.mode = v.ON_EVENT;
    this.addProperty("msg", "");
    this.addInput("", v.EVENT);
    var d = this;
    this.widget = this.addWidget("text", "Text", "", function(a) {
      d.properties.msg = a;
    });
    this.widgets_up = !0;
    this.size = [200, 30];
  }
  function z() {
    this.size = [60, 30];
    this.addProperty("onExecute", "return A;");
    this.addInput("A", "");
    this.addInput("B", "");
    this.addOutput("out", "");
    this._func = null;
    this.data = {};
  }
  var v = p.LiteGraph;
  r.title = "Time";
  r.desc = "Time";
  r.prototype.onExecute = function() {
    this.setOutputData(0, 1000 * this.graph.globaltime);
    this.setOutputData(1, this.graph.globaltime);
  };
  v.registerNodeType("basic/time", r);
  t.title = "Subgraph";
  t.desc = "Graph inside a node";
  t.title_color = "#334";
  t.prototype.onGetInputs = function() {
    return [["enabled", "boolean"]];
  };
  t.prototype.onDrawTitle = function(d) {
    if (!this.flags.collapsed) {
      d.fillStyle = "#555";
      var a = v.NODE_TITLE_HEIGHT, b = this.size[0] - a;
      d.fillRect(b, -a, a, a);
      d.fillStyle = "#333";
      d.beginPath();
      d.moveTo(b + 0.2 * a, 0.6 * -a);
      d.lineTo(b + 0.8 * a, 0.6 * -a);
      d.lineTo(b + 0.5 * a, 0.3 * -a);
      d.fill();
    }
  };
  t.prototype.onDblClick = function(d, a, b) {
    var c = this;
    setTimeout(function() {
      b.openSubgraph(c.subgraph);
    }, 10);
  };
  t.prototype.onMouseDown = function(d, a, b) {
    if (!this.flags.collapsed && a[0] > this.size[0] - v.NODE_TITLE_HEIGHT && 0 > a[1]) {
      var c = this;
      setTimeout(function() {
        b.openSubgraph(c.subgraph);
      }, 10);
    }
  };
  t.prototype.onAction = function(d, a) {
    this.subgraph.onAction(d, a);
  };
  t.prototype.onExecute = function() {
    if (this.enabled = this.getInputOrProperty("enabled")) {
      if (this.inputs) {
        for (var d = 0; d < this.inputs.length; d++) {
          var a = this.inputs[d], b = this.getInputData(d);
          this.subgraph.setInputData(a.name, b);
        }
      }
      this.subgraph.runStep();
      if (this.outputs) {
        for (d = 0; d < this.outputs.length; d++) {
          b = this.subgraph.getOutputData(this.outputs[d].name), this.setOutputData(d, b);
        }
      }
    }
  };
  t.prototype.sendEventToAllNodes = function(d, a, b) {
    this.enabled && this.subgraph.sendEventToAllNodes(d, a, b);
  };
  t.prototype.onSubgraphTrigger = function(d, a) {
    d = this.findOutputSlot(d);
    -1 != d && this.triggerSlot(d);
  };
  t.prototype.onSubgraphNewInput = function(d, a) {
    -1 == this.findInputSlot(d) && this.addInput(d, a);
  };
  t.prototype.onSubgraphRenamedInput = function(d, a) {
    d = this.findInputSlot(d);
    -1 != d && (this.getInputInfo(d).name = a);
  };
  t.prototype.onSubgraphTypeChangeInput = function(d, a) {
    d = this.findInputSlot(d);
    -1 != d && (this.getInputInfo(d).type = a);
  };
  t.prototype.onSubgraphRemovedInput = function(d) {
    d = this.findInputSlot(d);
    -1 != d && this.removeInput(d);
  };
  t.prototype.onSubgraphNewOutput = function(d, a) {
    -1 == this.findOutputSlot(d) && this.addOutput(d, a);
  };
  t.prototype.onSubgraphRenamedOutput = function(d, a) {
    d = this.findOutputSlot(d);
    -1 != d && (this.getOutputInfo(d).name = a);
  };
  t.prototype.onSubgraphTypeChangeOutput = function(d, a) {
    d = this.findOutputSlot(d);
    -1 != d && (this.getOutputInfo(d).type = a);
  };
  t.prototype.onSubgraphRemovedOutput = function(d) {
    d = this.findInputSlot(d);
    -1 != d && this.removeOutput(d);
  };
  t.prototype.getExtraMenuOptions = function(d) {
    var a = this;
    return [{content:"Open", callback:function() {
      d.openSubgraph(a.subgraph);
    }}];
  };
  t.prototype.onResize = function(d) {
    d[1] += 20;
  };
  t.prototype.serialize = function() {
    var d = LGraphNode.prototype.serialize.call(this);
    d.subgraph = this.subgraph.serialize();
    return d;
  };
  t.prototype.clone = function() {
    var d = v.createNode(this.type), a = this.serialize();
    delete a.id;
    delete a.inputs;
    delete a.outputs;
    d.configure(a);
    return d;
  };
  v.Subgraph = t;
  v.registerNodeType("graph/subgraph", t);
  h.title = "Input";
  h.desc = "Input of the graph";
  h.prototype.onConfigure = function() {
    this.updateType();
  };
  h.prototype.updateType = function() {
    var d = this.properties.type;
    this.type_widget.value = d;
    "number" == d ? (this.value_widget.type = "number", this.value_widget.value = 0) : "bool" == d ? (this.value_widget.type = "toggle", this.value_widget.value = !0) : "string" == d ? (this.value_widget.type = "text", this.value_widget.value = "") : (this.value_widget.type = null, this.value_widget.value = null);
    this.properties.value = this.value_widget.value;
  };
  h.prototype.onPropertyChanged = function(d, a) {
    if ("name" == d) {
      if ("" == a || a == this.name_in_graph || "enabled" == a) {
        return !1;
      }
      this.graph && (this.name_in_graph ? this.graph.renameInput(this.name_in_graph, a) : this.graph.addInput(a, this.properties.type));
      this.name_in_graph = this.name_widget.value = a;
    } else {
      "type" == d && this.updateType(a || "");
    }
  };
  h.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.name : this.title;
  };
  h.prototype.onAction = function(d, a) {
    this.properties.type == v.EVENT && this.triggerSlot(0, a);
  };
  h.prototype.onExecute = function() {
    var d = this.graph.inputs[this.properties.name];
    d || this.setOutputData(0, this.properties.value);
    this.setOutputData(0, void 0 === d.value ? this.properties.value : d.value);
  };
  h.prototype.onRemoved = function() {
    this.name_in_graph && this.graph.removeInput(this.name_in_graph);
  };
  v.GraphInput = h;
  v.registerNodeType("graph/input", h);
  A.title = "Output";
  A.desc = "Output of the graph";
  A.prototype.onExecute = function() {
    this._value = this.getInputData(0);
    this.graph.setOutputData(this.properties.name, this._value);
  };
  A.prototype.onAction = function(d, a) {
    this.properties.type == v.ACTION && this.graph.trigger(this.properties.name, a);
  };
  A.prototype.onRemoved = function() {
    this.name_in_graph && this.graph.removeOutput(this.name_in_graph);
  };
  A.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.name : this.title;
  };
  v.GraphOutput = A;
  v.registerNodeType("graph/output", A);
  B.title = "Const Number";
  B.desc = "Constant number";
  B.prototype.onExecute = function() {
    this.setOutputData(0, parseFloat(this.properties.value));
  };
  B.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.value : this.title;
  };
  B.prototype.setValue = function(d) {
    this.properties.value = d;
  };
  B.prototype.onDrawBackground = function(d) {
    this.outputs[0].label = this.properties.value.toFixed(3);
  };
  v.registerNodeType("basic/const", B);
  k.title = "Const String";
  k.desc = "Constant string";
  k.prototype.setValue = function(d) {
    this.properties.value = d;
  };
  k.prototype.onPropertyChanged = function(d, a) {
    this.widget.value = a;
  };
  k.prototype.getTitle = B.prototype.getTitle;
  k.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  v.registerNodeType("basic/string", k);
  H.title = "Const Data";
  H.desc = "Constant Data";
  H.prototype.setValue = function(d) {
    this.properties.value = d;
    this.onPropertyChanged("value", d);
  };
  H.prototype.onPropertyChanged = function(d, a) {
    this.widget.value = a;
    if (null != a && "" != a) {
      try {
        this._value = JSON.parse(a), this.boxcolor = "#AEA";
      } catch (b) {
        this.boxcolor = "red";
      }
    }
  };
  H.prototype.onExecute = function() {
    this.setOutputData(0, this._value);
  };
  v.registerNodeType("basic/data", H);
  C.title = "Object property";
  C.desc = "Outputs the property of an object";
  C.prototype.setValue = function(d) {
    this.properties.value = d;
    this.widget.value = d;
  };
  C.prototype.getTitle = function() {
    return this.flags.collapsed ? "in." + this.properties.value : this.title;
  };
  C.prototype.onPropertyChanged = function(d, a) {
    this.widget.value = a;
  };
  C.prototype.onExecute = function() {
    var d = this.getInputData(0);
    null != d && this.setOutputData(0, d[this.properties.value]);
  };
  v.registerNodeType("basic/object_property", C);
  I.title = "Object keys";
  I.desc = "Outputs an array with the keys of an object";
  I.prototype.onExecute = function() {
    var d = this.getInputData(0);
    null != d && this.setOutputData(0, Object.keys(d));
  };
  v.registerNodeType("basic/object_keys", I);
  E.title = "Merge Objects";
  E.desc = "Creates an object copying properties from others";
  E.prototype.onExecute = function() {
    var d = this.getInputData(0), a = this.getInputData(1), b = this._result;
    if (d) {
      for (var c in d) {
        b[c] = d[c];
      }
    }
    if (a) {
      for (c in a) {
        b[c] = a[c];
      }
    }
    this.setOutputData(0, b);
  };
  v.registerNodeType("basic/merge_objects", E);
  F.title = "Variable";
  F.desc = "store/read variable value";
  F.prototype.onExecute = function() {
    this.value = this.getInputData(0);
    this.graph && (this.graph.vars[this.properties.varname] = this.value);
    this.properties.global && (p[this.properties.varname] = this.value);
    this.setOutputData(0, this.value);
  };
  F.prototype.getTitle = function() {
    return this.properties.varname;
  };
  v.registerNodeType("basic/variable", F);
  d.title = "Download";
  d.desc = "Download some data";
  d.prototype.downloadAsFile = function() {
    if (null != this.value) {
      var d = null;
      d = this.value.constructor === String ? this.value : JSON.stringify(this.value);
      d = new Blob([d]);
      var a = URL.createObjectURL(d);
      d = document.createElement("a");
      d.setAttribute("href", a);
      d.setAttribute("download", this.properties.filename);
      d.style.display = "none";
      document.body.appendChild(d);
      d.click();
      document.body.removeChild(d);
      setTimeout(function() {
        URL.revokeObjectURL(a);
      }, 6E4);
    }
  };
  d.prototype.onAction = function(d, a) {
    var b = this;
    setTimeout(function() {
      b.downloadAsFile();
    }, 100);
  };
  d.prototype.onExecute = function() {
    this.inputs[0] && (this.value = this.getInputData(0));
  };
  d.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.filename : this.title;
  };
  v.registerNodeType("basic/download", d);
  J.title = "Watch";
  J.desc = "Show value of input";
  J.prototype.onExecute = function() {
    this.inputs[0] && (this.value = this.getInputData(0));
  };
  J.prototype.getTitle = function() {
    return this.flags.collapsed ? this.inputs[0].label : this.title;
  };
  J.toString = function(d) {
    if (null == d) {
      return "null";
    }
    if (d.constructor === Number) {
      return d.toFixed(3);
    }
    if (d.constructor === Array) {
      for (var a = "[", b = 0; b < d.length; ++b) {
        a += J.toString(d[b]) + (b + 1 != d.length ? "," : "");
      }
      return a + "]";
    }
    return String(d);
  };
  J.prototype.onDrawBackground = function(d) {
    this.inputs[0].label = J.toString(this.value);
  };
  v.registerNodeType("basic/watch", J);
  D.title = "Cast";
  D.desc = "Allows to connect different types";
  D.prototype.onExecute = function() {
    this.setOutputData(0, this.getInputData(0));
  };
  v.registerNodeType("basic/cast", D);
  w.title = "Console";
  w.desc = "Show value inside the console";
  w.prototype.onAction = function(d, a) {
    "log" == d ? console.log(a) : "warn" == d ? console.warn(a) : "error" == d && console.error(a);
  };
  w.prototype.onExecute = function() {
    var d = this.getInputData(1);
    null !== d && (this.properties.msg = d);
    console.log(d);
  };
  w.prototype.onGetInputs = function() {
    return [["log", v.ACTION], ["warn", v.ACTION], ["error", v.ACTION]];
  };
  v.registerNodeType("basic/console", w);
  G.title = "Alert";
  G.desc = "Show an alert window";
  G.color = "#510";
  G.prototype.onConfigure = function(d) {
    this.widget.value = d.properties.msg;
  };
  G.prototype.onAction = function(d, a) {
    var b = this.properties.msg;
    setTimeout(function() {
      alert(b);
    }, 10);
  };
  v.registerNodeType("basic/alert", G);
  z.prototype.onConfigure = function(d) {
    d.properties.onExecute && v.allow_scripts ? this.compileCode(d.properties.onExecute) : console.warn("Script not compiled, LiteGraph.allow_scripts is false");
  };
  z.title = "Script";
  z.desc = "executes a code (max 100 characters)";
  z.widgets_info = {onExecute:{type:"code"}};
  z.prototype.onPropertyChanged = function(d, a) {
    "onExecute" == d && v.allow_scripts ? this.compileCode(a) : console.warn("Script not compiled, LiteGraph.allow_scripts is false");
  };
  z.prototype.compileCode = function(d) {
    this._func = null;
    if (256 < d.length) {
      console.warn("Script too long, max 256 chars");
    } else {
      for (var a = d.toLowerCase(), b = "script body document eval nodescript function".split(" "), c = 0; c < b.length; ++c) {
        if (-1 != a.indexOf(b[c])) {
          console.warn("invalid script");
          return;
        }
      }
      try {
        this._func = new Function("A", "B", "C", "DATA", "node", d);
      } catch (e) {
        console.error("Error parsing script"), console.error(e);
      }
    }
  };
  z.prototype.onExecute = function() {
    if (this._func) {
      try {
        var d = this.getInputData(0), a = this.getInputData(1), b = this.getInputData(2);
        this.setOutputData(0, this._func(d, a, b, this.data, this));
      } catch (c) {
        console.error("Error in script"), console.error(c);
      }
    }
  };
  z.prototype.onGetOutputs = function() {
    return [["C", ""]];
  };
  v.registerNodeType("basic/script", z);
})(this);

