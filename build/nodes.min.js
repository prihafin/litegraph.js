var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(n, a, h) {
  n != Array.prototype && n != Object.prototype && (n[a] = h.value);
};
$jscomp.getGlobal = function(n) {
  return "undefined" != typeof window && window === n ? n : "undefined" != typeof global && null != global ? global : n;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(n, a, h, c) {
  if (a) {
    h = $jscomp.global;
    n = n.split(".");
    for (c = 0; c < n.length - 1; c++) {
      var b = n[c];
      b in h || (h[b] = {});
      h = h[b];
    }
    n = n[n.length - 1];
    c = h[n];
    a = a(c);
    a != c && null != a && $jscomp.defineProperty(h, n, {configurable:!0, writable:!0, value:a});
  }
};
$jscomp.polyfill("Array.prototype.fill", function(n) {
  return n ? n : function(a, h, c) {
    var b = this.length || 0;
    0 > h && (h = Math.max(0, b + h));
    if (null == c || c > b) {
      c = b;
    }
    c = Number(c);
    0 > c && (c = Math.max(0, b + c));
    for (h = Number(h || 0); h < c; h++) {
      this[h] = a;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var n = 0;
  return function(a) {
    return $jscomp.SYMBOL_PREFIX + (a || "") + n++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var n = $jscomp.global.Symbol.iterator;
  n || (n = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[n] && $jscomp.defineProperty(Array.prototype, n, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(n) {
  var a = 0;
  return $jscomp.iteratorPrototype(function() {
    return a < n.length ? {done:!1, value:n[a++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(n) {
  $jscomp.initSymbolIterator();
  n = {next:n};
  n[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return n;
};
$jscomp.iteratorFromArray = function(n, a) {
  $jscomp.initSymbolIterator();
  n instanceof String && (n += "");
  var h = 0, c = {next:function() {
    if (h < n.length) {
      var b = h++;
      return {value:a(b, n[b]), done:!1};
    }
    c.next = function() {
      return {done:!0, value:void 0};
    };
    return c.next();
  }};
  c[Symbol.iterator] = function() {
    return c;
  };
  return c;
};
$jscomp.polyfill("Array.prototype.values", function(n) {
  return n ? n : function() {
    return $jscomp.iteratorFromArray(this, function(a, h) {
      return h;
    });
  };
}, "es8", "es3");
$jscomp.polyfill("Array.prototype.keys", function(n) {
  return n ? n : function() {
    return $jscomp.iteratorFromArray(this, function(a) {
      return a;
    });
  };
}, "es6", "es3");
(function(n) {
  function a() {
    this.size = [60, 30];
    this.addInput("event", p.ACTION);
  }
  function h() {
    this.size = [60, 30];
    this.addInput("in", "");
    this.addOutput("true", p.EVENT);
    this.addOutput("change", p.EVENT);
    this.was_true = !1;
  }
  function c() {
    this.addInput("", p.ACTION);
    this.addInput("", p.ACTION);
    this.addInput("", p.ACTION);
    this.addInput("", p.ACTION);
    this.addInput("", p.ACTION);
    this.addInput("", p.ACTION);
    this.addOutput("", p.EVENT);
    this.addOutput("", p.EVENT);
    this.addOutput("", p.EVENT);
    this.addOutput("", p.EVENT);
    this.addOutput("", p.EVENT);
    this.addOutput("", p.EVENT);
    this.size = [120, 30];
    this.flags = {horizontal:!0, render_box:!1};
  }
  function b() {
    this.size = [60, 30];
    this.addInput("event", p.ACTION);
    this.addOutput("event", p.EVENT);
    this.properties = {equal_to:"", has_property:"", property_equal_to:""};
  }
  function l() {
    this.addInput("inc", p.ACTION);
    this.addInput("dec", p.ACTION);
    this.addInput("reset", p.ACTION);
    this.addOutput("change", p.EVENT);
    this.addOutput("num", "number");
    this.num = 0;
  }
  function g() {
    this.size = [60, 30];
    this.addProperty("time_in_ms", 1000);
    this.addInput("event", p.ACTION);
    this.addOutput("on_time", p.EVENT);
    this._pending = [];
  }
  function x() {
    this.addProperty("interval", 1000);
    this.addProperty("event", "tick");
    this.addOutput("on_tick", p.EVENT);
    this.time = 0;
    this.last_interval = 1000;
    this.triggered = !1;
  }
  function v() {
    this.addInput("data", "");
    this.addInput("assign", p.ACTION);
    this.addOutput("data", "");
    this._last_value = null;
    this.properties = {data:null, serialize:!0};
    var a = this;
    this.addWidget("button", "store", "", function() {
      a.properties.data = a._last_value;
    });
  }
  var p = n.LiteGraph;
  a.title = "Log Event";
  a.desc = "Log event in console";
  a.prototype.onAction = function(a, b) {
    console.log(a, b);
  };
  p.registerNodeType("events/log", a);
  h.title = "TriggerEvent";
  h.desc = "Triggers event if value is true";
  h.prototype.onExecute = function(a, b) {
    (a = this.getInputData(0)) && this.triggerSlot(0, b);
    a && !this.was_true && this.triggerSlot(1, b);
    this.was_true = a;
  };
  p.registerNodeType("events/trigger", h);
  c.title = "Sequencer";
  c.desc = "Trigger events when an event arrives";
  c.prototype.getTitle = function() {
    return "";
  };
  c.prototype.onAction = function(a, b) {
    if (this.outputs) {
      for (a = 0; a < this.outputs.length; ++a) {
        this.triggerSlot(a, b);
      }
    }
  };
  p.registerNodeType("events/sequencer", c);
  b.title = "Filter Event";
  b.desc = "Blocks events that do not match the filter";
  b.prototype.onAction = function(a, b) {
    if (null != b && (!this.properties.equal_to || this.properties.equal_to == b)) {
      if (this.properties.has_property && (a = b[this.properties.has_property], null == a || this.properties.property_equal_to && this.properties.property_equal_to != a)) {
        return;
      }
      this.triggerSlot(0, b);
    }
  };
  p.registerNodeType("events/filter", b);
  l.title = "Counter";
  l.desc = "Counts events";
  l.prototype.getTitle = function() {
    return this.flags.collapsed ? String(this.num) : this.title;
  };
  l.prototype.onAction = function(a, b) {
    b = this.num;
    "inc" == a ? this.num += 1 : "dec" == a ? --this.num : "reset" == a && (this.num = 0);
    this.num != b && this.trigger("change", this.num);
  };
  l.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || (a.fillStyle = "#AAA", a.font = "20px Arial", a.textAlign = "center", a.fillText(this.num, 0.5 * this.size[0], 0.5 * this.size[1]));
  };
  l.prototype.onExecute = function() {
    this.setOutputData(1, this.num);
  };
  p.registerNodeType("events/counter", l);
  g.title = "Delay";
  g.desc = "Delays one event";
  g.prototype.onAction = function(a, b) {
    a = this.properties.time_in_ms;
    0 >= a ? this.trigger(null, b) : this._pending.push([a, b]);
  };
  g.prototype.onExecute = function() {
    var a = 1000 * this.graph.elapsed_time;
    this.isInputConnected(1) && (this.properties.time_in_ms = this.getInputData(1));
    for (var b = 0; b < this._pending.length; ++b) {
      var u = this._pending[b];
      u[0] -= a;
      0 < u[0] || (this._pending.splice(b, 1), --b, this.trigger(null, u[1]));
    }
  };
  g.prototype.onGetInputs = function() {
    return [["event", p.ACTION], ["time_in_ms", "number"]];
  };
  p.registerNodeType("events/delay", g);
  x.title = "Timer";
  x.desc = "Sends an event every N milliseconds";
  x.prototype.onStart = function() {
    this.time = 0;
  };
  x.prototype.getTitle = function() {
    return "Timer: " + this.last_interval.toString() + "ms";
  };
  x.on_color = "#AAA";
  x.off_color = "#222";
  x.prototype.onDrawBackground = function() {
    this.boxcolor = this.triggered ? x.on_color : x.off_color;
    this.triggered = !1;
  };
  x.prototype.onExecute = function() {
    var a = 0 == this.time;
    this.time += 1000 * this.graph.elapsed_time;
    this.last_interval = Math.max(1, this.getInputOrProperty("interval") | 0);
    !a && (this.time < this.last_interval || isNaN(this.last_interval)) ? this.inputs && 1 < this.inputs.length && this.inputs[1] && this.setOutputData(1, !1) : (this.triggered = !0, this.time %= this.last_interval, this.trigger("on_tick", this.properties.event), this.inputs && 1 < this.inputs.length && this.inputs[1] && this.setOutputData(1, !0));
  };
  x.prototype.onGetInputs = function() {
    return [["interval", "number"]];
  };
  x.prototype.onGetOutputs = function() {
    return [["tick", "boolean"]];
  };
  p.registerNodeType("events/timer", x);
  v.title = "Data Store";
  v.desc = "Stores data and only changes when event is received";
  v.prototype.onExecute = function() {
    this._last_value = this.getInputData(0);
    this.setOutputData(0, this.properties.data);
  };
  v.prototype.onAction = function(a, b) {
    this.properties.data = this._last_value;
  };
  v.prototype.onSerialize = function(a) {
    null != a.data && (0 == this.properties.serialize || a.data.constructor !== String && a.data.constructor !== Number && a.data.constructor !== Boolean && a.data.constructor !== Array && a.data.constructor !== Object) && (a.data = null);
  };
  p.registerNodeType("basic/data_store", v);
})(this);
(function(n) {
  function a() {
    this.addOutput("", w.EVENT);
    this.addOutput("", "boolean");
    this.addProperty("text", "click me");
    this.addProperty("font_size", 30);
    this.addProperty("message", "");
    this.size = [164, 84];
    this.clicked = !1;
  }
  function h() {
    this.addInput("", "boolean");
    this.addInput("e", w.ACTION);
    this.addOutput("v", "boolean");
    this.addOutput("e", w.EVENT);
    this.properties = {font:"", value:!1};
    this.size = [160, 44];
  }
  function c() {
    this.addOutput("", "number");
    this.size = [80, 60];
    this.properties = {min:-1000, max:1000, value:1, step:1};
    this.old_y = -1;
    this._precision = this._remainder = 0;
    this.mouse_captured = !1;
  }
  function b() {
    this.addOutput("", "string");
    this.addOutput("change", w.EVENT);
    this.size = [80, 60];
    this.properties = {value:"A", values:"A;B;C"};
    this.old_y = -1;
    this.mouse_captured = !1;
    this._values = this.properties.values.split(";");
    var a = this;
    this.widgets_up = !0;
    this.widget = this.addWidget("combo", "", this.properties.value, function(b) {
      a.properties.value = b;
      a.triggerSlot(1, b);
    }, {property:"value", values:this._values});
  }
  function l() {
    this.addOutput("", "number");
    this.size = [64, 84];
    this.properties = {min:0, max:1, value:0.5, color:"#7AF", precision:2};
    this.value = -1;
  }
  function g() {
    this.addOutput("", "number");
    this.properties = {value:0.5, min:0, max:1, text:"V"};
    var a = this;
    this.size = [140, 40];
    this.slider = this.addWidget("slider", "V", this.properties.value, function(b) {
      a.properties.value = b;
    }, this.properties);
    this.widgets_up = !0;
  }
  function x() {
    this.size = [160, 26];
    this.addOutput("", "number");
    this.properties = {color:"#7AF", min:0, max:1, value:0.5};
    this.value = -1;
  }
  function v() {
    this.size = [160, 26];
    this.addInput("", "number");
    this.properties = {min:0, max:1, value:0, color:"#AAF"};
  }
  function p() {
    this.addInputs("", 0);
    this.properties = {value:"...", font:"Arial", fontsize:18, color:"#AAA", align:"left", glowSize:0, decimals:1};
  }
  function C() {
    this.size = [200, 100];
    this.properties = {borderColor:"#ffffff", bgcolorTop:"#f0f0f0", bgcolorBottom:"#e0e0e0", shadowSize:2, borderRadius:3};
  }
  var w = n.LiteGraph;
  a.title = "Button";
  a.desc = "Triggers an event";
  a.font = "Arial";
  a.prototype.onDrawForeground = function(b) {
    if (!this.flags.collapsed && (b.fillStyle = "black", b.fillRect(11, 11, this.size[0] - 20, this.size[1] - 20), b.fillStyle = "#AAF", b.fillRect(9, 9, this.size[0] - 20, this.size[1] - 20), b.fillStyle = this.clicked ? "white" : this.mouseOver ? "#668" : "#334", b.fillRect(10, 10, this.size[0] - 20, this.size[1] - 20), this.properties.text || 0 === this.properties.text)) {
      var u = this.properties.font_size || 30;
      b.textAlign = "center";
      b.fillStyle = this.clicked ? "black" : "white";
      b.font = u + "px " + a.font;
      b.fillText(this.properties.text, 0.5 * this.size[0], 0.5 * this.size[1] + 0.3 * u);
      b.textAlign = "left";
    }
  };
  a.prototype.onMouseDown = function(a, b) {
    if (1 < b[0] && 1 < b[1] && b[0] < this.size[0] - 2 && b[1] < this.size[1] - 2) {
      return this.clicked = !0, this.triggerSlot(0, this.properties.message), !0;
    }
  };
  a.prototype.onExecute = function() {
    this.setOutputData(1, this.clicked);
  };
  a.prototype.onMouseUp = function(a) {
    this.clicked = !1;
  };
  w.registerNodeType("widget/button", a);
  h.title = "Toggle";
  h.desc = "Toggles between true or false";
  h.prototype.onDrawForeground = function(a) {
    if (!this.flags.collapsed) {
      var b = 0.5 * this.size[1], u = 0.8 * this.size[1];
      a.font = this.properties.font || (0.8 * b).toFixed(0) + "px Arial";
      var c = a.measureText(this.title).width;
      c = 0.5 * (this.size[0] - (c + b));
      a.fillStyle = "#AAA";
      a.fillRect(c, u - b, b, b);
      a.fillStyle = this.properties.value ? "#AEF" : "#000";
      a.fillRect(c + 0.25 * b, u - b + 0.25 * b, .5 * b, .5 * b);
      a.textAlign = "left";
      a.fillStyle = "#AAA";
      a.fillText(this.title, 1.2 * b + c, 0.85 * u);
      a.textAlign = "left";
    }
  };
  h.prototype.onAction = function(a) {
    this.properties.value = !this.properties.value;
    this.trigger("e", this.properties.value);
  };
  h.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.properties.value = a);
    this.setOutputData(0, this.properties.value);
  };
  h.prototype.onMouseDown = function(a, b) {
    if (1 < b[0] && 1 < b[1] && b[0] < this.size[0] - 2 && b[1] < this.size[1] - 2) {
      return this.properties.value = !this.properties.value, this.graph._version++, this.trigger("e", this.properties.value), !0;
    }
  };
  w.registerNodeType("widget/toggle", h);
  c.title = "Number";
  c.desc = "Widget to select number value";
  c.pixels_threshold = 10;
  c.markers_color = "#666";
  c.prototype.onDrawForeground = function(a) {
    var b = 0.5 * this.size[0], u = this.size[1];
    30 < u ? (a.fillStyle = c.markers_color, a.beginPath(), a.moveTo(b, 0.1 * u), a.lineTo(b + 0.1 * u, 0.2 * u), a.lineTo(b + -0.1 * u, 0.2 * u), a.fill(), a.beginPath(), a.moveTo(b, 0.9 * u), a.lineTo(b + 0.1 * u, 0.8 * u), a.lineTo(b + -0.1 * u, 0.8 * u), a.fill(), a.font = (0.7 * u).toFixed(1) + "px Arial") : a.font = (0.8 * u).toFixed(1) + "px Arial";
    a.textAlign = "center";
    a.font = (0.7 * u).toFixed(1) + "px Arial";
    a.fillStyle = "#EEE";
    a.fillText(this.properties.value.toFixed(this._precision), b, 0.75 * u);
  };
  c.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  c.prototype.onPropertyChanged = function(a, b) {
    a = (this.properties.step + "").split(".");
    this._precision = 1 < a.length ? a[1].length : 0;
  };
  c.prototype.onMouseDown = function(a, b) {
    if (!(0 > b[1])) {
      return this.old_y = a.canvasY, this.captureInput(!0), this.mouse_captured = !0;
    }
  };
  c.prototype.onMouseMove = function(a) {
    if (this.mouse_captured) {
      var b = this.old_y - a.canvasY;
      a.shiftKey && (b *= 10);
      if (a.metaKey || a.altKey) {
        b *= 0.1;
      }
      this.old_y = a.canvasY;
      a = this._remainder + b / c.pixels_threshold;
      this._remainder = a % 1;
      a = Math.clamp(this.properties.value + (a | 0) * this.properties.step, this.properties.min, this.properties.max);
      this.properties.value = a;
      this.graph._version++;
      this.setDirtyCanvas(!0);
    }
  };
  c.prototype.onMouseUp = function(a, b) {
    200 > a.click_time && (this.properties.value = Math.clamp(this.properties.value + (b[1] > 0.5 * this.size[1] ? -1 : 1) * this.properties.step, this.properties.min, this.properties.max), this.graph._version++, this.setDirtyCanvas(!0));
    this.mouse_captured && (this.mouse_captured = !1, this.captureInput(!1));
  };
  w.registerNodeType("widget/number", c);
  b.title = "Combo";
  b.desc = "Widget to select from a list";
  b.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  b.prototype.onPropertyChanged = function(a, b) {
    "values" == a ? (this._values = b.split(";"), this.widget.options.values = this._values) : "value" == a && (this.widget.value = b);
  };
  w.registerNodeType("widget/combo", b);
  l.title = "Knob";
  l.desc = "Circular controller";
  l.size = [80, 100];
  l.prototype.onDrawForeground = function(a) {
    if (!this.flags.collapsed) {
      -1 == this.value && (this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min));
      var b = 0.5 * this.size[0], c = 0.5 * this.size[1], g = 0.5 * Math.min(this.size[0], this.size[1]) - 5;
      a.globalAlpha = 1;
      a.save();
      a.translate(b, c);
      a.rotate(0.75 * Math.PI);
      a.fillStyle = "rgba(0,0,0,0.5)";
      a.beginPath();
      a.moveTo(0, 0);
      a.arc(0, 0, g, 0, 1.5 * Math.PI);
      a.fill();
      a.strokeStyle = "black";
      a.fillStyle = this.properties.color;
      a.lineWidth = 2;
      a.beginPath();
      a.moveTo(0, 0);
      a.arc(0, 0, g - 4, 0, 1.5 * Math.PI * Math.max(0.01, this.value));
      a.closePath();
      a.fill();
      a.lineWidth = 1;
      a.globalAlpha = 1;
      a.restore();
      a.fillStyle = "black";
      a.beginPath();
      a.arc(b, c, 0.75 * g, 0, 2 * Math.PI, !0);
      a.fill();
      a.fillStyle = this.mouseOver ? "white" : this.properties.color;
      a.beginPath();
      var d = this.value * Math.PI * 1.5 + 0.75 * Math.PI;
      a.arc(b + Math.cos(d) * g * 0.65, c + Math.sin(d) * g * 0.65, 0.05 * g, 0, 2 * Math.PI, !0);
      a.fill();
      a.fillStyle = this.mouseOver ? "white" : "#AAA";
      a.font = Math.floor(0.5 * g) + "px Arial";
      a.textAlign = "center";
      a.fillText(this.properties.value.toFixed(this.properties.precision), b, c + 0.15 * g);
    }
  };
  l.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
    this.boxcolor = w.colorToString([this.value, this.value, this.value]);
  };
  l.prototype.onMouseDown = function(a) {
    this.center = [0.5 * this.size[0], 0.5 * this.size[1] + 20];
    this.radius = 0.5 * this.size[0];
    if (20 > a.canvasY - this.pos[1] || w.distance([a.canvasX, a.canvasY], [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]) > this.radius) {
      return !1;
    }
    this.oldmouse = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
    this.captureInput(!0);
    return !0;
  };
  l.prototype.onMouseMove = function(a) {
    if (this.oldmouse) {
      a = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
      var b = this.value;
      b -= 0.01 * (a[1] - this.oldmouse[1]);
      1.0 < b ? b = 1.0 : 0.0 > b && (b = 0.0);
      this.value = b;
      this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
      this.oldmouse = a;
      this.setDirtyCanvas(!0);
    }
  };
  l.prototype.onMouseUp = function(a) {
    this.oldmouse && (this.oldmouse = null, this.captureInput(!1));
  };
  l.prototype.onPropertyChanged = function(a, b) {
    if ("min" == a || "max" == a || "value" == a) {
      return this.properties[a] = parseFloat(b), !0;
    }
  };
  w.registerNodeType("widget/knob", l);
  g.title = "Inner Slider";
  g.prototype.onPropertyChanged = function(a, b) {
    "value" == a && (this.slider.value = b);
  };
  g.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  w.registerNodeType("widget/internal_slider", g);
  x.title = "H.Slider";
  x.desc = "Linear slider controller";
  x.prototype.onDrawForeground = function(a) {
    -1 == this.value && (this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min));
    a.globalAlpha = 1;
    a.lineWidth = 1;
    a.fillStyle = "#000";
    a.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4);
    a.fillStyle = this.properties.color;
    a.beginPath();
    a.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8);
    a.fill();
  };
  x.prototype.onExecute = function() {
    this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
    this.setOutputData(0, this.properties.value);
    this.boxcolor = w.colorToString([this.value, this.value, this.value]);
  };
  x.prototype.onMouseDown = function(a) {
    if (0 > a.canvasY - this.pos[1]) {
      return !1;
    }
    this.oldmouse = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
    this.captureInput(!0);
    return !0;
  };
  x.prototype.onMouseMove = function(a) {
    if (this.oldmouse) {
      a = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
      var b = this.value;
      b += (a[0] - this.oldmouse[0]) / this.size[0];
      1.0 < b ? b = 1.0 : 0.0 > b && (b = 0.0);
      this.value = b;
      this.oldmouse = a;
      this.setDirtyCanvas(!0);
    }
  };
  x.prototype.onMouseUp = function(a) {
    this.oldmouse = null;
    this.captureInput(!1);
  };
  x.prototype.onMouseLeave = function(a) {
  };
  w.registerNodeType("widget/hslider", x);
  v.title = "Progress";
  v.desc = "Shows data in linear progress";
  v.prototype.onExecute = function() {
    var a = this.getInputData(0);
    void 0 != a && (this.properties.value = a);
  };
  v.prototype.onDrawForeground = function(a) {
    a.lineWidth = 1;
    a.fillStyle = this.properties.color;
    var b = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    b = Math.min(1, b);
    b = Math.max(0, b);
    a.fillRect(2, 2, (this.size[0] - 4) * b, this.size[1] - 4);
  };
  w.registerNodeType("widget/progress", v);
  p.title = "Text";
  p.desc = "Shows the input value";
  p.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"led_text", text:"LED", type:"minibutton"}, {name:"normal_text", text:"Normal", type:"minibutton"}];
  p.prototype.onDrawForeground = function(a) {
    a.fillStyle = this.properties.color;
    var b = this.properties.value;
    this.properties.glowSize ? (a.shadowColor = this.properties.color, a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = this.properties.glowSize) : a.shadowColor = "transparent";
    var c = this.properties.fontsize;
    a.textAlign = this.properties.align;
    a.font = c.toString() + "px " + this.properties.font;
    this.str = "number" == typeof b ? b.toFixed(this.properties.decimals) : b;
    if ("string" == typeof this.str) {
      b = this.str.split("\\n");
      for (var g in b) {
        a.fillText(b[g], "left" == this.properties.align ? 15 : this.size[0] - 15, -0.15 * c + c * (parseInt(g) + 1));
      }
    }
    a.shadowColor = "transparent";
    this.last_ctx = a;
    a.textAlign = "left";
  };
  p.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.properties.value = a);
  };
  p.prototype.resize = function() {
    if (this.last_ctx) {
      var a = this.str.split("\\n");
      this.last_ctx.font = this.properties.fontsize + "px " + this.properties.font;
      var b = 0, c;
      for (c in a) {
        var g = this.last_ctx.measureText(a[c]).width;
        b < g && (b = g);
      }
      this.size[0] = b + 20;
      this.size[1] = 4 + a.length * this.properties.fontsize;
      this.setDirtyCanvas(!0);
    }
  };
  p.prototype.onPropertyChanged = function(a, b) {
    this.properties[a] = b;
    this.str = "number" == typeof b ? b.toFixed(3) : b;
    return !0;
  };
  w.registerNodeType("widget/text", p);
  C.title = "Panel";
  C.desc = "Non interactive panel";
  C.widgets = [{name:"update", text:"Update", type:"button"}];
  C.prototype.createGradient = function(a) {
    "" == this.properties.bgcolorTop || "" == this.properties.bgcolorBottom ? this.lineargradient = 0 : (this.lineargradient = a.createLinearGradient(0, 0, 0, this.size[1]), this.lineargradient.addColorStop(0, this.properties.bgcolorTop), this.lineargradient.addColorStop(1, this.properties.bgcolorBottom));
  };
  C.prototype.onDrawForeground = function(a) {
    this.flags.collapsed || (null == this.lineargradient && this.createGradient(a), this.lineargradient && (a.lineWidth = 1, a.strokeStyle = this.properties.borderColor, a.fillStyle = this.lineargradient, this.properties.shadowSize ? (a.shadowColor = "#000", a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = this.properties.shadowSize) : a.shadowColor = "transparent", a.roundRect(0, 0, this.size[0] - 1, this.size[1] - 1, this.properties.shadowSize), a.fill(), a.shadowColor = "transparent", 
    a.stroke()));
  };
  w.registerNodeType("widget/panel", C);
})(this);
(function(n) {
  function a() {
    this.addOutput("left_x_axis", "number");
    this.addOutput("left_y_axis", "number");
    this.addOutput("button_pressed", h.EVENT);
    this.properties = {gamepad_index:0, threshold:0.1};
    this._left_axis = new Float32Array(2);
    this._right_axis = new Float32Array(2);
    this._triggers = new Float32Array(2);
    this._previous_buttons = new Uint8Array(17);
    this._current_buttons = new Uint8Array(17);
  }
  var h = n.LiteGraph;
  a.title = "Gamepad";
  a.desc = "gets the input of the gamepad";
  a.CENTER = 0;
  a.LEFT = 1;
  a.RIGHT = 2;
  a.UP = 4;
  a.DOWN = 8;
  a.zero = new Float32Array(2);
  a.buttons = "a b x y lb rb lt rt back start ls rs home".split(" ");
  a.prototype.onExecute = function() {
    var c = this.getGamepad(), b = this.properties.threshold || 0.0;
    c && (this._left_axis[0] = Math.abs(c.xbox.axes.lx) > b ? c.xbox.axes.lx : 0, this._left_axis[1] = Math.abs(c.xbox.axes.ly) > b ? c.xbox.axes.ly : 0, this._right_axis[0] = Math.abs(c.xbox.axes.rx) > b ? c.xbox.axes.rx : 0, this._right_axis[1] = Math.abs(c.xbox.axes.ry) > b ? c.xbox.axes.ry : 0, this._triggers[0] = Math.abs(c.xbox.axes.ltrigger) > b ? c.xbox.axes.ltrigger : 0, this._triggers[1] = Math.abs(c.xbox.axes.rtrigger) > b ? c.xbox.axes.rtrigger : 0);
    if (this.outputs) {
      for (b = 0; b < this.outputs.length; b++) {
        var l = this.outputs[b];
        if (l.links && l.links.length) {
          var g = null;
          if (c) {
            switch(l.name) {
              case "left_axis":
                g = this._left_axis;
                break;
              case "right_axis":
                g = this._right_axis;
                break;
              case "left_x_axis":
                g = this._left_axis[0];
                break;
              case "left_y_axis":
                g = this._left_axis[1];
                break;
              case "right_x_axis":
                g = this._right_axis[0];
                break;
              case "right_y_axis":
                g = this._right_axis[1];
                break;
              case "trigger_left":
                g = this._triggers[0];
                break;
              case "trigger_right":
                g = this._triggers[1];
                break;
              case "a_button":
                g = c.xbox.buttons.a ? 1 : 0;
                break;
              case "b_button":
                g = c.xbox.buttons.b ? 1 : 0;
                break;
              case "x_button":
                g = c.xbox.buttons.x ? 1 : 0;
                break;
              case "y_button":
                g = c.xbox.buttons.y ? 1 : 0;
                break;
              case "lb_button":
                g = c.xbox.buttons.lb ? 1 : 0;
                break;
              case "rb_button":
                g = c.xbox.buttons.rb ? 1 : 0;
                break;
              case "ls_button":
                g = c.xbox.buttons.ls ? 1 : 0;
                break;
              case "rs_button":
                g = c.xbox.buttons.rs ? 1 : 0;
                break;
              case "hat_left":
                g = c.xbox.hatmap & a.LEFT;
                break;
              case "hat_right":
                g = c.xbox.hatmap & a.RIGHT;
                break;
              case "hat_up":
                g = c.xbox.hatmap & a.UP;
                break;
              case "hat_down":
                g = c.xbox.hatmap & a.DOWN;
                break;
              case "hat":
                g = c.xbox.hatmap;
                break;
              case "start_button":
                g = c.xbox.buttons.start ? 1 : 0;
                break;
              case "back_button":
                g = c.xbox.buttons.back ? 1 : 0;
                break;
              case "button_pressed":
                for (l = 0; l < this._current_buttons.length; ++l) {
                  this._current_buttons[l] && !this._previous_buttons[l] && this.triggerSlot(b, a.buttons[l]);
                }
            }
          } else {
            switch(l.name) {
              case "button_pressed":
                break;
              case "left_axis":
              case "right_axis":
                g = a.zero;
                break;
              default:
                g = 0;
            }
          }
          this.setOutputData(b, g);
        }
      }
    }
  };
  a.mapping = {a:0, b:1, x:2, y:3, lb:4, rb:5, lt:6, rt:7, back:8, start:9, ls:10, rs:11};
  a.mapping_array = "a b x y lb rb lt rt back start ls rs".split(" ");
  a.prototype.getGamepad = function() {
    var c = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
    if (!c) {
      return null;
    }
    c = c.call(navigator);
    this._previous_buttons.set(this._current_buttons);
    for (var b = this.properties.gamepad_index; 4 > b; b++) {
      if (c[b]) {
        c = c[b];
        b = this.xbox_mapping;
        b || (b = this.xbox_mapping = {axes:[], buttons:{}, hat:"", hatmap:a.CENTER});
        b.axes.lx = c.axes[0];
        b.axes.ly = c.axes[1];
        b.axes.rx = c.axes[2];
        b.axes.ry = c.axes[3];
        b.axes.ltrigger = c.buttons[6].value;
        b.axes.rtrigger = c.buttons[7].value;
        b.hat = "";
        b.hatmap = a.CENTER;
        for (var l = 0; l < c.buttons.length; l++) {
          if (this._current_buttons[l] = c.buttons[l].pressed, 12 > l) {
            b.buttons[a.mapping_array[l]] = c.buttons[l].pressed, c.buttons[l].was_pressed && this.trigger(a.mapping_array[l] + "_button_event");
          } else {
            switch(l) {
              case 12:
                c.buttons[l].pressed && (b.hat += "up", b.hatmap |= a.UP);
                break;
              case 13:
                c.buttons[l].pressed && (b.hat += "down", b.hatmap |= a.DOWN);
                break;
              case 14:
                c.buttons[l].pressed && (b.hat += "left", b.hatmap |= a.LEFT);
                break;
              case 15:
                c.buttons[l].pressed && (b.hat += "right", b.hatmap |= a.RIGHT);
                break;
              case 16:
                b.buttons.home = c.buttons[l].pressed;
            }
          }
        }
        c.xbox = b;
        return c;
      }
    }
  };
  a.prototype.onDrawBackground = function(a) {
    if (!this.flags.collapsed) {
      var b = this._left_axis, c = this._right_axis;
      a.strokeStyle = "#88A";
      a.strokeRect(0.5 * (b[0] + 1) * this.size[0] - 4, 0.5 * (b[1] + 1) * this.size[1] - 4, 8, 8);
      a.strokeStyle = "#8A8";
      a.strokeRect(0.5 * (c[0] + 1) * this.size[0] - 4, 0.5 * (c[1] + 1) * this.size[1] - 4, 8, 8);
      b = this.size[1] / this._current_buttons.length;
      a.fillStyle = "#AEB";
      for (c = 0; c < this._current_buttons.length; ++c) {
        this._current_buttons[c] && a.fillRect(0, b * c, 6, b);
      }
    }
  };
  a.prototype.onGetOutputs = function() {
    return [["left_axis", "vec2"], ["right_axis", "vec2"], ["left_x_axis", "number"], ["left_y_axis", "number"], ["right_x_axis", "number"], ["right_y_axis", "number"], ["trigger_left", "number"], ["trigger_right", "number"], ["a_button", "number"], ["b_button", "number"], ["x_button", "number"], ["y_button", "number"], ["lb_button", "number"], ["rb_button", "number"], ["ls_button", "number"], ["rs_button", "number"], ["start_button", "number"], ["back_button", "number"], ["a_button_event", h.EVENT], 
    ["b_button_event", h.EVENT], ["x_button_event", h.EVENT], ["y_button_event", h.EVENT], ["lb_button_event", h.EVENT], ["rb_button_event", h.EVENT], ["ls_button_event", h.EVENT], ["rs_button_event", h.EVENT], ["start_button_event", h.EVENT], ["back_button_event", h.EVENT], ["hat_left", "number"], ["hat_right", "number"], ["hat_up", "number"], ["hat_down", "number"], ["hat", "number"], ["button_pressed", h.EVENT]];
  };
  h.registerNodeType("input/gamepad", a);
})(this);
(function(n) {
  function a() {
    this.addInput("in", "*");
    this.size = [80, 30];
  }
  function h() {
    this.addInput("in");
    this.addOutput("out");
    this.size = [80, 30];
  }
  function c() {
    this.addInput("in");
    this.addOutput("out");
  }
  function b() {
    this.addInput("in", "number", {locked:!0});
    this.addOutput("out", "number", {locked:!0});
    this.addProperty("in", 0);
    this.addProperty("in_min", 0);
    this.addProperty("in_max", 1);
    this.addProperty("out_min", 0);
    this.addProperty("out_max", 1);
    this.size = [80, 30];
  }
  function l() {
    this.addOutput("value", "number");
    this.addProperty("min", 0);
    this.addProperty("max", 1);
    this.size = [80, 30];
  }
  function g() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.addProperty("min", 0);
    this.addProperty("max", 1);
    this.addProperty("smooth", !0);
    this.size = [90, 30];
  }
  function x() {
    this.addOutput("out", "number");
    this.addProperty("min_time", 1);
    this.addProperty("max_time", 2);
    this.addProperty("duration", 0.2);
    this.size = [90, 30];
    this._blink_time = this._remaining_time = 0;
  }
  function v() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
    this.addProperty("min", 0);
    this.addProperty("max", 1);
  }
  function p() {
    this.properties = {f:0.5};
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("out", "number");
  }
  function C() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
  }
  function w() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
  }
  function u() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
  }
  function y() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
    this.properties = {A:0, B:1};
  }
  function r() {
    this.addInput("in", "number", {label:""});
    this.addOutput("out", "number", {label:""});
    this.size = [80, 30];
    this.addProperty("factor", 1);
  }
  function z() {
    this.addInput("v", "boolean");
    this.addInput("A");
    this.addInput("B");
    this.addOutput("out");
  }
  function d() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
    this.addProperty("samples", 10);
    this._values = new Float32Array(10);
    this._current = 0;
  }
  function e() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.addProperty("factor", 0.1);
    this.size = [80, 30];
    this._value = null;
  }
  function m() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("=", "number");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", "+", "enum", {values:m.values});
  }
  function f() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("A==B", "boolean");
    this.addOutput("A!=B", "boolean");
    this.addProperty("A", 0);
    this.addProperty("B", 0);
  }
  function q() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("true", "boolean");
    this.addOutput("false", "boolean");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", ">", "enum", {values:q.values});
    this.size = [80, 60];
  }
  function B() {
    this.addInput("inc", "number");
    this.addOutput("total", "number");
    this.addProperty("increment", 1);
    this.addProperty("value", 0);
  }
  function F() {
    this.addInput("v", "number");
    this.addOutput("sin", "number");
    this.addProperty("amplitude", 1);
    this.addProperty("offset", 0);
    this.bgImageUrl = "nodes/imgs/icon-sin.png";
  }
  function G() {
    this.addInput("x", "number");
    this.addInput("y", "number");
    this.addOutput("", "number");
    this.properties = {x:1.0, y:1.0, formula:"x+y"};
    this.code_widget = this.addWidget("text", "F(x,y)", this.properties.formula, function(a, b, d) {
      d.properties.formula = a;
    });
    this.addWidget("toggle", "allow", t.allow_scripts, function(a) {
      t.allow_scripts = a;
    });
    this._func = null;
  }
  function P() {
    this.addInput("vec2", "vec2");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
  }
  function D() {
    this.addInputs([["x", "number"], ["y", "number"]]);
    this.addOutput("vec2", "vec2");
    this.properties = {x:0, y:0};
    this._data = new Float32Array(2);
  }
  function I() {
    this.addInput("vec3", "vec3");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
  }
  function J() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);
    this.addOutput("vec3", "vec3");
    this.properties = {x:0, y:0, z:0};
    this._data = new Float32Array(3);
  }
  function E() {
    this.addInput("vec4", "vec4");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
    this.addOutput("w", "number");
  }
  function K() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"], ["w", "number"]]);
    this.addOutput("vec4", "vec4");
    this.properties = {x:0, y:0, z:0, w:0};
    this._data = new Float32Array(4);
  }
  var t = n.LiteGraph;
  a.title = "Converter";
  a.desc = "type A to type B";
  a.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (null != a && this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        var d = this.outputs[b];
        if (d.links && d.links.length) {
          var k = null;
          switch(d.name) {
            case "number":
              k = a.length ? a[0] : parseFloat(a);
              break;
            case "vec2":
            case "vec3":
            case "vec4":
              k = 1;
              switch(d.name) {
                case "vec2":
                  k = 2;
                  break;
                case "vec3":
                  k = 3;
                  break;
                case "vec4":
                  k = 4;
              }k = new Float32Array(k);
              if (a.length) {
                for (d = 0; d < a.length && d < k.length; d++) {
                  k[d] = a[d];
                }
              } else {
                k[0] = parseFloat(a);
              }
          }
          this.setOutputData(b, k);
        }
      }
    }
  };
  a.prototype.onGetOutputs = function() {
    return [["number", "number"], ["vec2", "vec2"], ["vec3", "vec3"], ["vec4", "vec4"]];
  };
  t.registerNodeType("math/converter", a);
  h.title = "Bypass";
  h.desc = "removes the type";
  h.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, a);
  };
  t.registerNodeType("math/bypass", h);
  c.title = "to Number";
  c.desc = "Cast to number";
  c.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, Number(a));
  };
  t.registerNodeType("math/to_number", c);
  b.title = "Range";
  b.desc = "Convert a number from one range to another";
  b.prototype.getTitle = function() {
    return this.flags.collapsed ? (this._last_v || 0).toFixed(2) : this.title;
  };
  b.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], d = this.getInputData(a);
        void 0 !== d && (this.properties[b.name] = d);
      }
    }
    d = this.properties["in"];
    if (void 0 === d || null === d || d.constructor !== Number) {
      d = 0;
    }
    a = this.properties.in_min;
    b = this.properties.out_min;
    this._last_v = (d - a) / (this.properties.in_max - a) * (this.properties.out_max - b) + b;
    this.setOutputData(0, this._last_v);
  };
  b.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this._last_v ? this._last_v.toFixed(3) : "?";
  };
  b.prototype.onGetInputs = function() {
    return [["in_min", "number"], ["in_max", "number"], ["out_min", "number"], ["out_max", "number"]];
  };
  t.registerNodeType("math/range", b);
  l.title = "Rand";
  l.desc = "Random number";
  l.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], d = this.getInputData(a);
        void 0 !== d && (this.properties[b.name] = d);
      }
    }
    a = this.properties.min;
    this._last_v = Math.random() * (this.properties.max - a) + a;
    this.setOutputData(0, this._last_v);
  };
  l.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = (this._last_v || 0).toFixed(3);
  };
  l.prototype.onGetInputs = function() {
    return [["min", "number"], ["max", "number"]];
  };
  t.registerNodeType("math/rand", l);
  g.title = "Noise";
  g.desc = "Random number with temporal continuity";
  g.data = null;
  g.getValue = function(a, b) {
    if (!g.data) {
      g.data = new Float32Array(1024);
      for (var d = 0; d < g.data.length; ++d) {
        g.data[d] = Math.random();
      }
    }
    a %= 1024;
    0 > a && (a += 1024);
    var k = Math.floor(a);
    a -= k;
    d = g.data[k];
    k = g.data[1023 == k ? 0 : k + 1];
    b && (a = a * a * a * (a * (6.0 * a - 15.0) + 10.0));
    return d * (1 - a) + k * a;
  };
  g.prototype.onExecute = function() {
    var a = this.getInputData(0) || 0;
    a = g.getValue(a, this.properties.smooth);
    var b = this.properties.min;
    this._last_v = a * (this.properties.max - b) + b;
    this.setOutputData(0, this._last_v);
  };
  g.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = (this._last_v || 0).toFixed(3);
  };
  t.registerNodeType("math/noise", g);
  x.title = "Spikes";
  x.desc = "spike every random time";
  x.prototype.onExecute = function() {
    var a = this.graph.elapsed_time;
    this._remaining_time -= a;
    this._blink_time -= a;
    a = 0;
    0 < this._blink_time && (a = 1 / (Math.pow(this._blink_time / this.properties.duration * 8 - 4, 4) + 1));
    0 > this._remaining_time ? (this._remaining_time = Math.random() * (this.properties.max_time - this.properties.min_time) + this.properties.min_time, this._blink_time = this.properties.duration, this.boxcolor = "#FFF") : this.boxcolor = "#000";
    this.setOutputData(0, a);
  };
  t.registerNodeType("math/spikes", x);
  v.title = "Clamp";
  v.desc = "Clamp number between min and max";
  v.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (a = Math.max(this.properties.min, a), a = Math.min(this.properties.max, a), this.setOutputData(0, a));
  };
  v.prototype.getCode = function(a) {
    a = "";
    this.isInputConnected(0) && (a += "clamp({{0}}," + this.properties.min + "," + this.properties.max + ")");
    return a;
  };
  t.registerNodeType("math/clamp", v);
  p.title = "Lerp";
  p.desc = "Linear Interpolation";
  p.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.getInputData(1);
    null == b && (b = 0);
    var d = this.properties.f, k = this.getInputData(2);
    void 0 !== k && (d = k);
    this.setOutputData(0, a * (1 - d) + b * d);
  };
  p.prototype.onGetInputs = function() {
    return [["f", "number"]];
  };
  t.registerNodeType("math/lerp", p);
  C.title = "Abs";
  C.desc = "Absolute";
  C.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.abs(a));
  };
  t.registerNodeType("math/abs", C);
  w.title = "Floor";
  w.desc = "Floor number to remove fractional part";
  w.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.floor(a));
  };
  t.registerNodeType("math/floor", w);
  u.title = "Frac";
  u.desc = "Returns fractional part";
  u.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a % 1);
  };
  t.registerNodeType("math/frac", u);
  y.title = "Smoothstep";
  y.desc = "Smoothstep";
  y.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (void 0 !== a) {
      var b = this.properties.A;
      a = Math.clamp((a - b) / (this.properties.B - b), 0.0, 1.0);
      this.setOutputData(0, a * a * (3 - 2 * a));
    }
  };
  t.registerNodeType("math/smoothstep", y);
  r.title = "Scale";
  r.desc = "v * factor";
  r.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a * this.properties.factor);
  };
  t.registerNodeType("math/scale", r);
  z.title = "Gate";
  z.desc = "if v is true, then outputs A, otherwise B";
  z.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, this.getInputData(a ? 1 : 2));
  };
  t.registerNodeType("math/gate", z);
  d.title = "Average";
  d.desc = "Average Filter";
  d.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this._values.length;
    this._values[this._current % b] = a;
    this._current += 1;
    this._current > b && (this._current = 0);
    for (var d = a = 0; d < b; ++d) {
      a += this._values[d];
    }
    this.setOutputData(0, a / b);
  };
  d.prototype.onPropertyChanged = function(a, b) {
    1 > b && (b = 1);
    this.properties.samples = Math.round(b);
    a = this._values;
    this._values = new Float32Array(this.properties.samples);
    a.length <= this._values.length ? this._values.set(a) : this._values.set(a.subarray(0, this._values.length));
  };
  t.registerNodeType("math/average", d);
  e.title = "TendTo";
  e.desc = "moves the output value always closer to the input";
  e.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.factor;
    this._value = null == this._value ? a : this._value * (1 - b) + a * b;
    this.setOutputData(0, this._value);
  };
  t.registerNodeType("math/tendTo", e);
  m.values = "+ - * / % ^ max min".split(" ");
  m.title = "Operation";
  m.desc = "Easy math operators";
  m["@OP"] = {type:"enum", title:"operation", values:m.values};
  m.size = [100, 60];
  m.prototype.getTitle = function() {
    return "max" == this.properties.OP || "min" == this.properties.OP ? this.properties.OP + "(A,B)" : "A " + this.properties.OP + " B";
  };
  m.prototype.setValue = function(a) {
    "string" == typeof a && (a = parseFloat(a));
    this.properties.value = a;
  };
  m.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    null != a ? this.properties.A = a : a = this.properties.A;
    null != b ? this.properties.B = b : b = this.properties.B;
    var d = 0;
    switch(this.properties.OP) {
      case "+":
        d = a + b;
        break;
      case "-":
        d = a - b;
        break;
      case "x":
      case "X":
      case "*":
        d = a * b;
        break;
      case "/":
        d = a / b;
        break;
      case "%":
        d = a % b;
        break;
      case "^":
        d = Math.pow(a, b);
        break;
      case "max":
        d = Math.max(a, b);
        break;
      case "min":
        d = Math.min(a, b);
        break;
      default:
        console.warn("Unknown operation: " + this.properties.OP);
    }
    this.setOutputData(0, d);
  };
  m.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || (a.font = "40px Arial", a.fillStyle = "#666", a.textAlign = "center", a.fillText(this.properties.OP, 0.5 * this.size[0], 0.5 * (this.size[1] + t.NODE_TITLE_HEIGHT)), a.textAlign = "left");
  };
  t.registerNodeType("math/operation", m);
  t.registerSearchboxExtra("math/operation", "MAX", {properties:{OP:"max"}, title:"MAX()"});
  t.registerSearchboxExtra("math/operation", "MIN", {properties:{OP:"min"}, title:"MIN()"});
  f.title = "Compare";
  f.desc = "compares between two values";
  f.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    void 0 !== a ? this.properties.A = a : a = this.properties.A;
    void 0 !== b ? this.properties.B = b : b = this.properties.B;
    for (var d = 0, k = this.outputs.length; d < k; ++d) {
      var O = this.outputs[d];
      if (O.links && O.links.length) {
        switch(O.name) {
          case "A==B":
            var f = a == b;
            break;
          case "A!=B":
            f = a != b;
            break;
          case "A>B":
            f = a > b;
            break;
          case "A<B":
            f = a < b;
            break;
          case "A<=B":
            f = a <= b;
            break;
          case "A>=B":
            f = a >= b;
        }
        this.setOutputData(d, f);
      }
    }
  };
  f.prototype.onGetOutputs = function() {
    return [["A==B", "boolean"], ["A!=B", "boolean"], ["A>B", "boolean"], ["A<B", "boolean"], ["A>=B", "boolean"], ["A<=B", "boolean"]];
  };
  t.registerNodeType("math/compare", f);
  t.registerSearchboxExtra("math/compare", "==", {outputs:[["A==B", "boolean"]], title:"A==B"});
  t.registerSearchboxExtra("math/compare", "!=", {outputs:[["A!=B", "boolean"]], title:"A!=B"});
  t.registerSearchboxExtra("math/compare", ">", {outputs:[["A>B", "boolean"]], title:"A>B"});
  t.registerSearchboxExtra("math/compare", "<", {outputs:[["A<B", "boolean"]], title:"A<B"});
  t.registerSearchboxExtra("math/compare", ">=", {outputs:[["A>=B", "boolean"]], title:"A>=B"});
  t.registerSearchboxExtra("math/compare", "<=", {outputs:[["A<=B", "boolean"]], title:"A<=B"});
  q.values = "> < == != <= >= || &&".split(" ");
  q["@OP"] = {type:"enum", title:"operation", values:q.values};
  q.title = "Condition";
  q.desc = "evaluates condition between A and B";
  q.prototype.getTitle = function() {
    return "A " + this.properties.OP + " B";
  };
  q.prototype.onExecute = function() {
    var a = this.getInputData(0);
    void 0 === a ? a = this.properties.A : this.properties.A = a;
    var b = this.getInputData(1);
    void 0 === b ? b = this.properties.B : this.properties.B = b;
    var d = !0;
    switch(this.properties.OP) {
      case ">":
        d = a > b;
        break;
      case "<":
        d = a < b;
        break;
      case "==":
        d = a == b;
        break;
      case "!=":
        d = a != b;
        break;
      case "<=":
        d = a <= b;
        break;
      case ">=":
        d = a >= b;
        break;
      case "||":
        d = a || b;
        break;
      case "&&":
        d = a && b;
    }
    this.setOutputData(0, d);
    this.setOutputData(1, !d);
  };
  t.registerNodeType("math/condition", q);
  B.title = "Accumulate";
  B.desc = "Increments a value every time";
  B.prototype.onExecute = function() {
    null === this.properties.value && (this.properties.value = 0);
    var a = this.getInputData(0);
    this.properties.value = null !== a ? this.properties.value + a : this.properties.value + this.properties.increment;
    this.setOutputData(0, this.properties.value);
  };
  t.registerNodeType("math/accumulate", B);
  F.title = "Trigonometry";
  F.desc = "Sin Cos Tan";
  F.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.amplitude, d = this.findInputSlot("amplitude");
    -1 != d && (b = this.getInputData(d));
    var k = this.properties.offset;
    d = this.findInputSlot("offset");
    -1 != d && (k = this.getInputData(d));
    d = 0;
    for (var O = this.outputs.length; d < O; ++d) {
      switch(this.outputs[d].name) {
        case "sin":
          var f = Math.sin(a);
          break;
        case "cos":
          f = Math.cos(a);
          break;
        case "tan":
          f = Math.tan(a);
          break;
        case "asin":
          f = Math.asin(a);
          break;
        case "acos":
          f = Math.acos(a);
          break;
        case "atan":
          f = Math.atan(a);
      }
      this.setOutputData(d, b * f + k);
    }
  };
  F.prototype.onGetInputs = function() {
    return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];
  };
  F.prototype.onGetOutputs = function() {
    return [["sin", "number"], ["cos", "number"], ["tan", "number"], ["asin", "number"], ["acos", "number"], ["atan", "number"]];
  };
  t.registerNodeType("math/trigonometry", F);
  t.registerSearchboxExtra("math/trigonometry", "SIN()", {outputs:[["sin", "number"]], title:"SIN()"});
  t.registerSearchboxExtra("math/trigonometry", "COS()", {outputs:[["cos", "number"]], title:"COS()"});
  t.registerSearchboxExtra("math/trigonometry", "TAN()", {outputs:[["tan", "number"]], title:"TAN()"});
  G.title = "Formula";
  G.desc = "Compute formula";
  G.size = [160, 100];
  d.prototype.onPropertyChanged = function(a, b) {
    "formula" == a && (this.code_widget.value = b);
  };
  G.prototype.onExecute = function() {
    if (t.allow_scripts) {
      var a = this.getInputData(0), b = this.getInputData(1);
      null != a ? this.properties.x = a : a = this.properties.x;
      null != b ? this.properties.y = b : b = this.properties.y;
      try {
        this._func && this._func_code == this.properties.formula || (this._func = new Function("x", "y", "TIME", "return " + this.properties.formula), this._func_code = this.properties.formula);
        var d = this._func(a, b, this.graph.globaltime);
        this.boxcolor = null;
      } catch (k) {
        this.boxcolor = "red";
      }
      this.setOutputData(0, d);
    }
  };
  G.prototype.getTitle = function() {
    return this._func_code || "Formula";
  };
  G.prototype.onDrawBackground = function() {
    var a = this.properties.formula;
    this.outputs && this.outputs.length && (this.outputs[0].label = a);
  };
  t.registerNodeType("math/formula", G);
  P.title = "Vec2->XY";
  P.desc = "vector 2 to components";
  P.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]));
  };
  t.registerNodeType("math3d/vec2-to-xy", P);
  D.title = "XY->Vec2";
  D.desc = "components to vector2";
  D.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var d = this._data;
    d[0] = a;
    d[1] = b;
    this.setOutputData(0, d);
  };
  t.registerNodeType("math3d/xy-to-vec2", D);
  I.title = "Vec3->XYZ";
  I.desc = "vector 3 to components";
  I.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]));
  };
  t.registerNodeType("math3d/vec3-to-xyz", I);
  J.title = "XYZ->Vec3";
  J.desc = "components to vector3";
  J.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var d = this.getInputData(2);
    null == d && (d = this.properties.z);
    var k = this._data;
    k[0] = a;
    k[1] = b;
    k[2] = d;
    this.setOutputData(0, k);
  };
  t.registerNodeType("math3d/xyz-to-vec3", J);
  E.title = "Vec4->XYZW";
  E.desc = "vector 4 to components";
  E.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]), this.setOutputData(3, a[3]));
  };
  t.registerNodeType("math3d/vec4-to-xyzw", E);
  K.title = "XYZW->Vec4";
  K.desc = "components to vector4";
  K.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var d = this.getInputData(2);
    null == d && (d = this.properties.z);
    var k = this.getInputData(3);
    null == k && (k = this.properties.w);
    var O = this._data;
    O[0] = a;
    O[1] = b;
    O[2] = d;
    O[3] = k;
    this.setOutputData(0, O);
  };
  t.registerNodeType("math3d/xyzw-to-vec4", K);
  if (n.glMatrix) {
    n = function() {
      this.addInputs([["A", "quat"], ["B", "quat"], ["factor", "number"]]);
      this.addOutput("slerp", "quat");
      this.addProperty("factor", 0.5);
      this._value = quat.create();
    };
    var M = function() {
      this.addInputs([["A", "quat"], ["B", "quat"]]);
      this.addOutput("A*B", "quat");
      this._value = quat.create();
    }, H = function() {
      this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);
      this.addOutput("result", "vec3");
      this.properties = {vec:[0, 0, 1]};
    }, L = function() {
      this.addInputs([["degrees", "number"], ["axis", "vec3"]]);
      this.addOutput("quat", "quat");
      this.properties = {angle:90.0, axis:vec3.fromValues(0, 1, 0)};
      this._value = quat.create();
    }, N = function() {
      this.addOutput("quat", "quat");
      this.properties = {x:0, y:0, z:0, w:1};
      this._value = quat.create();
    };
    N.title = "Quaternion";
    N.desc = "quaternion";
    N.prototype.onExecute = function() {
      this._value[0] = this.properties.x;
      this._value[1] = this.properties.y;
      this._value[2] = this.properties.z;
      this._value[3] = this.properties.w;
      this.setOutputData(0, this._value);
    };
    t.registerNodeType("math3d/quaternion", N);
    L.title = "Rotation";
    L.desc = "quaternion rotation";
    L.prototype.onExecute = function() {
      var a = this.getInputData(0);
      null == a && (a = this.properties.angle);
      var b = this.getInputData(1);
      null == b && (b = this.properties.axis);
      a = quat.setAxisAngle(this._value, b, 0.0174532925 * a);
      this.setOutputData(0, a);
    };
    t.registerNodeType("math3d/rotation", L);
    H.title = "Rot. Vec3";
    H.desc = "rotate a point";
    H.prototype.onExecute = function() {
      var a = this.getInputData(0);
      null == a && (a = this.properties.vec);
      var b = this.getInputData(1);
      null == b ? this.setOutputData(a) : this.setOutputData(0, vec3.transformQuat(vec3.create(), a, b));
    };
    t.registerNodeType("math3d/rotate_vec3", H);
    M.title = "Mult. Quat";
    M.desc = "rotate quaternion";
    M.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (null != a) {
        var b = this.getInputData(1);
        null != b && (a = quat.multiply(this._value, a, b), this.setOutputData(0, a));
      }
    };
    t.registerNodeType("math3d/mult-quat", M);
    n.title = "Quat Slerp";
    n.desc = "quaternion spherical interpolation";
    n.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (null != a) {
        var b = this.getInputData(1);
        if (null != b) {
          var d = this.properties.factor;
          null != this.getInputData(2) && (d = this.getInputData(2));
          a = quat.slerp(this._value, a, b, d);
          this.setOutputData(0, a);
        }
      }
    };
    t.registerNodeType("math3d/quat-slerp", n);
  }
})(this);
(function(n) {
  function a() {
    this.addInput("sel", "number");
    this.addInput("A");
    this.addInput("B");
    this.addInput("C");
    this.addInput("D");
    this.addOutput("out");
    this.selected = 0;
  }
  function h() {
    this.properties = {sequence:"A,B,C"};
    this.addInput("index", "number");
    this.addInput("seq");
    this.addOutput("out");
    this.index = 0;
    this.values = this.properties.sequence.split(",");
  }
  var c = n.LiteGraph;
  a.title = "Selector";
  a.desc = "selects an output";
  a.prototype.onDrawBackground = function(a) {
    if (!this.flags.collapsed) {
      a.fillStyle = "#AFB";
      var b = (this.selected + 1) * c.NODE_SLOT_HEIGHT + 6;
      a.beginPath();
      a.moveTo(50, b);
      a.lineTo(50, b + c.NODE_SLOT_HEIGHT);
      a.lineTo(34, b + 0.5 * c.NODE_SLOT_HEIGHT);
      a.fill();
    }
  };
  a.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (null == a || a.constructor !== Number) {
      a = 0;
    }
    this.selected = a = Math.round(a) % (this.inputs.length - 1);
    a = this.getInputData(a + 1);
    void 0 !== a && this.setOutputData(0, a);
  };
  a.prototype.onGetInputs = function() {
    return [["E", 0], ["F", 0], ["G", 0], ["H", 0]];
  };
  c.registerNodeType("logic/selector", a);
  h.title = "Sequence";
  h.desc = "select one element from a sequence from a string";
  h.prototype.onPropertyChanged = function(a, c) {
    "sequence" == a && (this.values = c.split(","));
  };
  h.prototype.onExecute = function() {
    var a = this.getInputData(1);
    a && a != this.current_sequence && (this.values = a.split(","), this.current_sequence = a);
    a = this.getInputData(0);
    null == a && (a = 0);
    this.index = a = Math.round(a) % this.values.length;
    this.setOutputData(0, this.values[a]);
  };
  c.registerNodeType("logic/sequence", h);
})(this);
(function(n) {
  function a() {
    this.addOutput("tex", "Texture");
    this.addOutput("name", "string");
    this.properties = {name:"", filter:!0};
    this.size = [a.image_preview_size, a.image_preview_size];
  }
  function h() {
    this.addInput("Texture", "Texture");
    this.properties = {flipY:!1};
    this.size = [a.image_preview_size, a.image_preview_size];
  }
  function c() {
    this.addInput("Texture", "Texture");
    this.addOutput("tex", "Texture");
    this.addOutput("name", "string");
    this.properties = {name:"", generate_mipmaps:!1};
  }
  function b() {
    this.addInput("Texture", "Texture");
    this.addInput("TextureB", "Texture");
    this.addInput("value", "number");
    this.addOutput("Texture", "Texture");
    this.help = "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>\r\n\t\t<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>";
    this.properties = {value:1, pixelcode:"color + colorB * value", uvcode:"", precision:a.DEFAULT};
    this.has_error = !1;
  }
  function l() {
    this.addOutput("out", "Texture");
    this.properties = {code:"", u_value:1, u_color:[1, 1, 1, 1], width:512, height:512, precision:a.DEFAULT};
    this.properties.code = "//time: time in seconds\n//texSize: vec2 with res\nuniform float u_value;\nuniform vec4 u_color;\n\nvoid main() {\n  vec2 uv = v_coord;\n  vec3 color = vec3(0.0);\n\t//your code here\n\tcolor.xy=uv;\n\ngl_FragColor = vec4(color, 1.0);\n}\n";
    this._uniforms = {u_value:1, u_color:vec4.create(), in_texture:0, texSize:vec2.create(), time:0};
  }
  function g() {
    this.addInput("in", "Texture");
    this.addInput("scale", "vec2");
    this.addInput("offset", "vec2");
    this.addOutput("out", "Texture");
    this.properties = {offset:vec2.fromValues(0, 0), scale:vec2.fromValues(1, 1), precision:a.DEFAULT};
  }
  function x() {
    this.addInput("in", "Texture");
    this.addInput("warp", "Texture");
    this.addInput("factor", "number");
    this.addOutput("out", "Texture");
    this.properties = {factor:0.01, scale:[1, 1], offset:[0, 0], precision:a.DEFAULT};
    this._uniforms = {u_texture:0, u_textureB:1, u_factor:1, u_scale:vec2.create(), u_offset:vec2.create()};
  }
  function v() {
    this.addInput("Texture", "Texture");
    this.properties = {additive:!1, antialiasing:!1, filter:!0, disable_alpha:!1, gamma:1.0, viewport:[0, 0, 1, 1]};
    this.size[0] = 130;
  }
  function p() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {size:0, generate_mipmaps:!1, precision:a.DEFAULT};
  }
  function C() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {iterations:1, generate_mipmaps:!1, precision:a.DEFAULT};
  }
  function w() {
    this.addInput("Texture", "Texture");
    this.addOutput("tex", "Texture");
    this.addOutput("avg", "vec4");
    this.addOutput("lum", "number");
    this.properties = {use_previous_frame:!0, high_quality:!1};
    this._uniforms = {u_texture:0, u_mipmap_offset:0};
    this._luminance = new Float32Array(4);
  }
  function u() {
    this.addInput("in", "Texture");
    this.addInput("factor", "Number");
    this.addOutput("out", "Texture");
    this.properties = {factor:0.5};
    this._uniforms = {u_texture:0, u_textureB:1, u_factor:this.properties.factor};
  }
  function y() {
    this.addInput("in", "Texture");
    this.addOutput("avg", "Texture");
    this.addOutput("array", "Texture");
    this.properties = {samples:64, frames_interval:1};
    this._uniforms = {u_texture:0, u_textureB:1, u_samples:this.properties.samples, u_isamples:1 / this.properties.samples};
    this.frame = 0;
  }
  function r() {
    this.addInput("Image", "image");
    this.addOutput("", "Texture");
    this.properties = {};
  }
  function z() {
    this.addInput("Texture", "Texture");
    this.addInput("LUT", "Texture");
    this.addInput("Intensity", "number");
    this.addOutput("", "Texture");
    this.properties = {enabled:!0, intensity:1, precision:a.DEFAULT, texture:null};
    z._shader || (z._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, z.pixel_shader));
  }
  function d() {
    this.addInput("Texture", "Texture");
    this.addOutput("R", "Texture");
    this.addOutput("G", "Texture");
    this.addOutput("B", "Texture");
    this.addOutput("A", "Texture");
    d._shader || (d._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, d.pixel_shader));
  }
  function e() {
    this.addInput("R", "Texture");
    this.addInput("G", "Texture");
    this.addInput("B", "Texture");
    this.addInput("A", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {precision:a.DEFAULT, R:1, G:1, B:1, A:1};
    this._color = vec4.create();
    this._uniforms = {u_textureR:0, u_textureG:1, u_textureB:2, u_textureA:3, u_color:this._color};
  }
  function m() {
    this.addOutput("Texture", "Texture");
    this._tex_color = vec4.create();
    this.properties = {color:vec4.create(), precision:a.DEFAULT};
  }
  function f() {
    this.addInput("A", "color");
    this.addInput("B", "color");
    this.addOutput("Texture", "Texture");
    this.properties = {angle:0, scale:1, A:[0, 0, 0], B:[1, 1, 1], texture_size:32};
    f._shader || (f._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, f.pixel_shader));
    this._uniforms = {u_angle:0, u_colorA:vec3.create(), u_colorB:vec3.create()};
  }
  function q() {
    this.addInput("A", "Texture");
    this.addInput("B", "Texture");
    this.addInput("Mixer", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {factor:0.5, size_from_biggest:!0, invert:!1, precision:a.DEFAULT};
    this._uniforms = {u_textureA:0, u_textureB:1, u_textureMix:2, u_mix:vec4.create()};
  }
  function B() {
    this.addInput("Tex.", "Texture");
    this.addOutput("Edges", "Texture");
    this.properties = {invert:!0, threshold:!1, factor:1, precision:a.DEFAULT};
    B._shader || (B._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, B.pixel_shader));
  }
  function F() {
    this.addInput("Texture", "Texture");
    this.addInput("Distance", "number");
    this.addInput("Range", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {distance:100, range:50, only_depth:!1, high_precision:!1};
    this._uniforms = {u_texture:0, u_distance:100, u_range:50, u_camera_planes:null};
  }
  function G() {
    this.addInput("Texture", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {precision:a.DEFAULT, invert:!1};
    this._uniforms = {u_texture:0, u_near:0.1, u_far:10000};
  }
  function P() {
    this.addInput("Texture", "Texture");
    this.addInput("Iterations", "number");
    this.addInput("Intensity", "number");
    this.addOutput("Blurred", "Texture");
    this.properties = {intensity:1, iterations:1, preserve_aspect:!1, scale:[1, 1], precision:a.DEFAULT};
  }
  function D() {
    this.addInput("in", "Texture");
    this.addInput("dirt", "Texture");
    this.addOutput("out", "Texture");
    this.addOutput("glow", "Texture");
    this.properties = {enabled:!0, intensity:1, persistence:0.99, iterations:16, threshold:0, scale:1, dirt_factor:0.5, precision:a.DEFAULT};
    this._textures = [];
    this._uniforms = {u_intensity:1, u_texture:0, u_glow_texture:1, u_threshold:0, u_texel_size:vec2.create()};
  }
  function I() {
    this.addInput("Texture", "Texture");
    this.addOutput("Filtered", "Texture");
    this.properties = {intensity:1, radius:5};
  }
  function J() {
    this.addInput("Texture", "Texture");
    this.addOutput("Filtered", "Texture");
    this.properties = {sigma:1.4, k:1.6, p:21.7, epsilon:79, phi:0.017};
  }
  function E() {
    this.addOutput("Webcam", "Texture");
    this.properties = {texture_name:"", facingMode:"user"};
    this.boxcolor = "black";
    this.version = 0;
  }
  function K() {
    this.addInput("in", "Texture");
    this.addInput("f", "number");
    this.addOutput("out", "Texture");
    this.properties = {enabled:!0, factor:1, precision:a.LOW};
    this._uniforms = {u_texture:0, u_factor:1};
  }
  function t() {
    this.addInput("in", "Texture");
    this.addOutput("out", "Texture");
    this.properties = {precision:a.LOW, split_channels:!1};
    this._values = new Uint8Array(1024);
    this._values.fill(255);
    this._curve_texture = null;
    this._uniforms = {u_texture:0, u_curve:1, u_range:1.0};
    this._must_update = !0;
    this._points = {RGB:[[0, 0], [1, 1]], R:[[0, 0], [1, 1]], G:[[0, 0], [1, 1]], B:[[0, 0], [1, 1]]};
    this.curve_editor = null;
    this.addWidget("toggle", "Split Channels", !1, "split_channels");
    this.addWidget("combo", "Channel", "RGB", {values:["RGB", "R", "G", "B"]});
    this.curve_offset = 68;
    this.size = [240, 160];
  }
  function M() {
    this.addInput("in", "Texture");
    this.addInput("exp", "number");
    this.addOutput("out", "Texture");
    this.properties = {exposition:1, precision:a.LOW};
    this._uniforms = {u_texture:0, u_exposition:1};
  }
  function H() {
    this.addInput("in", "Texture");
    this.addInput("avg", "number,Texture");
    this.addOutput("out", "Texture");
    this.properties = {enabled:!0, scale:1, gamma:1, average_lum:1, lum_white:1, precision:a.LOW};
    this._uniforms = {u_texture:0, u_lumwhite2:1, u_igamma:1, u_scale:1, u_average_lum:1};
  }
  function L() {
    this.addOutput("out", "Texture");
    this.properties = {width:512, height:512, seed:0, persistence:0.1, octaves:8, scale:1, offset:[0, 0], amplitude:1, precision:a.DEFAULT};
    this._key = 0;
    this._texture = null;
    this._uniforms = {u_persistence:0.1, u_seed:0, u_offset:vec2.create(), u_scale:1, u_viewport:vec2.create()};
  }
  function N() {
    this.addInput("v");
    this.addOutput("out", "Texture");
    this.properties = {code:"", width:512, height:512, clear:!0, precision:a.DEFAULT, use_html_canvas:!1};
    this._temp_texture = this._func = null;
  }
  function Q() {
    this.addInput("in", "Texture");
    this.addOutput("out", "Texture");
    this.properties = {key_color:vec3.fromValues(0, 1, 0), threshold:0.8, slope:0.2, precision:a.DEFAULT};
  }
  function R() {
    this.addInput("in", "texture");
    this.addInput("yaw", "number");
    this.addOutput("out", "texture");
    this.properties = {yaw:0};
  }
  var A = n.LiteGraph;
  n.LGraphTexture = null;
  "undefined" != typeof GL && (LGraphCanvas.link_type_colors.Texture = "#987", n.LGraphTexture = a, a.title = "Texture", a.desc = "Texture", a.widgets_info = {name:{widget:"texture"}, filter:{widget:"checkbox"}}, a.loadTextureCallback = null, a.image_preview_size = 256, a.PASS_THROUGH = 1, a.COPY = 2, a.LOW = 3, a.HIGH = 4, a.REUSE = 5, a.DEFAULT = 2, a.MODE_VALUES = {"pass through":a.PASS_THROUGH, copy:a.COPY, low:a.LOW, high:a.HIGH, reuse:a.REUSE, default:a.DEFAULT}, a.getTexturesContainer = function() {
    return gl.textures;
  }, a.loadTexture = function(k, b) {
    b = b || {};
    var d = k;
    "http://" == d.substr(0, 7) && A.proxy && (d = A.proxy + d.substr(7));
    return a.getTexturesContainer()[k] = GL.Texture.fromURL(d, b);
  }, a.getTexture = function(a) {
    var k = this.getTexturesContainer();
    if (!k) {
      throw "Cannot load texture, container of textures not found";
    }
    k = k[a];
    return !k && a && ":" != a[0] ? this.loadTexture(a) : k;
  }, a.getTargetTexture = function(k, b, d) {
    if (!k) {
      throw "LGraphTexture.getTargetTexture expects a reference texture";
    }
    switch(d) {
      case a.LOW:
        d = gl.UNSIGNED_BYTE;
        break;
      case a.HIGH:
        d = gl.HIGH_PRECISION_FORMAT;
        break;
      case a.REUSE:
        return k;
      default:
        d = k ? k.type : gl.UNSIGNED_BYTE;
    }
    b && b.width == k.width && b.height == k.height && b.type == d || (b = new GL.Texture(k.width, k.height, {type:d, format:gl.RGBA, filter:gl.LINEAR}));
    return b;
  }, a.getTextureType = function(k, b) {
    b = b ? b.type : gl.UNSIGNED_BYTE;
    switch(k) {
      case a.HIGH:
        b = gl.HIGH_PRECISION_FORMAT;
        break;
      case a.LOW:
        b = gl.UNSIGNED_BYTE;
    }
    return b;
  }, a.getWhiteTexture = function() {
    return this._white_texture ? this._white_texture : this._white_texture = GL.Texture.fromMemory(1, 1, [255, 255, 255, 255], {format:gl.RGBA, wrap:gl.REPEAT, filter:gl.NEAREST});
  }, a.getNoiseTexture = function() {
    if (this._noise_texture) {
      return this._noise_texture;
    }
    for (var a = new Uint8Array(1048576), b = 0; 1048576 > b; ++b) {
      a[b] = 255 * Math.random();
    }
    return this._noise_texture = a = GL.Texture.fromMemory(512, 512, a, {format:gl.RGBA, wrap:gl.REPEAT, filter:gl.NEAREST});
  }, a.prototype.onDropFile = function(a, b, d) {
    a ? ("string" == typeof a ? a = GL.Texture.fromURL(a) : -1 != b.toLowerCase().indexOf(".dds") ? a = GL.Texture.fromDDSInMemory(a) : (a = new Blob([d]), a = URL.createObjectURL(a), a = GL.Texture.fromURL(a)), this._drop_texture = a, this.properties.name = b) : (this._drop_texture = null, this.properties.name = "");
  }, a.prototype.getExtraMenuOptions = function(a) {
    var k = this;
    if (this._drop_texture) {
      return [{content:"Clear", callback:function() {
        k._drop_texture = null;
        k.properties.name = "";
      }}];
    }
  }, a.prototype.onExecute = function() {
    var k = null;
    this.isOutputConnected(1) && (k = this.getInputData(0));
    !k && this._drop_texture && (k = this._drop_texture);
    !k && this.properties.name && (k = a.getTexture(this.properties.name));
    if (k) {
      this._last_tex = k;
      !1 === this.properties.filter ? k.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST) : k.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      this.setOutputData(0, k);
      this.setOutputData(1, k.fullpath || k.filename);
      for (var b = 2; b < this.outputs.length; b++) {
        var d = this.outputs[b];
        if (d) {
          var f = null;
          "width" == d.name ? f = k.width : "height" == d.name ? f = k.height : "aspect" == d.name && (f = k.width / k.height);
          this.setOutputData(b, f);
        }
      }
    } else {
      this.setOutputData(0, null), this.setOutputData(1, "");
    }
  }, a.prototype.onResourceRenamed = function(a, b) {
    this.properties.name == a && (this.properties.name = b);
  }, a.prototype.onDrawBackground = function(k) {
    if (!(this.flags.collapsed || 20 >= this.size[1])) {
      if (this._drop_texture && k.webgl) {
        k.drawImage(this._drop_texture, 0, 0, this.size[0], this.size[1]);
      } else {
        if (this._last_preview_tex != this._last_tex) {
          if (k.webgl) {
            this._canvas = this._last_tex;
          } else {
            var b = a.generateLowResTexturePreview(this._last_tex);
            if (!b) {
              return;
            }
            this._last_preview_tex = this._last_tex;
            this._canvas = cloneCanvas(b);
          }
        }
        this._canvas && (k.save(), k.webgl || (k.translate(0, this.size[1]), k.scale(1, -1)), k.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]), k.restore());
      }
    }
  }, a.generateLowResTexturePreview = function(k) {
    if (!k) {
      return null;
    }
    var b = a.image_preview_size, d = k;
    if (k.format == gl.DEPTH_COMPONENT) {
      return null;
    }
    if (k.width > b || k.height > b) {
      d = this._preview_temp_tex, this._preview_temp_tex || (this._preview_temp_tex = d = new GL.Texture(b, b, {minFilter:gl.NEAREST})), k.copyTo(d);
    }
    k = this._preview_canvas;
    k || (this._preview_canvas = k = createCanvas(b, b));
    d && d.toCanvas(k);
    return k;
  }, a.prototype.getResources = function(a) {
    this.properties.name && (a[this.properties.name] = GL.Texture);
    return a;
  }, a.prototype.onGetInputs = function() {
    return [["in", "Texture"]];
  }, a.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["aspect", "number"]];
  }, a.replaceCode = function(a, b) {
    return a.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function(a) {
      a = a.replace(/[\{\}]/g, "");
      return b[a] || "";
    });
  }, A.registerNodeType("texture/texture", a), h.title = "Preview", h.desc = "Show a texture in the graph canvas", h.allow_preview = !1, h.prototype.onDrawBackground = function(k) {
    if (!this.flags.collapsed && (k.webgl || h.allow_preview)) {
      var b = this.getInputData(0);
      b && (b = !b.handle && k.webgl ? b : a.generateLowResTexturePreview(b), k.save(), this.properties.flipY && (k.translate(0, this.size[1]), k.scale(1, -1)), k.drawImage(b, 0, 0, this.size[0], this.size[1]), k.restore());
    }
  }, A.registerNodeType("texture/preview", h), c.title = "Save", c.desc = "Save a texture in the repository", c.prototype.getPreviewTexture = function() {
    return this._texture;
  }, c.prototype.onExecute = function() {
    var k = this.getInputData(0);
    k && (this.properties.generate_mipmaps && (k.bind(0), k.setParameter(gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR), gl.generateMipmap(k.texture_type), k.unbind(0)), this.properties.name && (a.storeTexture ? a.storeTexture(this.properties.name, k) : a.getTexturesContainer()[this.properties.name] = k), this._texture = k, this.setOutputData(0, k), this.setOutputData(1, this.properties.name));
  }, A.registerNodeType("texture/save", c), b.widgets_info = {uvcode:{widget:"code"}, pixelcode:{widget:"code"}, precision:{widget:"combo", values:a.MODE_VALUES}}, b.title = "Operation", b.desc = "Texture shader operation", b.presets = {}, b.prototype.getExtraMenuOptions = function(a) {
    var k = this;
    return [{content:k.properties.show ? "Hide Texture" : "Show Texture", callback:function() {
      k.properties.show = !k.properties.show;
    }}];
  }, b.prototype.onPropertyChanged = function() {
    this.has_error = !1;
  }, b.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._tex || this._tex.gl != a || (a.save(), a.drawImage(this._tex, 0, 0, this.size[0], this.size[1]), a.restore());
  }, b.prototype.onExecute = function() {
    var k = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === a.PASS_THROUGH) {
        this.setOutputData(0, k);
      } else {
        var d = this.getInputData(1);
        if (this.properties.uvcode || this.properties.pixelcode) {
          var f = 512, e = 512;
          k ? (f = k.width, e = k.height) : d && (f = d.width, e = d.height);
          d || (d = GL.Texture.getWhiteTexture());
          var c = a.getTextureType(this.properties.precision, k);
          this._tex = k || this._tex ? a.getTargetTexture(k || this._tex, this._tex, this.properties.precision) : new GL.Texture(f, e, {type:c, format:gl.RGBA, filter:gl.LINEAR});
          c = "";
          this.properties.uvcode && (c = "uv = " + this.properties.uvcode, -1 != this.properties.uvcode.indexOf(";") && (c = this.properties.uvcode));
          var g = "";
          this.properties.pixelcode && (g = "result = " + this.properties.pixelcode, -1 != this.properties.pixelcode.indexOf(";") && (g = this.properties.pixelcode));
          var q = this._shader;
          if (!(this.has_error || q && this._shader_code == c + "|" + g)) {
            var m = a.replaceCode(b.pixel_shader, {UV_CODE:c, PIXEL_CODE:g});
            try {
              q = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, m), this.boxcolor = "#00FF00";
            } catch (U) {
              GL.Shader.dumpErrorToConsole(U, Shader.SCREEN_VERTEX_SHADER, m);
              this.boxcolor = "#FF0000";
              this.has_error = !0;
              return;
            }
            this._shader = q;
            this._shader_code = c + "|" + g;
          }
          if (this._shader) {
            var l = this.getInputData(2);
            null != l ? this.properties.value = l : l = parseFloat(this.properties.value);
            var h = this.graph.getTime();
            this._tex.drawTo(function() {
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              gl.disable(gl.BLEND);
              k && k.bind(0);
              d && d.bind(1);
              var a = Mesh.getScreenQuad();
              q.uniforms({u_texture:0, u_textureB:1, value:l, texSize:[f, e], time:h}).draw(a);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    }
  }, b.pixel_shader = "precision highp float;\n\r\n\t\t\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform vec2 texSize;\n\r\n\t\tuniform float time;\n\r\n\t\tuniform float value;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t{{UV_CODE}};\n\r\n\t\t\tvec4 color4 = texture2D(u_texture, uv);\n\r\n\t\t\tvec3 color = color4.rgb;\n\r\n\t\t\tvec4 color4B = texture2D(u_textureB, uv);\n\r\n\t\t\tvec3 colorB = color4B.rgb;\n\r\n\t\t\tvec3 result = color;\n\r\n\t\t\tfloat alpha = 1.0;\n\r\n\t\t\t{{PIXEL_CODE}};\n\r\n\t\t\tgl_FragColor = vec4(result, alpha);\n\r\n\t\t}\n\r\n\t\t", 
  b.registerPreset = function(a, d) {
    b.presets[a] = d;
  }, b.registerPreset("", ""), b.registerPreset("bypass", "color"), b.registerPreset("add", "color + colorB * value"), b.registerPreset("substract", "(color - colorB) * value"), b.registerPreset("mate", "mix( color, colorB, color4B.a * value)"), b.registerPreset("invert", "vec3(1.0) - color"), b.registerPreset("multiply", "color * colorB * value"), b.registerPreset("divide", "(color / colorB) / value"), b.registerPreset("difference", "abs(color - colorB) * value"), b.registerPreset("max", "max(color, colorB) * value"), 
  b.registerPreset("min", "min(color, colorB) * value"), b.registerPreset("displace", "texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz"), b.registerPreset("grayscale", "vec3(color.x + color.y + color.z) * value / 3.0"), b.registerPreset("saturation", "mix( vec3(color.x + color.y + color.z) / 3.0, color, value )"), b.registerPreset("threshold", "vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)"), b.prototype.onInspect = 
  function(a) {
    var k = this;
    a.addCombo("Presets", "", {values:Object.keys(b.presets), callback:function(d) {
      var f = b.presets[d];
      f && (k.setProperty("pixelcode", f), k.title = d, a.refresh());
    }});
  }, A.registerNodeType("texture/operation", b), l.title = "Shader", l.desc = "Texture shader", l.widgets_info = {code:{type:"code"}, precision:{widget:"combo", values:a.MODE_VALUES}}, l.prototype.onPropertyChanged = function(a, b) {
    if ("code" == a && (a = this.getShader())) {
      b = a.uniformInfo;
      if (this.inputs) {
        for (var k = {}, d = 0; d < this.inputs.length; ++d) {
          var f = this.getInputInfo(d);
          f && (b[f.name] && !k[f.name] ? k[f.name] = !0 : (this.removeInput(d), d--));
        }
      }
      for (d in b) {
        if (f = a.uniformInfo[d], null !== f.loc && "time" != d) {
          if (this._shader.samplers[d]) {
            b = "texture";
          } else {
            switch(f.size) {
              case 1:
                b = "number";
                break;
              case 2:
                b = "vec2";
                break;
              case 3:
                b = "vec3";
                break;
              case 4:
                b = "vec4";
                break;
              case 9:
                b = "mat3";
                break;
              case 16:
                b = "mat4";
                break;
              default:
                continue;
            }
          }
          k = this.findInputSlot(d);
          if (-1 != k && (f = this.getInputInfo(k))) {
            if (f.type == b) {
              continue;
            }
            this.removeInput(k, b);
          }
          this.addInput(d, b);
        }
      }
    }
  }, l.prototype.getShader = function() {
    if (this._shader && this._shader_code == this.properties.code) {
      return this._shader;
    }
    this._shader_code = this.properties.code;
    this._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, l.pixel_shader + this.properties.code), this.boxcolor = "green";
    return this._shader;
  }, l.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var k = this.getShader();
      if (k) {
        var b = 0, d = null;
        if (this.inputs) {
          for (var f = 0; f < this.inputs.length; ++f) {
            var e = this.getInputInfo(f), c = this.getInputData(f);
            null != c && (c.constructor === GL.Texture && (c.bind(b), d || (d = c), c = b, b++), k.setUniform(e.name, c));
          }
        }
        var g = this._uniforms;
        b = a.getTextureType(this.properties.precision, d);
        f = this.properties.width | 0;
        e = this.properties.height | 0;
        0 == f && (f = d ? d.width : gl.canvas.width);
        0 == e && (e = d ? d.height : gl.canvas.height);
        g.texSize[0] = f;
        g.texSize[1] = e;
        g.time = this.graph.getTime();
        g.u_value = this.properties.u_value;
        g.u_color.set(this.properties.u_color);
        this._tex && this._tex.type == b && this._tex.width == f && this._tex.height == e || (this._tex = new GL.Texture(f, e, {type:b, format:gl.RGBA, filter:gl.LINEAR}));
        this._tex.drawTo(function() {
          k.uniforms(g).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, this._tex);
      }
    }
  }, l.pixel_shader = "precision highp float;\n\r\n\t\t\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform float time;\n\r\n", A.registerNodeType("texture/shader", l), g.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, g.title = "Scale/Offset", g.desc = "Applies an scaling and offseting", g.prototype.onExecute = function() {
    var k = this.getInputData(0);
    if (this.isOutputConnected(0) && k) {
      if (this.properties.precision === a.PASS_THROUGH) {
        this.setOutputData(0, k);
      } else {
        var b = k.width, d = k.height, f = this.precision === a.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;
        this.precision === a.DEFAULT && (f = k.type);
        this._tex && this._tex.width == b && this._tex.height == d && this._tex.type == f || (this._tex = new GL.Texture(b, d, {type:f, format:gl.RGBA, filter:gl.LINEAR}));
        var e = this._shader;
        e || (e = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, g.pixel_shader));
        var c = this.getInputData(1);
        c ? (this.properties.scale[0] = c[0], this.properties.scale[1] = c[1]) : c = this.properties.scale;
        var q = this.getInputData(2);
        q ? (this.properties.offset[0] = q[0], this.properties.offset[1] = q[1]) : q = this.properties.offset;
        this._tex.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.BLEND);
          k.bind(0);
          var a = Mesh.getScreenQuad();
          e.uniforms({u_texture:0, u_scale:c, u_offset:q}).draw(a);
        });
        this.setOutputData(0, this._tex);
      }
    }
  }, g.pixel_shader = "precision highp float;\n\r\n\t\t\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform vec2 u_scale;\n\r\n\t\tuniform vec2 u_offset;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec2 uv = v_coord;\n\r\n\t\t\tuv = uv / u_scale - u_offset;\n\r\n\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\r\n\t\t}\n\r\n\t\t", A.registerNodeType("texture/scaleOffset", g), x.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, 
  x.title = "Warp", x.desc = "Texture warp operation", x.prototype.onExecute = function() {
    var k = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === a.PASS_THROUGH) {
        this.setOutputData(0, k);
      } else {
        var b = this.getInputData(1), d = 512, f = 512;
        k ? (d = k.width, f = k.height) : b && (d = b.width, f = b.height);
        this._tex = k || this._tex ? a.getTargetTexture(k || this._tex, this._tex, this.properties.precision) : new GL.Texture(d, f, {type:this.precision === a.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT, format:gl.RGBA, filter:gl.LINEAR});
        var e = this._shader;
        e || (e = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, x.pixel_shader));
        d = this.getInputData(2);
        null != d ? this.properties.factor = d : d = parseFloat(this.properties.factor);
        var c = this._uniforms;
        c.u_factor = d;
        c.u_scale.set(this.properties.scale);
        c.u_offset.set(this.properties.offset);
        this._tex.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.BLEND);
          k && k.bind(0);
          b && b.bind(1);
          var a = Mesh.getScreenQuad();
          e.uniforms(c).draw(a);
        });
        this.setOutputData(0, this._tex);
      }
    }
  }, x.pixel_shader = "precision highp float;\n\r\n\t\t\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform float u_factor;\n\r\n\t\tuniform vec2 u_scale;\n\r\n\t\tuniform vec2 u_offset;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec2 uv = v_coord;\n\r\n\t\t\tuv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;\n\r\n\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\r\n\t\t}\n\r\n\t\t", A.registerNodeType("texture/warp", 
  x), v.title = "to Viewport", v.desc = "Texture to viewport", v._prev_viewport = new Float32Array(4), v.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      this.properties.disable_alpha ? gl.disable(gl.BLEND) : (gl.enable(gl.BLEND), this.properties.additive ? gl.blendFunc(gl.SRC_ALPHA, gl.ONE) : gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA));
      gl.disable(gl.DEPTH_TEST);
      var b = this.properties.gamma || 1.0;
      this.isInputConnected(1) && (b = this.getInputData(1));
      a.setParameter(gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST);
      var d = v._prev_viewport;
      d.set(gl.viewport_data);
      var f = this.properties.viewport;
      gl.viewport(d[0] + d[2] * f[0], d[1] + d[3] * f[1], d[2] * f[2], d[3] * f[3]);
      gl.getViewport();
      this.properties.antialiasing ? (v._shader || (v._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, v.aa_pixel_shader)), f = Mesh.getScreenQuad(), a.bind(0), v._shader.uniforms({u_texture:0, uViewportSize:[a.width, a.height], u_igamma:1 / b, inverseVP:[1 / a.width, 1 / a.height]}).draw(f)) : 1.0 != b ? (v._gamma_shader || (v._gamma_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, v.gamma_pixel_shader)), a.toViewport(v._gamma_shader, {u_texture:0, u_igamma:1 / b})) : a.toViewport();
      gl.viewport(d[0], d[1], d[2], d[3]);
    }
  }, v.prototype.onGetInputs = function() {
    return [["gamma", "number"]];
  }, v.aa_pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec2 uViewportSize;\n\r\n\t\tuniform vec2 inverseVP;\n\r\n\t\tuniform float u_igamma;\n\r\n\t\t#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\r\n\t\t#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\r\n\t\t#define FXAA_SPAN_MAX     8.0\n\r\n\t\t\n\r\n\t\t/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\n\r\n\t\tvec4 applyFXAA(sampler2D tex, vec2 fragCoord)\n\r\n\t\t{\n\r\n\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\t/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\n\r\n\t\t\tvec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\n\r\n\t\t\tvec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\n\r\n\t\t\tvec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\n\r\n\t\t\tvec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\n\r\n\t\t\tvec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\n\r\n\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\r\n\t\t\tfloat lumaNW = dot(rgbNW, luma);\n\r\n\t\t\tfloat lumaNE = dot(rgbNE, luma);\n\r\n\t\t\tfloat lumaSW = dot(rgbSW, luma);\n\r\n\t\t\tfloat lumaSE = dot(rgbSE, luma);\n\r\n\t\t\tfloat lumaM  = dot(rgbM,  luma);\n\r\n\t\t\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\r\n\t\t\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\r\n\t\t\t\n\r\n\t\t\tvec2 dir;\n\r\n\t\t\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\r\n\t\t\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\r\n\t\t\t\n\r\n\t\t\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\r\n\t\t\t\n\r\n\t\t\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\r\n\t\t\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n\r\n\t\t\t\n\r\n\t\t\tvec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \n\r\n\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n\r\n\t\t\tvec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \n\r\n\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\r\n\t\t\t\n\r\n\t\t\t//return vec4(rgbA,1.0);\n\r\n\t\t\tfloat lumaB = dot(rgbB, luma);\n\r\n\t\t\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\r\n\t\t\t\tcolor = vec4(rgbA, 1.0);\n\r\n\t\t\telse\n\r\n\t\t\t\tcolor = vec4(rgbB, 1.0);\n\r\n\t\t\tif(u_igamma != 1.0)\n\r\n\t\t\t\tcolor.xyz = pow( color.xyz, vec3(u_igamma) );\n\r\n\t\t\treturn color;\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\n\r\n\t\t}\n\r\n\t\t", 
  v.gamma_pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_igamma;\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = texture2D( u_texture, v_coord);\n\r\n\t\t\tcolor.xyz = pow(color.xyz, vec3(u_igamma) );\n\r\n\t\t   gl_FragColor = color;\n\r\n\t\t}\n\r\n\t\t", A.registerNodeType("texture/toviewport", v), p.title = "Copy", p.desc = "Copy Texture", p.widgets_info = {size:{widget:"combo", 
  values:[0, 32, 64, 128, 256, 512, 1024, 2048]}, precision:{widget:"combo", values:a.MODE_VALUES}}, p.prototype.onExecute = function() {
    var b = this.getInputData(0);
    if ((b || this._temp_texture) && this.isOutputConnected(0)) {
      if (b) {
        var d = b.width, f = b.height;
        0 != this.properties.size && (f = d = this.properties.size);
        var e = this._temp_texture, c = b.type;
        this.properties.precision === a.LOW ? c = gl.UNSIGNED_BYTE : this.properties.precision === a.HIGH && (c = gl.HIGH_PRECISION_FORMAT);
        e && e.width == d && e.height == f && e.type == c || (e = gl.LINEAR, this.properties.generate_mipmaps && isPowerOfTwo(d) && isPowerOfTwo(f) && (e = gl.LINEAR_MIPMAP_LINEAR), this._temp_texture = new GL.Texture(d, f, {type:c, format:gl.RGBA, minFilter:e, magFilter:gl.LINEAR}));
        b.copyTo(this._temp_texture);
        this.properties.generate_mipmaps && (this._temp_texture.bind(0), gl.generateMipmap(this._temp_texture.texture_type), this._temp_texture.unbind(0));
      }
      this.setOutputData(0, this._temp_texture);
    }
  }, A.registerNodeType("texture/copy", p), C.title = "Downsample", C.desc = "Downsample Texture", C.widgets_info = {iterations:{type:"number", step:1, precision:0, min:0}, precision:{widget:"combo", values:a.MODE_VALUES}}, C.prototype.onExecute = function() {
    var b = this.getInputData(0);
    if ((b || this._temp_texture) && this.isOutputConnected(0) && b && b.texture_type === GL.TEXTURE_2D) {
      if (1 > this.properties.iterations) {
        this.setOutputData(0, b);
      } else {
        var d = C._shader;
        d || (C._shader = d = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, C.pixel_shader));
        var f = b.width | 0, e = b.height | 0, c = b.type;
        this.properties.precision === a.LOW ? c = gl.UNSIGNED_BYTE : this.properties.precision === a.HIGH && (c = gl.HIGH_PRECISION_FORMAT);
        var g = this.properties.iterations || 1, q = b, m = [];
        c = {type:c, format:b.format};
        var l = vec2.create(), h = {u_offset:l};
        this._texture && GL.Texture.releaseTemporary(this._texture);
        for (var B = 0; B < g; ++B) {
          l[0] = 1 / f;
          l[1] = 1 / e;
          f = f >> 1 || 0;
          e = e >> 1 || 0;
          b = GL.Texture.getTemporary(f, e, c);
          m.push(b);
          q.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
          q.copyTo(b, d, h);
          if (1 == f && 1 == e) {
            break;
          }
          q = b;
        }
        this._texture = m.pop();
        for (B = 0; B < m.length; ++B) {
          GL.Texture.releaseTemporary(m[B]);
        }
        this.properties.generate_mipmaps && (this._texture.bind(0), gl.generateMipmap(this._texture.texture_type), this._texture.unbind(0));
        this.setOutputData(0, this._texture);
      }
    }
  }, C.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec2 u_offset;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = texture2D(u_texture, v_coord );\n\r\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\n\r\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\n\r\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\n\r\n\t\t   gl_FragColor = color * 0.25;\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/downsample", C), w.title = "Average", w.desc = "Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.\n If high_quality is true, then it generates the mipmaps first and reads from the lower one.", w.prototype.onExecute = function() {
    this.properties.use_previous_frame || this.updateAverage();
    var a = this._luminance;
    this.setOutputData(0, this._temp_texture);
    this.setOutputData(1, a);
    this.setOutputData(2, (a[0] + a[1] + a[2]) / 3);
  }, w.prototype.onPreRenderExecute = function() {
    this.updateAverage();
  }, w.prototype.updateAverage = function() {
    var a = this.getInputData(0);
    if (a && (this.isOutputConnected(0) || this.isOutputConnected(1) || this.isOutputConnected(2))) {
      if (!w._shader) {
        w._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, w.pixel_shader);
        for (var b = new Float32Array(16), d = 0; d < b.length; ++d) {
          b[d] = Math.random();
        }
        w._shader.uniforms({u_samples_a:b.subarray(0, 16), u_samples_b:b.subarray(16, 32)});
      }
      d = this._temp_texture;
      b = gl.UNSIGNED_BYTE;
      a.type != b && (b = gl.FLOAT);
      d && d.type == b || (this._temp_texture = new GL.Texture(1, 1, {type:b, format:gl.RGBA, filter:gl.NEAREST}));
      this._uniforms.u_mipmap_offset = 0;
      this.properties.high_quality && (this._temp_pot2_texture && this._temp_pot2_texture.type == b || (this._temp_pot2_texture = new GL.Texture(512, 512, {type:b, format:gl.RGBA, minFilter:gl.LINEAR_MIPMAP_LINEAR, magFilter:gl.LINEAR})), a.copyTo(this._temp_pot2_texture), a = this._temp_pot2_texture, a.bind(0), gl.generateMipmap(GL.TEXTURE_2D), this._uniforms.u_mipmap_offset = 9);
      var f = w._shader, e = this._uniforms;
      e.u_mipmap_offset = this.properties.mipmap_offset;
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);
      this._temp_texture.drawTo(function() {
        a.toViewport(f, e);
      });
      if (this.isOutputConnected(1) || this.isOutputConnected(2)) {
        if (d = this._temp_texture.getPixels()) {
          var c = this._luminance;
          b = this._temp_texture.type;
          c.set(d);
          b == gl.UNSIGNED_BYTE && vec4.scale(c, c, 1 / 255);
        }
      }
    }
  }, w.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tuniform mat4 u_samples_a;\n\r\n\t\tuniform mat4 u_samples_b;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_mipmap_offset;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\t//random average\n\r\n\t\t\tfor(int i = 0; i < 4; ++i)\n\r\n\t\t\t\tfor(int j = 0; j < 4; ++j)\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\r\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\r\n\t\t\t\t}\n\r\n\t\t   gl_FragColor = color * 0.03125;\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/average", w), u.title = "Smooth", u.desc = "Smooth texture over time", u.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      u._shader || (u._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, u.pixel_shader));
      var b = this._temp_texture;
      b && b.type == a.type && b.width == a.width && b.height == a.height || (b = {type:a.type, format:gl.RGBA, filter:gl.NEAREST}, this._temp_texture = new GL.Texture(a.width, a.height, b), this._temp_texture2 = new GL.Texture(a.width, a.height, b), a.copyTo(this._temp_texture2));
      b = this._temp_texture;
      var d = this._temp_texture2, f = u._shader, e = this._uniforms;
      e.u_factor = 1.0 - this.getInputOrProperty("factor");
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      b.drawTo(function() {
        d.bind(1);
        a.toViewport(f, e);
      });
      this.setOutputData(0, b);
      this._temp_texture = d;
      this._temp_texture2 = b;
    }
  }, u.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tuniform float u_factor;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tgl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );\n\r\n\t\t}\n\r\n\t\t", A.registerNodeType("texture/temporal_smooth", u), y.title = "Lineal Avg Smooth", y.desc = "Smooth texture linearly over time", 
  y["@samples"] = {type:"number", min:1, max:64, step:1, precision:1}, y.prototype.getPreviewTexture = function() {
    return this._temp_texture2;
  }, y.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      y._shader || (y._shader_copy = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, y.pixel_shader_copy), y._shader_avg = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, y.pixel_shader_avg));
      var b = Math.clamp(this.properties.samples, 0, 64), d = this.frame, f = this.properties.frames_interval;
      if (0 == f || 0 == d % f) {
        d = this._temp_texture;
        d && d.type == a.type && d.width == b || (d = {type:a.type, format:gl.RGBA, filter:gl.NEAREST}, this._temp_texture = new GL.Texture(b, 1, d), this._temp_texture2 = new GL.Texture(b, 1, d), this._temp_texture_out = new GL.Texture(1, 1, d));
        var e = this._temp_texture, c = this._temp_texture2, g = y._shader_copy, q = y._shader_avg, m = this._uniforms;
        m.u_samples = b;
        m.u_isamples = 1.0 / b;
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        e.drawTo(function() {
          c.bind(1);
          a.toViewport(g, m);
        });
        this._temp_texture_out.drawTo(function() {
          e.toViewport(q, m);
        });
        this.setOutputData(0, this._temp_texture_out);
        this._temp_texture = c;
        this._temp_texture2 = e;
      } else {
        this.setOutputData(0, this._temp_texture_out);
      }
      this.setOutputData(1, this._temp_texture2);
      this.frame++;
    }
  }, y.pixel_shader_copy = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tuniform float u_isamples;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tif( v_coord.x <= u_isamples )\n\r\n\t\t\t\tgl_FragColor = texture2D( u_texture, vec2(0.5) );\n\r\n\t\t\telse\n\r\n\t\t\t\tgl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );\n\r\n\t\t}\n\r\n\t\t", y.pixel_shader_avg = 
  "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform int u_samples;\n\r\n\t\tuniform float u_isamples;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\tfor(int i = 0; i < 64; ++i)\n\r\n\t\t\t{\n\r\n\t\t\t\tcolor += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );\n\r\n\t\t\t\tif(i == (u_samples - 1))\n\r\n\t\t\t\t\tbreak;\n\r\n\t\t\t}\n\r\n\t\t\tgl_FragColor = color * u_isamples;\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/linear_avg_smooth", y), r.title = "Image to Texture", r.desc = "Uploads an image to the GPU", r.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      var b = a.videoWidth || a.width, d = a.videoHeight || a.height;
      if (a.gltexture) {
        this.setOutputData(0, a.gltexture);
      } else {
        var f = this._temp_texture;
        f && f.width == b && f.height == d || (this._temp_texture = new GL.Texture(b, d, {format:gl.RGBA, filter:gl.LINEAR}));
        try {
          this._temp_texture.uploadImage(a);
        } catch (T) {
          console.error("image comes from an unsafe location, cannot be uploaded to webgl: " + T);
          return;
        }
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, A.registerNodeType("texture/imageToTexture", r), z.widgets_info = {texture:{widget:"texture"}, precision:{widget:"combo", values:a.MODE_VALUES}}, z.title = "LUT", z.desc = "Apply LUT to Texture", z.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var b = this.getInputData(0);
      if (this.properties.precision === a.PASS_THROUGH || !1 === this.properties.enabled) {
        this.setOutputData(0, b);
      } else {
        if (b) {
          var d = this.getInputData(1);
          d || (d = a.getTexture(this.properties.texture));
          if (d) {
            d.bind(0);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            var f = this.properties.intensity;
            this.isInputConnected(2) && (this.properties.intensity = f = this.getInputData(2));
            this._tex = a.getTargetTexture(b, this._tex, this.properties.precision);
            this._tex.drawTo(function() {
              d.bind(1);
              b.toViewport(z._shader, {u_texture:0, u_textureB:1, u_amount:f});
            });
            this.setOutputData(0, this._tex);
          } else {
            this.setOutputData(0, b);
          }
        }
      }
    }
  }, z.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tuniform float u_amount;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\t lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\r\n\t\t\t mediump float blueColor = textureColor.b * 63.0;\n\r\n\t\t\t mediump vec2 quad1;\n\r\n\t\t\t quad1.y = floor(floor(blueColor) / 8.0);\n\r\n\t\t\t quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\r\n\t\t\t mediump vec2 quad2;\n\r\n\t\t\t quad2.y = floor(ceil(blueColor) / 8.0);\n\r\n\t\t\t quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\r\n\t\t\t highp vec2 texPos1;\n\r\n\t\t\t texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\r\n\t\t\t texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\r\n\t\t\t highp vec2 texPos2;\n\r\n\t\t\t texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\r\n\t\t\t texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\r\n\t\t\t lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\r\n\t\t\t lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\r\n\t\t\t lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\r\n\t\t\t gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/LUT", z), d.title = "Texture to Channels", d.desc = "Split texture channels", d.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      this._channels || (this._channels = Array(4));
      for (var b = gl.RGB, f = 0, e = 0; 4 > e; e++) {
        this.isOutputConnected(e) ? (this._channels[e] && this._channels[e].width == a.width && this._channels[e].height == a.height && this._channels[e].type == a.type && this._channels[e].format == b || (this._channels[e] = new GL.Texture(a.width, a.height, {type:a.type, format:b, filter:gl.LINEAR})), f++) : this._channels[e] = null;
      }
      if (f) {
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var c = Mesh.getScreenQuad(), g = d._shader, q = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
        for (e = 0; 4 > e; e++) {
          this._channels[e] && (this._channels[e].drawTo(function() {
            a.bind(0);
            g.uniforms({u_texture:0, u_mask:q[e]}).draw(c);
          }), this.setOutputData(e, this._channels[e]));
        }
      }
    }
  }, d.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec4 u_mask;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\r\n\t\t}\n\r\n\t\t", A.registerNodeType("texture/textureChannels", d), e.title = "Channels to Texture", e.desc = "Split texture channels", e.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, 
  e.prototype.onExecute = function() {
    var b = a.getWhiteTexture(), d = this.getInputData(0) || b, f = this.getInputData(1) || b, c = this.getInputData(2) || b, g = this.getInputData(3) || b;
    gl.disable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
    var q = Mesh.getScreenQuad();
    e._shader || (e._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, e.pixel_shader));
    var m = e._shader;
    b = Math.max(d.width, f.width, c.width, g.width);
    var l = Math.max(d.height, f.height, c.height, g.height), h = this.properties.precision == a.HIGH ? a.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
    this._texture && this._texture.width == b && this._texture.height == l && this._texture.type == h || (this._texture = new GL.Texture(b, l, {type:h, format:gl.RGBA, filter:gl.LINEAR}));
    b = this._color;
    b[0] = this.properties.R;
    b[1] = this.properties.G;
    b[2] = this.properties.B;
    b[3] = this.properties.A;
    var B = this._uniforms;
    this._texture.drawTo(function() {
      d.bind(0);
      f.bind(1);
      c.bind(2);
      g.bind(3);
      m.uniforms(B).draw(q);
    });
    this.setOutputData(0, this._texture);
  }, e.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_textureR;\n\r\n\t\tuniform sampler2D u_textureG;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\tuniform sampler2D u_textureA;\n\r\n\t\tuniform vec4 u_color;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t   gl_FragColor = u_color * vec4( \r\n\t\t\t\t\ttexture2D(u_textureR, v_coord).r,\r\n\t\t\t\t\ttexture2D(u_textureG, v_coord).r,\r\n\t\t\t\t\ttexture2D(u_textureB, v_coord).r,\r\n\t\t\t\t\ttexture2D(u_textureA, v_coord).r);\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/channelsTexture", e), m.title = "Color", m.desc = "Generates a 1x1 texture with a constant color", m.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, m.prototype.onDrawBackground = function(a) {
    var b = this.properties.color;
    a.fillStyle = "rgb(" + Math.floor(255 * Math.clamp(b[0], 0, 1)) + "," + Math.floor(255 * Math.clamp(b[1], 0, 1)) + "," + Math.floor(255 * Math.clamp(b[2], 0, 1)) + ")";
    this.flags.collapsed ? this.boxcolor = a.fillStyle : a.fillRect(0, 0, this.size[0], this.size[1]);
  }, m.prototype.onExecute = function() {
    var b = this.properties.precision == a.HIGH ? a.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
    this._tex && this._tex.type == b || (this._tex = new GL.Texture(1, 1, {format:gl.RGBA, type:b, minFilter:gl.NEAREST}));
    b = this.properties.color;
    if (this.inputs) {
      for (var d = 0; d < this.inputs.length; d++) {
        var f = this.inputs[d], e = this.getInputData(d);
        if (void 0 !== e) {
          switch(f.name) {
            case "RGB":
            case "RGBA":
              b.set(e);
              break;
            case "R":
              b[0] = e;
              break;
            case "G":
              b[1] = e;
              break;
            case "B":
              b[2] = e;
              break;
            case "A":
              b[3] = e;
          }
        }
      }
    }
    0.001 < vec4.sqrDist(this._tex_color, b) && (this._tex_color.set(b), this._tex.fill(b));
    this.setOutputData(0, this._tex);
  }, m.prototype.onGetInputs = function() {
    return [["RGB", "vec3"], ["RGBA", "vec4"], ["R", "number"], ["G", "number"], ["B", "number"], ["A", "number"]];
  }, A.registerNodeType("texture/color", m), f.title = "Gradient", f.desc = "Generates a gradient", f["@A"] = {type:"color"}, f["@B"] = {type:"color"}, f["@texture_size"] = {type:"enum", values:[32, 64, 128, 256, 512]}, f.prototype.onExecute = function() {
    gl.disable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
    var a = GL.Mesh.getScreenQuad(), b = f._shader, d = this.getInputData(0);
    d || (d = this.properties.A);
    var e = this.getInputData(1);
    e || (e = this.properties.B);
    for (var c = 2; c < this.inputs.length; c++) {
      var g = this.inputs[c], q = this.getInputData(c);
      void 0 !== q && (this.properties[g.name] = q);
    }
    var m = this._uniforms;
    this._uniforms.u_angle = this.properties.angle * DEG2RAD;
    this._uniforms.u_scale = this.properties.scale;
    vec3.copy(m.u_colorA, d);
    vec3.copy(m.u_colorB, e);
    d = parseInt(this.properties.texture_size);
    this._tex && this._tex.width == d || (this._tex = new GL.Texture(d, d, {format:gl.RGB, filter:gl.LINEAR}));
    this._tex.drawTo(function() {
      b.uniforms(m).draw(a);
    });
    this.setOutputData(0, this._tex);
  }, f.prototype.onGetInputs = function() {
    return [["angle", "number"], ["scale", "number"]];
  }, f.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform float u_angle;\n\r\n\t\tuniform float u_scale;\n\r\n\t\tuniform vec3 u_colorA;\n\r\n\t\tuniform vec3 u_colorB;\n\r\n\t\t\n\r\n\t\tvec2 rotate(vec2 v, float angle)\n\r\n\t\t{\n\r\n\t\t\tvec2 result;\n\r\n\t\t\tfloat _cos = cos(angle);\n\r\n\t\t\tfloat _sin = sin(angle);\n\r\n\t\t\tresult.x = v.x * _cos - v.y * _sin;\n\r\n\t\t\tresult.y = v.x * _sin + v.y * _cos;\n\r\n\t\t\treturn result;\n\r\n\t\t}\n\r\n\t\tvoid main() {\n\r\n\t\t\tfloat f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\r\n\t\t\tvec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\r\n\t\t   gl_FragColor = vec4(color,1.0);\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/gradient", f), q.title = "Mix", q.desc = "Generates a texture mixing two textures", q.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, q.prototype.onExecute = function() {
    var b = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === a.PASS_THROUGH) {
        this.setOutputData(0, b);
      } else {
        var d = this.getInputData(1);
        if (b && d) {
          var f = this.getInputData(2), e = this.getInputData(3);
          this._tex = a.getTargetTexture(this.properties.size_from_biggest && d.width > b.width ? d : b, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var c = Mesh.getScreenQuad(), g = null, m = this._uniforms;
          f ? (g = q._shader_tex, g || (g = q._shader_tex = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, q.pixel_shader, {MIX_TEX:""}))) : (g = q._shader_factor, g || (g = q._shader_factor = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, q.pixel_shader)), e = null == e ? this.properties.factor : e, m.u_mix.set([e, e, e, e]));
          var l = this.properties.invert;
          this._tex.drawTo(function() {
            b.bind(l ? 1 : 0);
            d.bind(l ? 0 : 1);
            f && f.bind(2);
            g.uniforms(m).draw(c);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  }, q.prototype.onGetInputs = function() {
    return [["factor", "number"]];
  }, q.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_textureA;\n\r\n\t\tuniform sampler2D u_textureB;\n\r\n\t\t#ifdef MIX_TEX\n\r\n\t\t\tuniform sampler2D u_textureMix;\n\r\n\t\t#else\n\r\n\t\t\tuniform vec4 u_mix;\n\r\n\t\t#endif\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\t#ifdef MIX_TEX\n\r\n\t\t\t   vec4 f = texture2D(u_textureMix, v_coord);\n\r\n\t\t\t#else\n\r\n\t\t\t   vec4 f = u_mix;\n\r\n\t\t\t#endif\n\r\n\t\t   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/mix", q), B.title = "Edges", B.desc = "Detects edges", B.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, B.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var b = this.getInputData(0);
      if (this.properties.precision === a.PASS_THROUGH) {
        this.setOutputData(0, b);
      } else {
        if (b) {
          this._tex = a.getTargetTexture(b, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var d = Mesh.getScreenQuad(), f = B._shader, e = this.properties.invert, c = this.properties.factor, g = this.properties.threshold ? 1 : 0;
          this._tex.drawTo(function() {
            b.bind(0);
            f.uniforms({u_texture:0, u_isize:[1 / b.width, 1 / b.height], u_factor:c, u_threshold:g, u_invert:e ? 1 : 0}).draw(d);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  }, B.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec2 u_isize;\n\r\n\t\tuniform int u_invert;\n\r\n\t\tuniform float u_factor;\n\r\n\t\tuniform float u_threshold;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 center = texture2D(u_texture, v_coord);\n\r\n\t\t\tvec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\r\n\t\t\tvec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\r\n\t\t\tvec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\r\n\t\t\tvec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\r\n\t\t\tvec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\r\n\t\t\tdiff *= u_factor;\n\r\n\t\t\tif(u_invert == 1)\n\r\n\t\t\t\tdiff.xyz = vec3(1.0) - diff.xyz;\n\r\n\t\t\tif( u_threshold == 0.0 )\n\r\n\t\t\t\tgl_FragColor = vec4( diff.xyz, center.a );\n\r\n\t\t\telse\n\r\n\t\t\t\tgl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/edges", B), F.title = "Depth Range", F.desc = "Generates a texture with a depth range", F.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (a) {
        var b = gl.UNSIGNED_BYTE;
        this.properties.high_precision && (b = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
        this._temp_texture && this._temp_texture.type == b && this._temp_texture.width == a.width && this._temp_texture.height == a.height || (this._temp_texture = new GL.Texture(a.width, a.height, {type:b, format:gl.RGBA, filter:gl.LINEAR}));
        var d = this._uniforms;
        b = this.properties.distance;
        this.isInputConnected(1) && (b = this.getInputData(1), this.properties.distance = b);
        var f = this.properties.range;
        this.isInputConnected(2) && (f = this.getInputData(2), this.properties.range = f);
        d.u_distance = b;
        d.u_range = f;
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var e = Mesh.getScreenQuad();
        F._shader || (F._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, F.pixel_shader), F._shader_onlydepth = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, F.pixel_shader, {ONLY_DEPTH:""}));
        var c = this.properties.only_depth ? F._shader_onlydepth : F._shader;
        b = null;
        b = a.near_far_planes ? a.near_far_planes : window.LS && LS.Renderer._main_camera ? LS.Renderer._main_camera._uniforms.u_camera_planes : [0.1, 1000];
        d.u_camera_planes = b;
        this._temp_texture.drawTo(function() {
          a.bind(0);
          c.uniforms(d).draw(e);
        });
        this._temp_texture.near_far_planes = b;
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, F.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec2 u_camera_planes;\n\r\n\t\tuniform float u_distance;\n\r\n\t\tuniform float u_range;\n\r\n\t\t\n\r\n\t\tfloat LinearDepth()\n\r\n\t\t{\n\r\n\t\t\tfloat zNear = u_camera_planes.x;\n\r\n\t\t\tfloat zFar = u_camera_planes.y;\n\r\n\t\t\tfloat depth = texture2D(u_texture, v_coord).x;\n\r\n\t\t\tdepth = depth * 2.0 - 1.0;\n\r\n\t\t\treturn zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tfloat depth = LinearDepth();\n\r\n\t\t\t#ifdef ONLY_DEPTH\n\r\n\t\t\t   gl_FragColor = vec4(depth);\n\r\n\t\t\t#else\n\r\n\t\t\t\tfloat diff = abs(depth * u_camera_planes.y - u_distance);\n\r\n\t\t\t\tfloat dof = 1.0;\n\r\n\t\t\t\tif(diff <= u_range)\n\r\n\t\t\t\t\tdof = diff / u_range;\n\r\n\t\t\t   gl_FragColor = vec4(dof);\n\r\n\t\t\t#endif\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/depth_range", F), G.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, G.title = "Linear Depth", G.desc = "Creates a color texture with linear depth", G.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var b = this.getInputData(0);
      if (b && (b.format == gl.DEPTH_COMPONENT || b.format == gl.DEPTH_STENCIL)) {
        var d = this.properties.precision == a.HIGH ? gl.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
        this._temp_texture && this._temp_texture.type == d && this._temp_texture.width == b.width && this._temp_texture.height == b.height || (this._temp_texture = new GL.Texture(b.width, b.height, {type:d, format:gl.RGB, filter:gl.LINEAR}));
        var f = this._uniforms;
        f.u_near = b.near_far_planes[0];
        f.u_far = b.near_far_planes[1];
        f.u_invert = this.properties.invert ? 1 : 0;
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var e = Mesh.getScreenQuad();
        G._shader || (G._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, G.pixel_shader));
        var c = G._shader;
        d = null;
        d = b.near_far_planes ? b.near_far_planes : window.LS && LS.Renderer._main_camera ? LS.Renderer._main_camera._uniforms.u_camera_planes : [0.1, 1000];
        f.u_camera_planes = d;
        this._temp_texture.drawTo(function() {
          b.bind(0);
          c.uniforms(f).draw(e);
        });
        this._temp_texture.near_far_planes = d;
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, G.pixel_shader = "precision highp float;\n\r\n\t\tprecision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_near;\n\r\n\t\tuniform float u_far;\n\r\n\t\tuniform int u_invert;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tfloat zNear = u_near;\n\r\n\t\t\tfloat zFar = u_far;\n\r\n\t\t\tfloat depth = texture2D(u_texture, v_coord).x;\n\r\n\t\t\tdepth = depth * 2.0 - 1.0;\n\r\n\t\t\tfloat f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\r\n\t\t\tif( u_invert == 1 )\n\r\n\t\t\t\tf = 1.0 - f;\n\r\n\t\t\tgl_FragColor = vec4(vec3(f),1.0);\n\r\n\t\t}\n\r\n\t\t", 
  A.registerNodeType("texture/linear_depth", G), P.title = "Blur", P.desc = "Blur a texture", P.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, P.max_iterations = 20, P.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._final_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._final_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      var d = this.properties.iterations;
      this.isInputConnected(1) && (d = this.getInputData(1), this.properties.iterations = d);
      d = Math.min(Math.floor(d), P.max_iterations);
      if (0 == d) {
        this.setOutputData(0, a);
      } else {
        var f = this.properties.intensity;
        this.isInputConnected(2) && (f = this.getInputData(2), this.properties.intensity = f);
        var e = A.camera_aspect;
        e || void 0 === window.gl || (e = gl.canvas.height / gl.canvas.width);
        e || (e = 1);
        e = this.properties.preserve_aspect ? e : 1;
        var c = this.properties.scale || [1, 1];
        a.applyBlur(e * c[0], c[1], f, b);
        for (a = 1; a < d; ++a) {
          b.applyBlur(e * c[0] * (a + 1), c[1] * (a + 1), f);
        }
        this.setOutputData(0, b);
      }
    }
  }, A.registerNodeType("texture/blur", P), D.title = "Glow", D.desc = "Filters a texture giving it a glow effect", D.weights = new Float32Array([0.5, 0.4, 0.3, 0.2]), D.widgets_info = {iterations:{type:"number", min:0, max:16, step:1, precision:0}, threshold:{type:"number", min:0, max:10, step:0.01, precision:2}, precision:{widget:"combo", values:a.MODE_VALUES}}, D.prototype.onGetInputs = function() {
    return [["enabled", "boolean"], ["threshold", "number"], ["intensity", "number"], ["persistence", "number"], ["iterations", "number"], ["dirt_factor", "number"]];
  }, D.prototype.onGetOutputs = function() {
    return [["average", "Texture"]];
  }, D.prototype.onExecute = function() {
    var b = this.getInputData(0);
    if (b && this.isAnyOutputConnected()) {
      if (this.properties.precision === a.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
        this.setOutputData(0, b);
      } else {
        var d = b.width, f = b.height, e = {format:b.format, type:b.type, minFilter:GL.LINEAR, magFilter:GL.LINEAR, wrap:gl.CLAMP_TO_EDGE}, c = a.getTextureType(this.properties.precision, b), g = this._uniforms, q = this._textures, m = D._cut_shader;
        m || (m = D._cut_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, D.cut_pixel_shader));
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        g.u_threshold = this.getInputOrProperty("threshold");
        var l = q[0] = GL.Texture.getTemporary(d, f, e);
        b.blit(l, m.uniforms(g));
        var h = l, B = this.getInputOrProperty("iterations");
        B = Math.clamp(B, 1, 16) | 0;
        var p = g.u_texel_size, x = this.getInputOrProperty("intensity");
        g.u_intensity = 1;
        g.u_delta = this.properties.scale;
        m = D._shader;
        m || (m = D._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, D.scale_pixel_shader));
        for (var n = 1; n < B; n++) {
          d >>= 1;
          1 < (f | 0) && (f >>= 1);
          if (2 > d) {
            break;
          }
          l = q[n] = GL.Texture.getTemporary(d, f, e);
          p[0] = 1 / h.width;
          p[1] = 1 / h.height;
          h.blit(l, m.uniforms(g));
          h = l;
        }
        this.isOutputConnected(2) && (d = this._average_texture, d && d.type == b.type && d.format == b.format || (d = this._average_texture = new GL.Texture(1, 1, {type:b.type, format:b.format, filter:gl.LINEAR})), p[0] = 1 / h.width, p[1] = 1 / h.height, g.u_intensity = x, g.u_delta = 1, h.blit(d, m.uniforms(g)), this.setOutputData(2, d));
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        g.u_intensity = this.getInputOrProperty("persistence");
        g.u_delta = 0.5;
        for (n -= 2; 0 <= n; n--) {
          l = q[n], q[n] = null, p[0] = 1 / h.width, p[1] = 1 / h.height, h.blit(l, m.uniforms(g)), GL.Texture.releaseTemporary(h), h = l;
        }
        gl.disable(gl.BLEND);
        this.isOutputConnected(1) && (q = this._glow_texture, q && q.width == b.width && q.height == b.height && q.type == c && q.format == b.format || (q = this._glow_texture = new GL.Texture(b.width, b.height, {type:c, format:b.format, filter:gl.LINEAR})), h.blit(q), this.setOutputData(1, q));
        if (this.isOutputConnected(0)) {
          q = this._final_texture;
          q && q.width == b.width && q.height == b.height && q.type == c && q.format == b.format || (q = this._final_texture = new GL.Texture(b.width, b.height, {type:c, format:b.format, filter:gl.LINEAR}));
          var v = this.getInputData(1), r = this.getInputOrProperty("dirt_factor");
          g.u_intensity = x;
          m = v ? D._dirt_final_shader : D._final_shader;
          m || (m = v ? D._dirt_final_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, D.final_pixel_shader, {USE_DIRT:""}) : D._final_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, D.final_pixel_shader));
          q.drawTo(function() {
            b.bind(0);
            h.bind(1);
            v && (m.setUniform("u_dirt_factor", r), m.setUniform("u_dirt_texture", v.bind(2)));
            m.toViewport(g);
          });
          this.setOutputData(0, q);
        }
        GL.Texture.releaseTemporary(h);
      }
    }
  }, D.cut_pixel_shader = "precision highp float;\n\r\n\tvarying vec2 v_coord;\n\r\n\tuniform sampler2D u_texture;\n\r\n\tuniform float u_threshold;\n\r\n\tvoid main() {\n\r\n\t\tgl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\n\r\n\t}", D.scale_pixel_shader = "precision highp float;\n\r\n\tvarying vec2 v_coord;\n\r\n\tuniform sampler2D u_texture;\n\r\n\tuniform vec2 u_texel_size;\n\r\n\tuniform float u_delta;\n\r\n\tuniform float u_intensity;\n\r\n\t\n\r\n\tvec4 sampleBox(vec2 uv) {\n\r\n\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\r\n\t\tvec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\n\r\n\t\treturn s * 0.25;\n\r\n\t}\n\r\n\tvoid main() {\n\r\n\t\tgl_FragColor = u_intensity * sampleBox( v_coord );\n\r\n\t}", 
  D.final_pixel_shader = "precision highp float;\n\r\n\tvarying vec2 v_coord;\n\r\n\tuniform sampler2D u_texture;\n\r\n\tuniform sampler2D u_glow_texture;\n\r\n\t#ifdef USE_DIRT\n\r\n\t\tuniform sampler2D u_dirt_texture;\n\r\n\t#endif\n\r\n\tuniform vec2 u_texel_size;\n\r\n\tuniform float u_delta;\n\r\n\tuniform float u_intensity;\n\r\n\tuniform float u_dirt_factor;\n\r\n\t\n\r\n\tvec4 sampleBox(vec2 uv) {\n\r\n\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\r\n\t\tvec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\n\r\n\t\treturn s * 0.25;\n\r\n\t}\n\r\n\tvoid main() {\n\r\n\t\tvec4 glow = sampleBox( v_coord );\n\r\n\t\t#ifdef USE_DIRT\n\r\n\t\t\tglow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\n\r\n\t\t#endif\n\r\n\t\tgl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\n\r\n\t}", 
  A.registerNodeType("texture/glow", D), I.title = "Kuwahara Filter", I.desc = "Filters a texture giving an artistic oil canvas painting", I.max_radius = 10, I._shaders = [], I.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      b = this.properties.radius;
      b = Math.min(Math.floor(b), I.max_radius);
      if (0 == b) {
        this.setOutputData(0, a);
      } else {
        var d = this.properties.intensity, f = A.camera_aspect;
        f || void 0 === window.gl || (f = gl.canvas.height / gl.canvas.width);
        f || (f = 1);
        f = this.properties.preserve_aspect ? f : 1;
        I._shaders[b] || (I._shaders[b] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, I.pixel_shader, {RADIUS:b.toFixed(0)}));
        var e = I._shaders[b], c = GL.Mesh.getScreenQuad();
        a.bind(0);
        this._temp_texture.drawTo(function() {
          e.uniforms({u_texture:0, u_intensity:d, u_resolution:[a.width, a.height], u_iResolution:[1 / a.width, 1 / a.height]}).draw(c);
        });
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, I.pixel_shader = "\n\r\nprecision highp float;\n\r\nvarying vec2 v_coord;\n\r\nuniform sampler2D u_texture;\n\r\nuniform float u_intensity;\n\r\nuniform vec2 u_resolution;\n\r\nuniform vec2 u_iResolution;\n\r\n#ifndef RADIUS\n\r\n\t#define RADIUS 7\n\r\n#endif\n\r\nvoid main() {\n\r\n\n\r\n\tconst int radius = RADIUS;\n\r\n\tvec2 fragCoord = v_coord;\n\r\n\tvec2 src_size = u_iResolution;\n\r\n\tvec2 uv = v_coord;\n\r\n\tfloat n = float((radius + 1) * (radius + 1));\n\r\n\tint i;\n\r\n\tint j;\n\r\n\tvec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\r\n\tvec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\r\n\tvec3 c;\n\r\n\t\n\r\n\tfor (int j = -radius; j <= 0; ++j)  {\n\r\n\t\tfor (int i = -radius; i <= 0; ++i)  {\n\r\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\tm0 += c;\n\r\n\t\t\ts0 += c * c;\n\r\n\t\t}\n\r\n\t}\n\r\n\t\n\r\n\tfor (int j = -radius; j <= 0; ++j)  {\n\r\n\t\tfor (int i = 0; i <= radius; ++i)  {\n\r\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\tm1 += c;\n\r\n\t\t\ts1 += c * c;\n\r\n\t\t}\n\r\n\t}\n\r\n\t\n\r\n\tfor (int j = 0; j <= radius; ++j)  {\n\r\n\t\tfor (int i = 0; i <= radius; ++i)  {\n\r\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\tm2 += c;\n\r\n\t\t\ts2 += c * c;\n\r\n\t\t}\n\r\n\t}\n\r\n\t\n\r\n\tfor (int j = 0; j <= radius; ++j)  {\n\r\n\t\tfor (int i = -radius; i <= 0; ++i)  {\n\r\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\tm3 += c;\n\r\n\t\t\ts3 += c * c;\n\r\n\t\t}\n\r\n\t}\n\r\n\t\n\r\n\tfloat min_sigma2 = 1e+2;\n\r\n\tm0 /= n;\n\r\n\ts0 = abs(s0 / n - m0 * m0);\n\r\n\t\n\r\n\tfloat sigma2 = s0.r + s0.g + s0.b;\n\r\n\tif (sigma2 < min_sigma2) {\n\r\n\t\tmin_sigma2 = sigma2;\n\r\n\t\tgl_FragColor = vec4(m0, 1.0);\n\r\n\t}\n\r\n\t\n\r\n\tm1 /= n;\n\r\n\ts1 = abs(s1 / n - m1 * m1);\n\r\n\t\n\r\n\tsigma2 = s1.r + s1.g + s1.b;\n\r\n\tif (sigma2 < min_sigma2) {\n\r\n\t\tmin_sigma2 = sigma2;\n\r\n\t\tgl_FragColor = vec4(m1, 1.0);\n\r\n\t}\n\r\n\t\n\r\n\tm2 /= n;\n\r\n\ts2 = abs(s2 / n - m2 * m2);\n\r\n\t\n\r\n\tsigma2 = s2.r + s2.g + s2.b;\n\r\n\tif (sigma2 < min_sigma2) {\n\r\n\t\tmin_sigma2 = sigma2;\n\r\n\t\tgl_FragColor = vec4(m2, 1.0);\n\r\n\t}\n\r\n\t\n\r\n\tm3 /= n;\n\r\n\ts3 = abs(s3 / n - m3 * m3);\n\r\n\t\n\r\n\tsigma2 = s3.r + s3.g + s3.b;\n\r\n\tif (sigma2 < min_sigma2) {\n\r\n\t\tmin_sigma2 = sigma2;\n\r\n\t\tgl_FragColor = vec4(m3, 1.0);\n\r\n\t}\n\r\n}\n\r\n", 
  A.registerNodeType("texture/kuwahara", I), J.title = "XDoG Filter", J.desc = "Filters a texture giving an artistic ink style", J.max_radius = 10, J._shaders = [], J.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      J._xdog_shader || (J._xdog_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, J.xdog_pixel_shader));
      var d = J._xdog_shader, f = GL.Mesh.getScreenQuad(), e = this.properties.sigma, c = this.properties.k, g = this.properties.p, q = this.properties.epsilon, m = this.properties.phi;
      a.bind(0);
      this._temp_texture.drawTo(function() {
        d.uniforms({src:0, sigma:e, k:c, p:g, epsilon:q, phi:m, cvsWidth:a.width, cvsHeight:a.height}).draw(f);
      });
      this.setOutputData(0, this._temp_texture);
    }
  }, J.xdog_pixel_shader = "\n\r\nprecision highp float;\n\r\nuniform sampler2D src;\n\n\r\nuniform float cvsHeight;\n\r\nuniform float cvsWidth;\n\n\r\nuniform float sigma;\n\r\nuniform float k;\n\r\nuniform float p;\n\r\nuniform float epsilon;\n\r\nuniform float phi;\n\r\nvarying vec2 v_coord;\n\n\r\nfloat cosh(float val)\n\r\n{\n\r\n\tfloat tmp = exp(val);\n\r\n\tfloat cosH = (tmp + 1.0 / tmp) / 2.0;\n\r\n\treturn cosH;\n\r\n}\n\n\r\nfloat tanh(float val)\n\r\n{\n\r\n\tfloat tmp = exp(val);\n\r\n\tfloat tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n\r\n\treturn tanH;\n\r\n}\n\n\r\nfloat sinh(float val)\n\r\n{\n\r\n\tfloat tmp = exp(val);\n\r\n\tfloat sinH = (tmp - 1.0 / tmp) / 2.0;\n\r\n\treturn sinH;\n\r\n}\n\n\r\nvoid main(void){\n\r\n\tvec3 destColor = vec3(0.0);\n\r\n\tfloat tFrag = 1.0 / cvsHeight;\n\r\n\tfloat sFrag = 1.0 / cvsWidth;\n\r\n\tvec2 Frag = vec2(sFrag,tFrag);\n\r\n\tvec2 uv = gl_FragCoord.st;\n\r\n\tfloat twoSigmaESquared = 2.0 * sigma * sigma;\n\r\n\tfloat twoSigmaRSquared = twoSigmaESquared * k * k;\n\r\n\tint halfWidth = int(ceil( 1.0 * sigma * k ));\n\n\r\n\tconst int MAX_NUM_ITERATION = 99999;\n\r\n\tvec2 sum = vec2(0.0);\n\r\n\tvec2 norm = vec2(0.0);\n\n\r\n\tfor(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){\n\r\n\t\tif(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}\n\r\n\t\tint i = int(cnt / (2*halfWidth+1)) - halfWidth;\n\r\n\t\tint j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);\n\n\r\n\t\tfloat d = length(vec2(i,j));\n\r\n\t\tvec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), \n\r\n\t\t\t\t\t\t\texp( -d * d / twoSigmaRSquared ));\n\n\r\n\t\tvec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;\n\n\r\n\t\tnorm += kernel;\n\r\n\t\tsum += kernel * L;\n\r\n\t}\n\n\r\n\tsum /= norm;\n\n\r\n\tfloat H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);\n\r\n\tfloat edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));\n\r\n\tdestColor = vec3(edge);\n\r\n\tgl_FragColor = vec4(destColor, 1.0);\n\r\n}", 
  A.registerNodeType("texture/xDoG", J), E.title = "Webcam", E.desc = "Webcam texture", E.is_webcam_open = !1, E.prototype.openStream = function() {
    if (navigator.getUserMedia) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!1, video:{facingMode:this.properties.facingMode}}).then(this.streamReady.bind(this)).catch(function(b) {
        E.is_webcam_open = !1;
        console.log("Webcam rejected", b);
        a._webcam_stream = !1;
        a.boxcolor = "red";
        a.trigger("stream_error");
      });
      var a = this;
    }
  }, E.prototype.closeStream = function() {
    if (this._webcam_stream) {
      var a = this._webcam_stream.getTracks();
      if (a.length) {
        for (var b = 0; b < a.length; ++b) {
          a[b].stop();
        }
      }
      E.is_webcam_open = !1;
      this._video = this._webcam_stream = null;
      this.boxcolor = "black";
      this.trigger("stream_closed");
    }
  }, E.prototype.streamReady = function(a) {
    this._webcam_stream = a;
    this.boxcolor = "green";
    var b = this._video;
    b || (b = document.createElement("video"), b.autoplay = !0, b.srcObject = a, this._video = b, b.onloadedmetadata = function(a) {
      E.is_webcam_open = !0;
      console.log(a);
    });
    this.trigger("stream_ready", b);
  }, E.prototype.onPropertyChanged = function(a, b) {
    "facingMode" == a && (this.properties.facingMode = b, this.closeStream(), this.openStream());
  }, E.prototype.onRemoved = function() {
    if (this._webcam_stream) {
      var a = this._webcam_stream.getTracks();
      if (a.length) {
        for (var b = 0; b < a.length; ++b) {
          a[b].stop();
        }
      }
      this._video = this._webcam_stream = null;
    }
  }, E.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || 20 >= this.size[1] || !this._video || (a.save(), a.webgl ? this._video_texture && a.drawImage(this._video_texture, 0, 0, this.size[0], this.size[1]) : a.drawImage(this._video, 0, 0, this.size[0], this.size[1]), a.restore());
  }, E.prototype.onExecute = function() {
    null != this._webcam_stream || this._waiting_confirmation || this.openStream();
    if (this._video && this._video.videoWidth) {
      var b = this._video.videoWidth, d = this._video.videoHeight, f = this._video_texture;
      f && f.width == b && f.height == d || (this._video_texture = new GL.Texture(b, d, {format:gl.RGB, filter:gl.LINEAR}));
      this._video_texture.uploadImage(this._video);
      this._video_texture.version = ++this.version;
      this.properties.texture_name && (a.getTexturesContainer()[this.properties.texture_name] = this._video_texture);
      this.setOutputData(0, this._video_texture);
      for (b = 1; b < this.outputs.length; ++b) {
        if (this.outputs[b]) {
          switch(this.outputs[b].name) {
            case "width":
              this.setOutputData(b, this._video.videoWidth);
              break;
            case "height":
              this.setOutputData(b, this._video.videoHeight);
          }
        }
      }
    }
  }, E.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["stream_ready", A.EVENT], ["stream_closed", A.EVENT], ["stream_error", A.EVENT]];
  }, A.registerNodeType("texture/webcam", E), K.title = "Lens FX", K.desc = "distortion and chromatic aberration", K.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}}, K.prototype.onGetInputs = function() {
    return [["enabled", "boolean"]];
  }, K.prototype.onExecute = function() {
    var b = this.getInputData(0);
    if (b && this.isOutputConnected(0)) {
      if (this.properties.precision === a.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
        this.setOutputData(0, b);
      } else {
        var d = this._temp_texture;
        d && d.width == b.width && d.height == b.height && d.type == b.type || (d = this._temp_texture = new GL.Texture(b.width, b.height, {type:b.type, format:gl.RGBA, filter:gl.LINEAR}));
        var f = K._shader;
        f || (f = K._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, K.pixel_shader));
        var e = this.getInputData(1);
        null == e && (e = this.properties.factor);
        var c = this._uniforms;
        c.u_factor = e;
        gl.disable(gl.DEPTH_TEST);
        d.drawTo(function() {
          b.bind(0);
          f.uniforms(c).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, d);
      }
    }
  }, K.pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_factor;\n\r\n\t\tvec2 barrelDistortion(vec2 coord, float amt) {\n\r\n\t\t\tvec2 cc = coord - 0.5;\n\r\n\t\t\tfloat dist = dot(cc, cc);\n\r\n\t\t\treturn coord + cc * dist * amt;\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfloat sat( float t )\n\r\n\t\t{\n\r\n\t\t\treturn clamp( t, 0.0, 1.0 );\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfloat linterp( float t ) {\n\r\n\t\t\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfloat remap( float t, float a, float b ) {\n\r\n\t\t\treturn sat( (t - a) / (b - a) );\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tvec4 spectrum_offset( float t ) {\n\r\n\t\t\tvec4 ret;\n\r\n\t\t\tfloat lo = step(t,0.5);\n\r\n\t\t\tfloat hi = 1.0-lo;\n\r\n\t\t\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\r\n\t\t\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\r\n\t\t\n\r\n\t\t\treturn pow( ret, vec4(1.0/2.2) );\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tconst float max_distort = 2.2;\n\r\n\t\tconst int num_iter = 12;\n\r\n\t\tconst float reci_num_iter_f = 1.0 / float(num_iter);\n\r\n\t\t\n\r\n\t\tvoid main()\n\r\n\t\t{\t\n\r\n\t\t\tvec2 uv=v_coord;\n\r\n\t\t\tvec4 sumcol = vec4(0.0);\n\r\n\t\t\tvec4 sumw = vec4(0.0);\t\n\r\n\t\t\tfor ( int i=0; i<num_iter;++i )\n\r\n\t\t\t{\n\r\n\t\t\t\tfloat t = float(i) * reci_num_iter_f;\n\r\n\t\t\t\tvec4 w = spectrum_offset( t );\n\r\n\t\t\t\tsumw += w;\n\r\n\t\t\t\tsumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\n\r\n\t\t\t}\n\r\n\t\t\tgl_FragColor = sumcol / sumw;\n\r\n\t\t}", 
  A.registerNodeType("texture/lensfx", K), t.title = "Curve", t.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      var d = t._shader;
      d || (d = t._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, t.pixel_shader));
      !this._must_update && this._curve_texture || this.updateCurve();
      var f = this._uniforms, e = this._curve_texture;
      b.drawTo(function() {
        gl.disable(gl.DEPTH_TEST);
        a.bind(0);
        e.bind(1);
        d.uniforms(f).draw(GL.Mesh.getScreenQuad());
      });
      this.setOutputData(0, b);
    }
  }, t.prototype.sampleCurve = function(a, b) {
    if (b = b || this._points.RGB) {
      for (var d = 0; d < b.length - 1; ++d) {
        var f = b[d], e = b[d + 1];
        if (!(e[0] < a)) {
          b = e[0] - f[0];
          if (0.00001 > Math.abs(b)) {
            return f[1];
          }
          a = (a - f[0]) / b;
          return f[1] * (1.0 - a) + e[1] * a;
        }
      }
      return 0;
    }
  }, t.prototype.updateCurve = function() {
    for (var a = this._values, b = a.length / 4, d = this.properties.split_channels, f = 0; f < b; ++f) {
      if (d) {
        a[4 * f] = Math.clamp(255 * this.sampleCurve(f / b, this._points.R), 0, 255), a[4 * f + 1] = Math.clamp(255 * this.sampleCurve(f / b, this._points.G), 0, 255), a[4 * f + 2] = Math.clamp(255 * this.sampleCurve(f / b, this._points.B), 0, 255);
      } else {
        var e = this.sampleCurve(f / b);
        a[4 * f] = a[4 * f + 1] = a[4 * f + 2] = Math.clamp(255 * e, 0, 255);
      }
      a[4 * f + 3] = 255;
    }
    this._curve_texture || (this._curve_texture = new GL.Texture(256, 1, {format:gl.RGBA, magFilter:gl.LINEAR, wrap:gl.CLAMP_TO_EDGE}));
    this._curve_texture.uploadData(a, null, !0);
  }, t.prototype.onSerialize = function(a) {
    var b = {}, d;
    for (d in this._points) {
      b[d] = this._points[d].concat();
    }
    a.curves = b;
  }, t.prototype.onConfigure = function(a) {
    this._points = a.curves;
    this.curve_editor && (curve_editor.points = this._points);
    this._must_update = !0;
  }, t.prototype.onMouseDown = function(a, b, d) {
    if (this.curve_editor) {
      return (a = this.curve_editor.onMouseDown([b[0], b[1] - this.curve_offset], d)) && this.captureInput(!0), a;
    }
  }, t.prototype.onMouseMove = function(a, b, d) {
    if (this.curve_editor) {
      return this.curve_editor.onMouseMove([b[0], b[1] - this.curve_offset], d);
    }
  }, t.prototype.onMouseUp = function(a, b, d) {
    if (this.curve_editor) {
      return this.curve_editor.onMouseUp([b[0], b[1] - this.curve_offset], d);
    }
    this.captureInput(!1);
  }, t.channel_line_colors = {RGB:"#666", R:"#F33", G:"#3F3", B:"#33F"}, t.prototype.onDrawBackground = function(a, b) {
    if (!this.flags.collapsed) {
      this.curve_editor || (this.curve_editor = new A.CurveEditor(this._points.R));
      a.save();
      a.translate(0, this.curve_offset);
      var d = this.widgets[1].value;
      this.properties.split_channels ? ("RGB" == d && (this.widgets[1].value = d = "R", this.widgets[1].disabled = !1), this.curve_editor.points = this._points.R, this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, "#111", t.channel_line_colors.R, !0), a.globalCompositeOperation = "lighten", this.curve_editor.points = this._points.G, this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, null, t.channel_line_colors.G, !0), this.curve_editor.points = 
      this._points.B, this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, null, t.channel_line_colors.B, !0), a.globalCompositeOperation = "source-over") : (this.widgets[1].value = d = "RGB", this.widgets[1].disabled = !0);
      this.curve_editor.points = this._points[d];
      this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, this.properties.split_channels ? null : "#111", t.channel_line_colors[d]);
      a.restore();
    }
  }, t.pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_curve;\n\r\n\t\tuniform float u_range;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = texture2D( u_texture, v_coord ) * u_range;\n\r\n\t\t\tcolor.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;\n\r\n\t\t\tcolor.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;\n\r\n\t\t\tcolor.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;\n\r\n\t\t\t//color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;\n\r\n\t\t\tgl_FragColor = color;\n\r\n\t\t}", 
  A.registerNodeType("texture/curve", t), M.title = "Exposition", M.desc = "Controls texture exposition", M.widgets_info = {exposition:{widget:"slider", min:0, max:3}, precision:{widget:"combo", values:a.MODE_VALUES}}, M.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      var d = M._shader;
      d || (d = M._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, M.pixel_shader));
      var f = this.getInputData(1);
      null != f && (this.properties.exposition = f);
      var e = this._uniforms;
      b.drawTo(function() {
        gl.disable(gl.DEPTH_TEST);
        a.bind(0);
        d.uniforms(e).draw(GL.Mesh.getScreenQuad());
      });
      this.setOutputData(0, b);
    }
  }, M.pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_exposition;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = texture2D( u_texture, v_coord );\n\r\n\t\t\tgl_FragColor = vec4( color.xyz * u_exposition, color.a );\n\r\n\t\t}", A.registerNodeType("texture/exposition", M), H.title = "Tone Mapping", H.desc = "Applies Tone Mapping to convert from high to low", H.widgets_info = {precision:{widget:"combo", 
  values:a.MODE_VALUES}}, H.prototype.onGetInputs = function() {
    return [["enabled", "boolean"]];
  }, H.prototype.onExecute = function() {
    var b = this.getInputData(0);
    if (b && this.isOutputConnected(0)) {
      if (this.properties.precision === a.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
        this.setOutputData(0, b);
      } else {
        var d = this._temp_texture;
        d && d.width == b.width && d.height == b.height && d.type == b.type || (d = this._temp_texture = new GL.Texture(b.width, b.height, {type:b.type, format:gl.RGBA, filter:gl.LINEAR}));
        var f = this.getInputData(1);
        null == f && (f = this.properties.average_lum);
        var e = this._uniforms, c = null;
        f.constructor === Number ? (this.properties.average_lum = f, e.u_average_lum = this.properties.average_lum, c = H._shader, c || (c = H._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, H.pixel_shader))) : f.constructor === GL.Texture && (e.u_average_texture = f.bind(1), c = H._shader_texture, c || (c = H._shader_texture = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, H.pixel_shader, {AVG_TEXTURE:""})));
        e.u_lumwhite2 = this.properties.lum_white * this.properties.lum_white;
        e.u_scale = this.properties.scale;
        e.u_igamma = 1 / this.properties.gamma;
        gl.disable(gl.DEPTH_TEST);
        d.drawTo(function() {
          b.bind(0);
          c.uniforms(e).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, H.pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_scale;\n\r\n\t\t#ifdef AVG_TEXTURE\n\r\n\t\t\tuniform sampler2D u_average_texture;\n\r\n\t\t#else\n\r\n\t\t\tuniform float u_average_lum;\n\r\n\t\t#endif\n\r\n\t\tuniform float u_lumwhite2;\n\r\n\t\tuniform float u_igamma;\n\r\n\t\tvec3 RGB2xyY (vec3 rgb)\n\r\n\t\t{\n\r\n\t\t\t const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\n\r\n\t\t\t\t\t\t\t\t\t   0.2126, 0.7152, 0.0722,\n\r\n\t\t\t\t\t\t\t\t\t   0.0193, 0.1192, 0.9505);\n\r\n\t\t\tvec3 XYZ = RGB2XYZ * rgb;\n\r\n\t\t\t\n\r\n\t\t\tfloat f = (XYZ.x + XYZ.y + XYZ.z);\n\r\n\t\t\treturn vec3(XYZ.x / f,\n\r\n\t\t\t\t\t\tXYZ.y / f,\n\r\n\t\t\t\t\t\tXYZ.y);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = texture2D( u_texture, v_coord );\n\r\n\t\t\tvec3 rgb = color.xyz;\n\r\n\t\t\tfloat average_lum = 0.0;\n\r\n\t\t\t#ifdef AVG_TEXTURE\n\r\n\t\t\t\tvec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;\n\r\n\t\t\t\taverage_lum = (pixel.x + pixel.y + pixel.z) / 3.0;\n\r\n\t\t\t#else\n\r\n\t\t\t\taverage_lum = u_average_lum;\n\r\n\t\t\t#endif\n\r\n\t\t\t//Ld - this part of the code is the same for both versions\n\r\n\t\t\tfloat lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n\r\n\t\t\tfloat L = (u_scale / average_lum) * lum;\n\r\n\t\t\tfloat Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\n\r\n\t\t\t//first\n\r\n\t\t\t//vec3 xyY = RGB2xyY(rgb);\n\r\n\t\t\t//xyY.z *= Ld;\n\r\n\t\t\t//rgb = xyYtoRGB(xyY);\n\r\n\t\t\t//second\n\r\n\t\t\trgb = (rgb / lum) * Ld;\n\r\n\t\t\trgb = max(rgb,vec3(0.001));\n\r\n\t\t\trgb = pow( rgb, vec3( u_igamma ) );\n\r\n\t\t\tgl_FragColor = vec4( rgb, color.a );\n\r\n\t\t}", 
  A.registerNodeType("texture/tonemapping", H), L.title = "Perlin", L.desc = "Generates a perlin noise texture", L.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}, width:{type:"Number", precision:0, step:1}, height:{type:"Number", precision:0, step:1}, octaves:{type:"Number", precision:0, step:1, min:1, max:50}}, L.prototype.onGetInputs = function() {
    return [["seed", "Number"], ["persistence", "Number"], ["octaves", "Number"], ["scale", "Number"], ["amplitude", "Number"], ["offset", "vec2"]];
  }, L.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var b = this.properties.width | 0, d = this.properties.height | 0;
      0 == b && (b = gl.viewport_data[2]);
      0 == d && (d = gl.viewport_data[3]);
      var f = a.getTextureType(this.properties.precision), e = this._texture;
      e && e.width == b && e.height == d && e.type == f || (e = this._texture = new GL.Texture(b, d, {type:f, format:gl.RGB, filter:gl.LINEAR}));
      var c = this.getInputOrProperty("persistence"), g = this.getInputOrProperty("octaves"), q = this.getInputOrProperty("offset"), m = this.getInputOrProperty("scale"), l = this.getInputOrProperty("amplitude"), h = this.getInputOrProperty("seed");
      f = "" + b + d + f + c + g + m + h + q[0] + q[1] + l;
      if (f != this._key) {
        this._key = f;
        var B = this._uniforms;
        B.u_persistence = c;
        B.u_octaves = g;
        B.u_offset.set(q);
        B.u_scale = m;
        B.u_amplitude = l;
        B.u_seed = 128 * h;
        B.u_viewport[0] = b;
        B.u_viewport[1] = d;
        var p = L._shader;
        p || (p = L._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, L.pixel_shader));
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        e.drawTo(function() {
          p.uniforms(B).draw(GL.Mesh.getScreenQuad());
        });
      }
      this.setOutputData(0, e);
    }
  }, L.pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform vec2 u_offset;\n\r\n\t\tuniform float u_scale;\n\r\n\t\tuniform float u_persistence;\n\r\n\t\tuniform int u_octaves;\n\r\n\t\tuniform float u_amplitude;\n\r\n\t\tuniform vec2 u_viewport;\n\r\n\t\tuniform float u_seed;\n\r\n\t\t#define M_PI 3.14159265358979323846\n\r\n\t\t\n\r\n\t\tfloat rand(vec2 c){\treturn fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\n\r\n\t\t\n\r\n\t\tfloat noise(vec2 p, float freq ){\n\r\n\t\t\tfloat unit = u_viewport.x/freq;\n\r\n\t\t\tvec2 ij = floor(p/unit);\n\r\n\t\t\tvec2 xy = mod(p,unit)/unit;\n\r\n\t\t\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\r\n\t\t\txy = .5*(1.-cos(M_PI*xy));\n\r\n\t\t\tfloat a = rand((ij+vec2(0.,0.)));\n\r\n\t\t\tfloat b = rand((ij+vec2(1.,0.)));\n\r\n\t\t\tfloat c = rand((ij+vec2(0.,1.)));\n\r\n\t\t\tfloat d = rand((ij+vec2(1.,1.)));\n\r\n\t\t\tfloat x1 = mix(a, b, xy.x);\n\r\n\t\t\tfloat x2 = mix(c, d, xy.x);\n\r\n\t\t\treturn mix(x1, x2, xy.y);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfloat pNoise(vec2 p, int res){\n\r\n\t\t\tfloat persistance = u_persistence;\n\r\n\t\t\tfloat n = 0.;\n\r\n\t\t\tfloat normK = 0.;\n\r\n\t\t\tfloat f = 4.;\n\r\n\t\t\tfloat amp = 1.0;\n\r\n\t\t\tint iCount = 0;\n\r\n\t\t\tfor (int i = 0; i<50; i++){\n\r\n\t\t\t\tn+=amp*noise(p, f);\n\r\n\t\t\t\tf*=2.;\n\r\n\t\t\t\tnormK+=amp;\n\r\n\t\t\t\tamp*=persistance;\n\r\n\t\t\t\tif (iCount >= res)\n\r\n\t\t\t\t\tbreak;\n\r\n\t\t\t\tiCount++;\n\r\n\t\t\t}\n\r\n\t\t\tfloat nf = n/normK;\n\r\n\t\t\treturn nf*nf*nf*nf;\n\r\n\t\t}\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\n\r\n\t\t\tvec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\n\r\n\t\t\tgl_FragColor = color;\n\r\n\t\t}", 
  A.registerNodeType("texture/perlin", L), N.title = "Canvas2D", N.desc = "Executes Canvas2D code inside a texture or the viewport.", N.help = "Set width and height to 0 to match viewport size.", N.widgets_info = {precision:{widget:"combo", values:a.MODE_VALUES}, code:{type:"code"}, width:{type:"Number", precision:0, step:1}, height:{type:"Number", precision:0, step:1}}, N.prototype.onPropertyChanged = function(a, b) {
    "code" == a && this.compileCode(b);
  }, N.prototype.compileCode = function(a) {
    this._func = null;
    if (A.allow_scripts) {
      try {
        this._func = new Function("canvas", "ctx", "time", "script", "v", a), this.boxcolor = "#00FF00";
      } catch (O) {
        this.boxcolor = "#FF0000", console.error("Error parsing script"), console.error(O);
      }
    }
  }, N.prototype.onExecute = function() {
    var a = this._func;
    a && this.isOutputConnected(0) && this.executeDraw(a);
  }, N.prototype.executeDraw = function(b) {
    var d = this.properties.width || gl.canvas.width, f = this.properties.height || gl.canvas.height, e = this._temp_texture, c = a.getTextureType(this.properties.precision);
    e && e.width == d && e.height == f && e.type == c || (e = this._temp_texture = new GL.Texture(d, f, {format:gl.RGBA, filter:gl.LINEAR, type:c}));
    var g = this.getInputData(0), q = this.properties, m = this, k = this.graph.getTime(), l = gl, h = gl.canvas;
    if (this.properties.use_html_canvas || !n.enableWebGLCanvas) {
      this._canvas ? (h = this._canvas, l = this._ctx) : (h = this._canvas = createCanvas(d.height), l = this._ctx = h.getContext("2d")), h.width = d, h.height = f;
    }
    if (l == gl) {
      e.drawTo(function() {
        gl.start2D();
        q.clear && (gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT));
        try {
          b.draw ? b.draw.call(m, h, l, k, b, g) : b.call(m, h, l, k, b, g), m.boxcolor = "#00FF00";
        } catch (S) {
          m.boxcolor = "#FF0000", console.error("Error executing script"), console.error(S);
        }
        gl.finish2D();
      });
    } else {
      q.clear && l.clearRect(0, 0, h.width, h.height);
      try {
        b.draw ? b.draw.call(this, h, l, k, b, g) : b.call(this, h, l, k, b, g), this.boxcolor = "#00FF00";
      } catch (S) {
        this.boxcolor = "#FF0000", console.error("Error executing script"), console.error(S);
      }
      e.uploadImage(h);
    }
    this.setOutputData(0, e);
  }, A.registerNodeType("texture/canvas2D", N), Q.title = "Matte", Q.desc = "Extracts background", Q.widgets_info = {key_color:{widget:"color"}, precision:{widget:"combo", values:a.MODE_VALUES}}, Q.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var b = this.getInputData(0);
      if (this.properties.precision === a.PASS_THROUGH) {
        this.setOutputData(0, b);
      } else {
        if (b) {
          this._tex = a.getTargetTexture(b, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          this._uniforms || (this._uniforms = {u_texture:0, u_key_color:this.properties.key_color, u_threshold:1, u_slope:1});
          var d = this._uniforms, f = Mesh.getScreenQuad(), e = Q._shader;
          e || (e = Q._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, Q.pixel_shader));
          d.u_key_color = this.properties.key_color;
          d.u_threshold = this.properties.threshold;
          d.u_slope = this.properties.slope;
          this._tex.drawTo(function() {
            b.bind(0);
            e.uniforms(d).draw(f);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  }, Q.pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec3 u_key_color;\n\r\n\t\tuniform float u_threshold;\n\r\n\t\tuniform float u_slope;\n\r\n\t\t\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec3 color = texture2D( u_texture, v_coord ).xyz;\n\r\n\t\t\tfloat diff = length( normalize(color) - normalize(u_key_color) );\n\r\n\t\t\tfloat edge = u_threshold * (1.0 - u_slope);\n\r\n\t\t\tfloat alpha = smoothstep( edge, u_threshold, diff);\n\r\n\t\t\tgl_FragColor = vec4( color, alpha );\n\r\n\t\t}", 
  A.registerNodeType("texture/matte", Q), R.title = "CubemapToTexture2D", R.desc = "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation", R.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (a && a.texture_type == GL.TEXTURE_CUBE_MAP) {
        !this._last_tex || this._last_tex.height == a.height && this._last_tex.type == a.type || (this._last_tex = null);
        var b = this.getInputOrProperty("yaw");
        this._last_tex = GL.Texture.cubemapToTexture2D(a, a.height, this._last_tex, !0, b);
        this.setOutputData(0, this._last_tex);
      }
    }
  }, A.registerNodeType("texture/cubemapToTexture2D", R));
})(this);
(function(n) {
  var a = n.LiteGraph;
  if ("undefined" != typeof GL) {
    var h = function() {
      this.addInput("Tex.", "Texture");
      this.addInput("intensity", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {intensity:1, invert:!1, precision:LGraphTexture.DEFAULT};
      h._shader || (h._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, h.pixel_shader));
    }, c = function() {
      this.addInput("Texture", "Texture");
      this.addInput("value1", "number");
      this.addInput("value2", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {fx:"halftone", value1:1, value2:1, precision:LGraphTexture.DEFAULT};
    }, b = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Blurred", "Texture");
      this.addInput("Mask", "Texture");
      this.addInput("Threshold", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {shape:"", size:10, alpha:1.0, threshold:1.0, high_precision:!1};
    }, l = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Aberration", "number");
      this.addInput("Distortion", "number");
      this.addInput("Blur", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {aberration:1.0, distortion:1.0, blur:1.0, precision:LGraphTexture.DEFAULT};
      l._shader || (l._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, l.pixel_shader), l._texture = new GL.Texture(3, 1, {format:gl.RGB, wrap:gl.CLAMP_TO_EDGE, magFilter:gl.LINEAR, minFilter:gl.LINEAR, pixel_data:[255, 0, 0, 0, 255, 0, 0, 0, 255]}));
    };
    l.title = "Lens";
    l.desc = "Camera Lens distortion";
    l.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    l.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        if (a) {
          this._tex = LGraphTexture.getTargetTexture(a, this._tex, this.properties.precision);
          var b = this.properties.aberration;
          this.isInputConnected(1) && (b = this.getInputData(1), this.properties.aberration = b);
          var c = this.properties.distortion;
          this.isInputConnected(2) && (c = this.getInputData(2), this.properties.distortion = c);
          var h = this.properties.blur;
          this.isInputConnected(3) && (h = this.getInputData(3), this.properties.blur = h);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var n = Mesh.getScreenQuad(), w = l._shader;
          this._tex.drawTo(function() {
            a.bind(0);
            w.uniforms({u_texture:0, u_aberration:b, u_distortion:c, u_blur:h}).draw(n);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    l.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform float u_aberration;\n\r\n\t\t\tuniform float u_distortion;\n\r\n\t\t\tuniform float u_blur;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = v_coord;\n\r\n\t\t\t\tfloat dist = distance(vec2(0.5), coord);\n\r\n\t\t\t\tvec2 dist_coord = coord - vec2(0.5);\n\r\n\t\t\t\tfloat percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\n\r\n\t\t\t\tdist_coord *= percent;\n\r\n\t\t\t\tcoord = dist_coord + vec2(0.5);\n\r\n\t\t\t\tvec4 color = texture2D(u_texture,coord, u_blur * dist);\n\r\n\t\t\t\tcolor.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\n\r\n\t\t\t\tcolor.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n\r\n\t\t\t";
    a.registerNodeType("fx/lens", l);
    n.LGraphFXLens = l;
    b.title = "Bokeh";
    b.desc = "applies an Bokeh effect";
    b.widgets_info = {shape:{widget:"texture"}};
    b.prototype.onExecute = function() {
      var a = this.getInputData(0), c = this.getInputData(1), l = this.getInputData(2);
      if (a && l && this.properties.shape) {
        c || (c = a);
        var h = LGraphTexture.getTexture(this.properties.shape);
        if (h) {
          var n = this.properties.threshold;
          this.isInputConnected(3) && (n = this.getInputData(3), this.properties.threshold = n);
          var w = gl.UNSIGNED_BYTE;
          this.properties.high_precision && (w = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
          this._temp_texture && this._temp_texture.type == w && this._temp_texture.width == a.width && this._temp_texture.height == a.height || (this._temp_texture = new GL.Texture(a.width, a.height, {type:w, format:gl.RGBA, filter:gl.LINEAR}));
          var u = b._first_shader;
          u || (u = b._first_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, b._first_pixel_shader));
          var y = b._second_shader;
          y || (y = b._second_shader = new GL.Shader(b._second_vertex_shader, b._second_pixel_shader));
          var r = this._points_mesh;
          r && r._width == a.width && r._height == a.height && 2 == r._spacing || (r = this.createPointsMesh(a.width, a.height, 2));
          var z = Mesh.getScreenQuad(), d = this.properties.size, e = this.properties.alpha;
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.BLEND);
          this._temp_texture.drawTo(function() {
            a.bind(0);
            c.bind(1);
            l.bind(2);
            u.uniforms({u_texture:0, u_texture_blur:1, u_mask:2, u_texsize:[a.width, a.height]}).draw(z);
          });
          this._temp_texture.drawTo(function() {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE);
            a.bind(0);
            h.bind(3);
            y.uniforms({u_texture:0, u_mask:2, u_shape:3, u_alpha:e, u_threshold:n, u_pointSize:d, u_itexsize:[1.0 / a.width, 1.0 / a.height]}).draw(r, gl.POINTS);
          });
          this.setOutputData(0, this._temp_texture);
        }
      } else {
        this.setOutputData(0, a);
      }
    };
    b.prototype.createPointsMesh = function(a, b, c) {
      for (var g = Math.round(a / c), l = Math.round(b / c), h = new Float32Array(g * l * 2), n = -1, x = 2 / a * c, r = 2 / b * c, v = 0; v < l; ++v) {
        for (var d = -1, e = 0; e < g; ++e) {
          var m = v * g * 2 + 2 * e;
          h[m] = d;
          h[m + 1] = n;
          d += x;
        }
        n += r;
      }
      this._points_mesh = GL.Mesh.load({vertices2D:h});
      this._points_mesh._width = a;
      this._points_mesh._height = b;
      this._points_mesh._spacing = c;
      return this._points_mesh;
    };
    b._first_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_texture_blur;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec4 blurred_color = texture2D(u_texture_blur, v_coord);\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, v_coord).x;\n\r\n\t\t\t   gl_FragColor = mix(color, blurred_color, mask);\n\r\n\t\t\t}\n\r\n\t\t\t";
    b._second_vertex_shader = "precision highp float;\n\r\n\t\t\tattribute vec2 a_vertex2D;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\tuniform vec2 u_itexsize;\n\r\n\t\t\tuniform float u_pointSize;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = a_vertex2D * 0.5 + 0.5;\n\r\n\t\t\t\tv_color = texture2D( u_texture, coord );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + u_itexsize);\n\r\n\t\t\t\tv_color *= 0.25;\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, coord).x;\n\r\n\t\t\t\tfloat luminance = length(v_color) * mask;\n\r\n\t\t\t\t/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\n\r\n\t\t\t\tluminance -= u_threshold;\n\r\n\t\t\t\tif(luminance < 0.0)\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tgl_Position.x = -100.0;\n\r\n\t\t\t\t\treturn;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tgl_PointSize = u_pointSize;\n\r\n\t\t\t\tgl_Position = vec4(a_vertex2D,0.0,1.0);\n\r\n\t\t\t}\n\r\n\t\t\t";
    b._second_pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_shape;\n\r\n\t\t\tuniform float u_alpha;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_shape, gl_PointCoord );\n\r\n\t\t\t\tcolor *= v_color * u_alpha;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
    a.registerNodeType("fx/bokeh", b);
    n.LGraphFXBokeh = b;
    c.title = "FX";
    c.desc = "applies an FX from a list";
    c.widgets_info = {fx:{widget:"combo", values:["halftone", "pixelate", "lowpalette", "noise", "gamma"]}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    c.shaders = {};
    c.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.getInputData(0);
        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          if (a) {
            this._tex = LGraphTexture.getTargetTexture(a, this._tex, this.properties.precision);
            var b = this.properties.value1;
            this.isInputConnected(1) && (b = this.getInputData(1), this.properties.value1 = b);
            var l = this.properties.value2;
            this.isInputConnected(2) && (l = this.getInputData(2), this.properties.value2 = l);
            var h = this.properties.fx, C = c.shaders[h];
            if (!C) {
              var w = c["pixel_shader_" + h];
              if (!w) {
                return;
              }
              C = c.shaders[h] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, w);
            }
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var u = Mesh.getScreenQuad();
            var y = n.LS && LS.Renderer._current_camera ? [LS.Renderer._current_camera.near, LS.Renderer._current_camera.far] : [1, 100];
            var r = null;
            "noise" == h && (r = LGraphTexture.getNoiseTexture());
            this._tex.drawTo(function() {
              a.bind(0);
              "noise" == h && r.bind(1);
              C.uniforms({u_texture:0, u_noise:1, u_size:[a.width, a.height], u_rand:[Math.random(), Math.random()], u_value1:b, u_value2:l, u_camera_planes:y}).draw(u);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    };
    c.pixel_shader_halftone = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tfloat pattern() {\n\r\n\t\t\t\tfloat s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\n\r\n\t\t\t\tvec2 tex = v_coord * u_size.xy;\n\r\n\t\t\t\tvec2 point = vec2(\n\r\n\t\t\t\t   c * tex.x - s * tex.y ,\n\r\n\t\t\t\t   s * tex.x + c * tex.y \n\r\n\t\t\t\t) * u_value2;\n\r\n\t\t\t\treturn (sin(point.x) * sin(point.y)) * 4.0;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat average = (color.r + color.g + color.b) / 3.0;\n\r\n\t\t\t\tgl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\r\n\t\t\t}\n";
    c.pixel_shader_pixelate = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, coord);\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
    c.pixel_shader_lowpalette = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tgl_FragColor = floor(color * u_value1) / u_value1;\n\r\n\t\t\t}\n";
    c.pixel_shader_noise = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_noise;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\tuniform vec2 u_rand;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\n\r\n\t\t\t\tgl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\n\r\n\t\t\t}\n";
    c.pixel_shader_gamma = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat gamma = 1.0 / u_value1;\n\r\n\t\t\t\tgl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\n\r\n\t\t\t}\n";
    a.registerNodeType("fx/generic", c);
    n.LGraphFXGeneric = c;
    h.title = "Vigneting";
    h.desc = "Vigneting";
    h.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    h.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        if (a) {
          this._tex = LGraphTexture.getTargetTexture(a, this._tex, this.properties.precision);
          var b = this.properties.intensity;
          this.isInputConnected(1) && (b = this.getInputData(1), this.properties.intensity = b);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var c = Mesh.getScreenQuad(), l = h._shader, n = this.properties.invert;
          this._tex.drawTo(function() {
            a.bind(0);
            l.uniforms({u_texture:0, u_intensity:b, u_isize:[1 / a.width, 1 / a.height], u_invert:n ? 1 : 0}).draw(c);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    h.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_intensity;\n\r\n\t\t\tuniform int u_invert;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tif(u_invert == 1)\n\r\n\t\t\t\t\tluminance = 1.0 - luminance;\n\r\n\t\t\t\tluminance = mix(1.0, luminance, u_intensity);\n\r\n\t\t\t   gl_FragColor = vec4( luminance * color.xyz, color.a);\n\r\n\t\t\t}\n\r\n\t\t\t";
    a.registerNodeType("fx/vigneting", h);
    n.LGraphFXVigneting = h;
  }
})(this);
(function(n) {
  function a(a) {
    this.cmd = this.channel = 0;
    this.data = new Uint32Array(3);
    a && this.setup(a);
  }
  function h(a, b) {
    navigator.requestMIDIAccess ? (this.on_ready = a, this.state = {note:[], cc:[]}, navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))) : (this.error = "not suppoorted", b ? b("Not supported") : console.error("MIDI NOT SUPPORTED, enable by chrome://flags"));
  }
  function c() {
    this.addOutput("on_midi", r.EVENT);
    this.addOutput("out", "midi");
    this.properties = {port:0};
    this._current_midi_event = this._last_midi_event = null;
    this.boxcolor = "#AAA";
    this._last_time = 0;
    var a = this;
    new h(function(b) {
      a._midi = b;
      if (a._waiting) {
        a.onStart();
      }
      a._waiting = !1;
    });
  }
  function b() {
    this.addInput("send", r.EVENT);
    this.properties = {port:0};
    var a = this;
    new h(function(b) {
      a._midi = b;
    });
  }
  function l() {
    this.addInput("on_midi", r.EVENT);
    this._str = "";
    this.size = [200, 40];
  }
  function g() {
    this.properties = {channel:-1, cmd:-1, min_value:-1, max_value:-1};
    var a = this;
    this._learning = !1;
    this.addWidget("button", "Learn", "", function() {
      a._learning = !0;
      a.boxcolor = "#FA3";
    });
    this.addInput("in", r.EVENT);
    this.addOutput("on_midi", r.EVENT);
    this.boxcolor = "#AAA";
  }
  function x() {
    this.properties = {channel:0, cmd:144, value1:1, value2:1};
    this.addInput("send", r.EVENT);
    this.addInput("assign", r.EVENT);
    this.addOutput("on_midi", r.EVENT);
    this.midi_event = new a;
    this.gate = !1;
  }
  function v() {
    this.properties = {cc:1, value:0};
    this.addOutput("value", "number");
  }
  function p() {
    this.addInput("generate", r.ACTION);
    this.addInput("scale", "string");
    this.addInput("octave", "number");
    this.addOutput("note", r.EVENT);
    this.properties = {notes:"A,A#,B,C,C#,D,D#,E,F,F#,G,G#", octave:2, duration:0.5, mode:"sequence"};
    this.notes_pitches = p.processScale(this.properties.notes);
    this.sequence_index = 0;
  }
  function C() {
    this.properties = {amount:0};
    this.addInput("in", r.ACTION);
    this.addInput("amount", "number");
    this.addOutput("out", r.EVENT);
    this.midi_event = new a;
  }
  function w() {
    this.properties = {scale:"A,A#,B,C,C#,D,D#,E,F,F#,G,G#"};
    this.addInput("note", r.ACTION);
    this.addInput("scale", "string");
    this.addOutput("out", r.EVENT);
    this.valid_notes = Array(12);
    this.offset_notes = Array(12);
    this.processScale(this.properties.scale);
  }
  function u() {
    this.properties = {volume:0.5, duration:1};
    this.addInput("note", r.ACTION);
    this.addInput("volume", "number");
    this.addInput("duration", "number");
    this.addOutput("note", r.EVENT);
    "undefined" == typeof AudioSynth ? (console.error("Audiosynth.js not included, LGMidiPlay requires that library"), this.boxcolor = "red") : this.instrument = (this.synth = new AudioSynth).createInstrument("piano");
  }
  function y() {
    this.properties = {num_octaves:2, start_octave:2};
    this.addInput("note", r.ACTION);
    this.addInput("reset", r.ACTION);
    this.addOutput("note", r.EVENT);
    this.size = [400, 100];
    this.keys = [];
    this._last_key = -1;
  }
  var r = n.LiteGraph;
  r.MIDIEvent = a;
  a.prototype.fromJSON = function(a) {
    this.setup(a.data);
  };
  a.prototype.setup = function(b) {
    var d = b;
    b.constructor === Object && (d = b.data);
    this.data.set(d);
    this.status = b = d[0];
    d = b & 240;
    this.cmd = 240 <= b ? b : d;
    this.cmd == a.NOTEON && 0 == this.velocity && (this.cmd = a.NOTEOFF);
    this.cmd_str = a.commands[this.cmd] || "";
    if (d >= a.NOTEON || d <= a.NOTEOFF) {
      this.channel = b & 15;
    }
  };
  Object.defineProperty(a.prototype, "velocity", {get:function() {
    return this.cmd == a.NOTEON ? this.data[2] : -1;
  }, set:function(a) {
    this.data[2] = a;
  }, enumerable:!0});
  a.notes = "A A# B C C# D D# E F F# G G#".split(" ");
  a.note_to_index = {A:0, "A#":1, B:2, C:3, "C#":4, D:5, "D#":6, E:7, F:8, "F#":9, G:10, "G#":11};
  Object.defineProperty(a.prototype, "note", {get:function() {
    return this.cmd != a.NOTEON ? -1 : a.toNoteString(this.data[1], !0);
  }, set:function(a) {
    throw "notes cannot be assigned this way, must modify the data[1]";
  }, enumerable:!0});
  Object.defineProperty(a.prototype, "octave", {get:function() {
    return this.cmd != a.NOTEON ? -1 : Math.floor((this.data[1] - 24) / 12 + 1);
  }, set:function(a) {
    throw "octave cannot be assigned this way, must modify the data[1]";
  }, enumerable:!0});
  a.prototype.getPitch = function() {
    return 440 * Math.pow(2, (this.data[1] - 69) / 12);
  };
  a.computePitch = function(a) {
    return 440 * Math.pow(2, (a - 69) / 12);
  };
  a.prototype.getCC = function() {
    return this.data[1];
  };
  a.prototype.getCCValue = function() {
    return this.data[2];
  };
  a.prototype.getPitchBend = function() {
    return this.data[1] + (this.data[2] << 7) - 8192;
  };
  a.computePitchBend = function(a, b) {
    return a + (b << 7) - 8192;
  };
  a.prototype.setCommandFromString = function(b) {
    this.cmd = a.computeCommandFromString(b);
  };
  a.computeCommandFromString = function(b) {
    if (!b) {
      return 0;
    }
    if (b && b.constructor === Number) {
      return b;
    }
    b = b.toUpperCase();
    switch(b) {
      case "NOTE ON":
      case "NOTEON":
        return a.NOTEON;
      case "NOTE OFF":
      case "NOTEOFF":
        return a.NOTEON;
      case "KEY PRESSURE":
      case "KEYPRESSURE":
        return a.KEYPRESSURE;
      case "CONTROLLER CHANGE":
      case "CONTROLLERCHANGE":
      case "CC":
        return a.CONTROLLERCHANGE;
      case "PROGRAM CHANGE":
      case "PROGRAMCHANGE":
      case "PC":
        return a.PROGRAMCHANGE;
      case "CHANNEL PRESSURE":
      case "CHANNELPRESSURE":
        return a.CHANNELPRESSURE;
      case "PITCH BEND":
      case "PITCHBEND":
        return a.PITCHBEND;
      case "TIME TICK":
      case "TIMETICK":
        return a.TIMETICK;
      default:
        return Number(b);
    }
  };
  a.toNoteString = function(b, e) {
    b = Math.round(b);
    var d = Math.floor((b - 24) / 12 + 1);
    b = (b - 21) % 12;
    0 > b && (b = 12 + b);
    return a.notes[b] + (e ? "" : d);
  };
  a.NoteStringToPitch = function(b) {
    b = b.toUpperCase();
    var d = b[0], c = 4;
    "#" == b[1] ? (d += "#", 2 < b.length && (c = Number(b[2]))) : 1 < b.length && (c = Number(b[1]));
    b = a.note_to_index[d];
    return null == b ? null : 12 * (c - 1) + b + 21;
  };
  a.prototype.toString = function() {
    var b = "" + this.channel + ". ";
    switch(this.cmd) {
      case a.NOTEON:
        b += "NOTEON " + a.toNoteString(this.data[1]);
        break;
      case a.NOTEOFF:
        b += "NOTEOFF " + a.toNoteString(this.data[1]);
        break;
      case a.CONTROLLERCHANGE:
        b += "CC " + this.data[1] + " " + this.data[2];
        break;
      case a.PROGRAMCHANGE:
        b += "PC " + this.data[1];
        break;
      case a.PITCHBEND:
        b += "PITCHBEND " + this.getPitchBend();
        break;
      case a.KEYPRESSURE:
        b += "KEYPRESS " + this.data[1];
    }
    return b;
  };
  a.prototype.toHexString = function() {
    for (var a = "", b = 0; b < this.data.length; b++) {
      a += this.data[b].toString(16) + " ";
    }
  };
  a.prototype.toJSON = function() {
    return {data:[this.data[0], this.data[1], this.data[2]], object_class:"MIDIEvent"};
  };
  a.NOTEOFF = 128;
  a.NOTEON = 144;
  a.KEYPRESSURE = 160;
  a.CONTROLLERCHANGE = 176;
  a.PROGRAMCHANGE = 192;
  a.CHANNELPRESSURE = 208;
  a.PITCHBEND = 224;
  a.TIMETICK = 248;
  a.commands = {128:"note off", 144:"note on", 160:"key pressure", 176:"controller change", 192:"program change", 208:"channel pressure", 224:"pitch bend", 240:"system", 242:"Song pos", 243:"Song select", 246:"Tune request", 248:"time tick", 250:"Start Song", 251:"Continue Song", 252:"Stop Song", 254:"Sensing", 255:"Reset"};
  a.commands_short = {128:"NOTEOFF", 144:"NOTEOFF", 160:"KEYP", 176:"CC", 192:"PC", 208:"CP", 224:"PB", 240:"SYS", 242:"POS", 243:"SELECT", 246:"TUNEREQ", 248:"TT", 250:"START", 251:"CONTINUE", 252:"STOP", 254:"SENS", 255:"RESET"};
  a.commands_reversed = {};
  for (var z in a.commands) {
    a.commands_reversed[a.commands[z]] = z;
  }
  h.input = null;
  h.MIDIEvent = a;
  h.prototype.onMIDISuccess = function(a) {
    console.log("MIDI ready!");
    console.log(a);
    this.midi = a;
    this.updatePorts();
    if (this.on_ready) {
      this.on_ready(this);
    }
  };
  h.prototype.updatePorts = function() {
    var a = this.midi;
    this.input_ports = a.inputs;
    for (var b = 0, c = this.input_ports.values(), f = c.next(); f && !1 === f.done;) {
      f = f.value, console.log("Input port [type:'" + f.type + "'] id:'" + f.id + "' manufacturer:'" + f.manufacturer + "' name:'" + f.name + "' version:'" + f.version + "'"), b++, f = c.next();
    }
    this.num_input_ports = b;
    b = 0;
    this.output_ports = a.outputs;
    c = this.output_ports.values();
    for (f = c.next(); f && !1 === f.done;) {
      f = f.value, console.log("Output port [type:'" + f.type + "'] id:'" + f.id + "' manufacturer:'" + f.manufacturer + "' name:'" + f.name + "' version:'" + f.version + "'"), b++, f = c.next();
    }
    this.num_output_ports = b;
  };
  h.prototype.onMIDIFailure = function(a) {
    console.error("Failed to get MIDI access - " + a);
  };
  h.prototype.openInputPort = function(b, e) {
    b = this.input_ports.get("input-" + b);
    if (!b) {
      return !1;
    }
    h.input = this;
    var d = this;
    b.onmidimessage = function(b) {
      var f = new a(b.data);
      d.updateState(f);
      e && e(b.data, f);
      if (h.on_message) {
        h.on_message(b.data, f);
      }
    };
    console.log("port open: ", b);
    return !0;
  };
  h.parseMsg = function(a) {
  };
  h.prototype.updateState = function(b) {
    switch(b.cmd) {
      case a.NOTEON:
        this.state.note[b.value1 | 0] = b.value2;
        break;
      case a.NOTEOFF:
        this.state.note[b.value1 | 0] = 0;
        break;
      case a.CONTROLLERCHANGE:
        this.state.cc[b.getCC()] = b.getCCValue();
    }
  };
  h.prototype.sendMIDI = function(b, e) {
    e && (b = this.output_ports.get("output-" + b)) && (h.output = this, e.constructor === a ? b.send(e.data) : b.send(e));
  };
  c.MIDIInterface = h;
  c.title = "MIDI Input";
  c.desc = "Reads MIDI from a input port";
  c.color = "#243";
  c.prototype.getPropertyInfo = function(a) {
    if (this._midi && "port" == a) {
      a = {};
      for (var b = 0; b < this._midi.input_ports.size; ++b) {
        var d = this._midi.input_ports.get("input-" + b);
        a[b] = b + ".- " + d.name + " version:" + d.version;
      }
      return {type:"enum", values:a};
    }
  };
  c.prototype.onStart = function() {
    this._midi ? this._midi.openInputPort(this.properties.port, this.onMIDIEvent.bind(this)) : this._waiting = !0;
  };
  c.prototype.onMIDIEvent = function(b, e) {
    this._last_midi_event = e;
    this.boxcolor = "#AFA";
    this._last_time = r.getTime();
    this.trigger("on_midi", e);
    e.cmd == a.NOTEON ? this.trigger("on_noteon", e) : e.cmd == a.NOTEOFF ? this.trigger("on_noteoff", e) : e.cmd == a.CONTROLLERCHANGE ? this.trigger("on_cc", e) : e.cmd == a.PROGRAMCHANGE ? this.trigger("on_pc", e) : e.cmd == a.PITCHBEND && this.trigger("on_pitchbend", e);
  };
  c.prototype.onDrawBackground = function(a) {
    this.boxcolor = "#AAA";
    if (!this.flags.collapsed && this._last_midi_event) {
      a.fillStyle = "white";
      var b = r.getTime();
      b = 1.0 - Math.max(0, 0.001 * (b - this._last_time));
      if (0 < b) {
        var d = a.globalAlpha;
        a.globalAlpha *= b;
        a.font = "12px Tahoma";
        a.fillText(this._last_midi_event.toString(), 2, 0.5 * this.size[1] + 3);
        a.globalAlpha = d;
      }
    }
  };
  c.prototype.onExecute = function() {
    if (this.outputs) {
      for (var a = this._last_midi_event, b = 0; b < this.outputs.length; ++b) {
        switch(this.outputs[b].name) {
          case "midi":
            var c = this._midi;
            break;
          case "last_midi":
            c = a;
            break;
          default:
            continue;
        }
        this.setOutputData(b, c);
      }
    }
  };
  c.prototype.onGetOutputs = function() {
    return [["last_midi", "midi"], ["on_midi", r.EVENT], ["on_noteon", r.EVENT], ["on_noteoff", r.EVENT], ["on_cc", r.EVENT], ["on_pc", r.EVENT], ["on_pitchbend", r.EVENT]];
  };
  r.registerNodeType("midi/input", c);
  b.MIDIInterface = h;
  b.title = "MIDI Output";
  b.desc = "Sends MIDI to output channel";
  b.color = "#243";
  b.prototype.getPropertyInfo = function(a) {
    if (this._midi && "port" == a) {
      a = {};
      for (var b = 0; b < this._midi.output_ports.size; ++b) {
        var d = this._midi.output_ports.get(b);
        a[b] = b + ".- " + d.name + " version:" + d.version;
      }
      return {type:"enum", values:a};
    }
  };
  b.prototype.onAction = function(a, b) {
    this._midi && ("send" == a && this._midi.sendMIDI(this.port, b), this.trigger("midi", b));
  };
  b.prototype.onGetInputs = function() {
    return [["send", r.ACTION]];
  };
  b.prototype.onGetOutputs = function() {
    return [["on_midi", r.EVENT]];
  };
  r.registerNodeType("midi/output", b);
  l.title = "MIDI Show";
  l.desc = "Shows MIDI in the graph";
  l.color = "#243";
  l.prototype.getTitle = function() {
    return this.flags.collapsed ? this._str : this.title;
  };
  l.prototype.onAction = function(b, e) {
    e && (this._str = e.constructor === a ? e.toString() : "???");
  };
  l.prototype.onDrawForeground = function(a) {
    this._str && !this.flags.collapsed && (a.font = "30px Arial", a.fillText(this._str, 10, 0.8 * this.size[1]));
  };
  l.prototype.onGetInputs = function() {
    return [["in", r.ACTION]];
  };
  l.prototype.onGetOutputs = function() {
    return [["on_midi", r.EVENT]];
  };
  r.registerNodeType("midi/show", l);
  g.title = "MIDI Filter";
  g.desc = "Filters MIDI messages";
  g.color = "#243";
  g["@cmd"] = {type:"enum", title:"Command", values:a.commands_reversed};
  g.prototype.getTitle = function() {
    var b = -1 == this.properties.cmd ? "Nothing" : a.commands_short[this.properties.cmd] || "Unknown";
    -1 != this.properties.min_value && -1 != this.properties.max_value && (b += " " + (this.properties.min_value == this.properties.max_value ? this.properties.max_value : this.properties.min_value + ".." + this.properties.max_value));
    return "Filter: " + b;
  };
  g.prototype.onPropertyChanged = function(b, e) {
    "cmd" == b && (b = Number(e), isNaN(b) && (b = a.commands[e] || 0), this.properties.cmd = b);
  };
  g.prototype.onAction = function(b, e) {
    if (e && e.constructor === a) {
      if (this._learning) {
        this._learning = !1, this.boxcolor = "#AAA", this.properties.channel = e.channel, this.properties.cmd = e.cmd, this.properties.min_value = this.properties.max_value = e.data[1];
      } else {
        if (-1 != this.properties.channel && e.channel != this.properties.channel || -1 != this.properties.cmd && e.cmd != this.properties.cmd || -1 != this.properties.min_value && e.data[1] < this.properties.min_value || -1 != this.properties.max_value && e.data[1] > this.properties.max_value) {
          return;
        }
      }
      this.trigger("on_midi", e);
    }
  };
  r.registerNodeType("midi/filter", g);
  x.title = "MIDIEvent";
  x.desc = "Create a MIDI Event";
  x.color = "#243";
  x.prototype.onAction = function(b, e) {
    "assign" == b ? (this.properties.channel = e.channel, this.properties.cmd = e.cmd, this.properties.value1 = e.data[1], this.properties.value2 = e.data[2], e.cmd == a.NOTEON ? this.gate = !0 : e.cmd == a.NOTEOFF && (this.gate = !1)) : (e = this.midi_event, e.channel = this.properties.channel, this.properties.cmd && this.properties.cmd.constructor === String ? e.setCommandFromString(this.properties.cmd) : e.cmd = this.properties.cmd, e.data[0] = e.cmd | e.channel, e.data[1] = Number(this.properties.value1), 
    e.data[2] = Number(this.properties.value2), this.trigger("on_midi", e));
  };
  x.prototype.onExecute = function() {
    var b = this.properties;
    if (this.inputs) {
      for (var e = 0; e < this.inputs.length; ++e) {
        var c = this.inputs[e];
        if (-1 != c.link) {
          switch(c.name) {
            case "note":
              c = this.getInputData(e), null != c && (c.constructor === String && (c = a.NoteStringToPitch(c)), this.properties.value1 = (c | 0) % 255);
          }
        }
      }
    }
    if (this.outputs) {
      for (e = 0; e < this.outputs.length; ++e) {
        switch(this.outputs[e].name) {
          case "midi":
            c = new a;
            c.setup([b.cmd, b.value1, b.value2]);
            c.channel = b.channel;
            break;
          case "command":
            c = b.cmd;
            break;
          case "cc":
            c = b.value1;
            break;
          case "cc_value":
            c = b.value2;
            break;
          case "note":
            c = b.cmd == a.NOTEON || b.cmd == a.NOTEOFF ? b.value1 : null;
            break;
          case "velocity":
            c = b.cmd == a.NOTEON ? b.value2 : null;
            break;
          case "pitch":
            c = b.cmd == a.NOTEON ? a.computePitch(b.value1) : null;
            break;
          case "pitchbend":
            c = b.cmd == a.PITCHBEND ? a.computePitchBend(b.value1, b.value2) : null;
            break;
          case "gate":
            c = this.gate;
            break;
          default:
            continue;
        }
        null !== c && this.setOutputData(e, c);
      }
    }
  };
  x.prototype.onPropertyChanged = function(b, e) {
    "cmd" == b && (this.properties.cmd = a.computeCommandFromString(e));
  };
  x.prototype.onGetInputs = function() {
    return [["note", "number"]];
  };
  x.prototype.onGetOutputs = function() {
    return [["midi", "midi"], ["on_midi", r.EVENT], ["command", "number"], ["note", "number"], ["velocity", "number"], ["cc", "number"], ["cc_value", "number"], ["pitch", "number"], ["gate", "bool"], ["pitchbend", "number"]];
  };
  r.registerNodeType("midi/event", x);
  v.title = "MIDICC";
  v.desc = "gets a Controller Change";
  v.color = "#243";
  v.prototype.onExecute = function() {
    h.input && (this.properties.value = h.input.state.cc[this.properties.cc]);
    this.setOutputData(0, this.properties.value);
  };
  r.registerNodeType("midi/cc", v);
  p.title = "MIDI Generator";
  p.desc = "Generates a random MIDI note";
  p.color = "#243";
  p.processScale = function(b) {
    b = b.split(",");
    for (var d = 0; d < b.length; ++d) {
      var c = b[d];
      b[d] = 2 == c.length && "#" != c[1] || 2 < c.length ? -r.MIDIEvent.NoteStringToPitch(c) : a.note_to_index[c] || 0;
    }
    return b;
  };
  p.prototype.onPropertyChanged = function(a, b) {
    "notes" == a && (this.notes_pitches = p.processScale(b));
  };
  p.prototype.onExecute = function() {
    var a = this.getInputData(2);
    null != a && (this.properties.octave = a);
    if (a = this.getInputData(1)) {
      this.notes_pitches = p.processScale(a);
    }
  };
  p.prototype.onAction = function(b, c) {
    var d = 0;
    c = this.notes_pitches.length;
    b = 0;
    "sequence" == this.properties.mode ? b = this.sequence_index = (this.sequence_index + 1) % c : "random" == this.properties.mode && (b = Math.floor(Math.random() * c));
    c = this.notes_pitches[b];
    d = 0 <= c ? c + 12 * (this.properties.octave - 1) + 33 : -c;
    c = new a;
    c.setup([a.NOTEON, d, 10]);
    b = this.properties.duration || 1;
    this.trigger("note", c);
    setTimeout(function() {
      var b = new a;
      b.setup([a.NOTEOFF, d, 0]);
      this.trigger("note", b);
    }.bind(this), 1000 * b);
  };
  r.registerNodeType("midi/generator", p);
  C.title = "MIDI Transpose";
  C.desc = "Transpose a MIDI note";
  C.color = "#243";
  C.prototype.onAction = function(b, c) {
    c && c.constructor === a && (c.data[0] == a.NOTEON || c.data[0] == a.NOTEOFF ? (this.midi_event = new a, this.midi_event.setup(c.data), this.midi_event.data[1] = Math.round(this.midi_event.data[1] + this.properties.amount), this.trigger("out", this.midi_event)) : this.trigger("out", c));
  };
  C.prototype.onExecute = function() {
    var a = this.getInputData(1);
    null != a && (this.properties.amount = a);
  };
  r.registerNodeType("midi/transpose", C);
  w.title = "MIDI Quantize Pitch";
  w.desc = "Transpose a MIDI note tp fit an scale";
  w.color = "#243";
  w.prototype.onPropertyChanged = function(a, b) {
    "scale" == a && this.processScale(b);
  };
  w.prototype.processScale = function(a) {
    this._current_scale = a;
    this.notes_pitches = p.processScale(a);
    for (a = 0; 12 > a; ++a) {
      this.valid_notes[a] = -1 != this.notes_pitches.indexOf(a);
    }
    for (a = 0; 12 > a; ++a) {
      if (this.valid_notes[a]) {
        this.offset_notes[a] = 0;
      } else {
        for (var b = 1; 12 > b; ++b) {
          if (this.valid_notes[(a - b) % 12]) {
            this.offset_notes[a] = -b;
            break;
          }
          if (this.valid_notes[(a + b) % 12]) {
            this.offset_notes[a] = b;
            break;
          }
        }
      }
    }
  };
  w.prototype.onAction = function(b, c) {
    c && c.constructor === a && (c.data[0] == a.NOTEON || c.data[0] == a.NOTEOFF ? (this.midi_event = new a, this.midi_event.setup(c.data), this.midi_event.data[1] += this.offset_notes[a.note_to_index[c.note]], this.trigger("out", this.midi_event)) : this.trigger("out", c));
  };
  w.prototype.onExecute = function() {
    var a = this.getInputData(1);
    null != a && a != this._current_scale && this.processScale(a);
  };
  r.registerNodeType("midi/quantize", w);
  u.title = "MIDI Play";
  u.desc = "Plays a MIDI note";
  u.color = "#243";
  u.prototype.onAction = function(b, c) {
    if (c && c.constructor === a) {
      if (this.instrument && c.data[0] == a.NOTEON) {
        b = c.note;
        if (!b || "undefined" == b || b.constructor !== String) {
          return;
        }
        this.instrument.play(b, c.octave, this.properties.duration, this.properties.volume);
      }
      this.trigger("note", c);
    }
  };
  u.prototype.onExecute = function() {
    var a = this.getInputData(1);
    null != a && (this.properties.volume = a);
    a = this.getInputData(2);
    null != a && (this.properties.duration = a);
  };
  r.registerNodeType("midi/play", u);
  y.title = "MIDI Keys";
  y.desc = "Keyboard to play notes";
  y.color = "#243";
  y.keys = [{x:0, w:1, h:1, t:0}, {x:0.75, w:0.5, h:0.6, t:1}, {x:1, w:1, h:1, t:0}, {x:1.75, w:0.5, h:0.6, t:1}, {x:2, w:1, h:1, t:0}, {x:2.75, w:0.5, h:0.6, t:1}, {x:3, w:1, h:1, t:0}, {x:4, w:1, h:1, t:0}, {x:4.75, w:0.5, h:0.6, t:1}, {x:5, w:1, h:1, t:0}, {x:5.75, w:0.5, h:0.6, t:1}, {x:6, w:1, h:1, t:0}];
  y.prototype.onDrawForeground = function(a) {
    if (!this.flags.collapsed) {
      var b = 12 * this.properties.num_octaves;
      this.keys.length = b;
      var d = this.size[0] / (7 * this.properties.num_octaves), f = this.size[1];
      a.globalAlpha = 1;
      for (var c = 0; 2 > c; c++) {
        for (var g = 0; g < b; ++g) {
          var l = y.keys[g % 12];
          if (l.t == c) {
            var h = 7 * Math.floor(g / 12) * d + l.x * d;
            a.fillStyle = 0 == c ? this.keys[g] ? "#CCC" : "white" : this.keys[g] ? "#333" : "black";
            a.fillRect(h + 1, 0, d * l.w - 2, f * l.h);
          }
        }
      }
    }
  };
  y.prototype.getKeyIndex = function(a) {
    for (var b = this.size[0] / (7 * this.properties.num_octaves), d = this.size[1], f = 1; 0 <= f; f--) {
      for (var c = 0; c < this.keys.length; ++c) {
        var g = y.keys[c % 12];
        if (g.t == f) {
          var l = 7 * Math.floor(c / 12) * b + g.x * b, h = b * g.w;
          g = d * g.h;
          if (!(a[0] < l || a[0] > l + h || a[1] > g)) {
            return c;
          }
        }
      }
    }
    return -1;
  };
  y.prototype.onAction = function(b, c) {
    if ("reset" == b) {
      for (c = 0; c < this.keys.length; ++c) {
        this.keys[c] = !1;
      }
    } else {
      c && c.constructor === a && (b = c.data[1] - (12 * (this.properties.start_octave - 1) + 29), 0 <= b && b < this.keys.length && (c.data[0] == a.NOTEON ? this.keys[b] = !0 : c.data[0] == a.NOTEOFF && (this.keys[b] = !1)), this.trigger("note", c));
    }
  };
  y.prototype.onMouseDown = function(b, c) {
    if (!(0 > c[1])) {
      return b = this.getKeyIndex(c), this.keys[b] = !0, this._last_key = b, b = 12 * (this.properties.start_octave - 1) + 29 + b, c = new a, c.setup([a.NOTEON, b, 100]), this.trigger("note", c), !0;
    }
  };
  y.prototype.onMouseMove = function(b, c) {
    if (!(0 > c[1] || -1 == this._last_key)) {
      this.setDirtyCanvas(!0);
      b = this.getKeyIndex(c);
      if (this._last_key == b) {
        return !0;
      }
      this.keys[this._last_key] = !1;
      c = 12 * (this.properties.start_octave - 1) + 29 + this._last_key;
      var d = new a;
      d.setup([a.NOTEOFF, c, 100]);
      this.trigger("note", d);
      this.keys[b] = !0;
      c = 12 * (this.properties.start_octave - 1) + 29 + b;
      d = new a;
      d.setup([a.NOTEON, c, 100]);
      this.trigger("note", d);
      this._last_key = b;
      return !0;
    }
  };
  y.prototype.onMouseUp = function(b, c) {
    if (!(0 > c[1])) {
      return b = this.getKeyIndex(c), this.keys[b] = !1, this._last_key = -1, b = 12 * (this.properties.start_octave - 1) + 29 + b, c = new a, c.setup([a.NOTEOFF, b, 100]), this.trigger("note", c), !0;
    }
  };
  r.registerNodeType("midi/keys", y);
})(this);
(function(n) {
  function a() {
    this.properties = {src:"", gain:0.5, loop:!0, autoplay:!0, playbackRate:1};
    this._loading_audio = !1;
    this._audiobuffer = null;
    this._audionodes = [];
    this._last_sourcenode = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = m.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
    this.properties.src && this.loadSound(this.properties.src);
  }
  function h() {
    this.properties = {gain:0.5};
    this._audionodes = [];
    this._media_stream = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = m.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
  }
  function c() {
    this.properties = {fftSize:2048, minDecibels:-100, maxDecibels:-10, smoothingTimeConstant:0.5};
    this.audionode = m.getAudioContext().createAnalyser();
    this.audionode.graphnode = this;
    this.audionode.fftSize = this.properties.fftSize;
    this.audionode.minDecibels = this.properties.minDecibels;
    this.audionode.maxDecibels = this.properties.maxDecibels;
    this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;
    this.addInput("in", "audio");
    this.addOutput("freqs", "array");
    this.addOutput("samples", "array");
    this._time_bin = this._freq_bin = null;
  }
  function b() {
    this.properties = {gain:1};
    this.audionode = m.getAudioContext().createGain();
    this.addInput("in", "audio");
    this.addInput("gain", "number");
    this.addOutput("out", "audio");
  }
  function l() {
    this.properties = {impulse_src:"", normalize:!0};
    this.audionode = m.getAudioContext().createConvolver();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function g() {
    this.properties = {threshold:-50, knee:40, ratio:12, reduction:-20, attack:0, release:0.25};
    this.audionode = m.getAudioContext().createDynamicsCompressor();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function x() {
    this.properties = {};
    this.audionode = m.getAudioContext().createWaveShaper();
    this.addInput("in", "audio");
    this.addInput("shape", "waveshape");
    this.addOutput("out", "audio");
  }
  function v() {
    this.properties = {gain1:0.5, gain2:0.5};
    this.audionode = m.getAudioContext().createGain();
    this.audionode1 = m.getAudioContext().createGain();
    this.audionode1.gain.value = this.properties.gain1;
    this.audionode2 = m.getAudioContext().createGain();
    this.audionode2.gain.value = this.properties.gain2;
    this.audionode1.connect(this.audionode);
    this.audionode2.connect(this.audionode);
    this.addInput("in1", "audio");
    this.addInput("in1 gain", "number");
    this.addInput("in2", "audio");
    this.addInput("in2 gain", "number");
    this.addOutput("out", "audio");
  }
  function p() {
    this.properties = {A:0.1, D:0.1, S:0.1, R:0.1};
    this.audionode = m.getAudioContext().createGain();
    this.audionode.gain.value = 0;
    this.addInput("in", "audio");
    this.addInput("gate", "bool");
    this.addOutput("out", "audio");
    this.gate = !1;
  }
  function C() {
    this.properties = {delayTime:0.5};
    this.audionode = m.getAudioContext().createDelay(10);
    this.audionode.delayTime.value = this.properties.delayTime;
    this.addInput("in", "audio");
    this.addInput("time", "number");
    this.addOutput("out", "audio");
  }
  function w() {
    this.properties = {frequency:350, detune:0, Q:1};
    this.addProperty("type", "lowpass", "enum", {values:"lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ")});
    this.audionode = m.getAudioContext().createBiquadFilter();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function u() {
    this.properties = {frequency:440, detune:0, type:"sine"};
    this.addProperty("type", "sine", "enum", {values:["sine", "square", "sawtooth", "triangle", "custom"]});
    this.audionode = m.getAudioContext().createOscillator();
    this.addOutput("out", "audio");
  }
  function y() {
    this.properties = {continuous:!0, mark:-1};
    this.addInput("data", "array");
    this.addInput("mark", "number");
    this.size = [300, 200];
    this._last_buffer = null;
  }
  function r() {
    this.properties = {band:440, amplitude:1};
    this.addInput("freqs", "array");
    this.addOutput("signal", "number");
  }
  function z() {
    if (!z.default_code) {
      var a = z.default_function.toString(), b = a.indexOf("{") + 1, c = a.lastIndexOf("}");
      z.default_code = a.substr(b, c - b);
    }
    this.properties = {code:z.default_code};
    a = m.getAudioContext();
    a.createScriptProcessor ? this.audionode = a.createScriptProcessor(4096, 1, 1) : (console.warn("ScriptProcessorNode deprecated"), this.audionode = a.createGain());
    this.processCode();
    z._bypass_function || (z._bypass_function = this.audionode.onaudioprocess);
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function d() {
    this.audionode = m.getAudioContext().destination;
    this.addInput("in", "audio");
  }
  var e = n.LiteGraph, m = {};
  n.LGAudio = m;
  m.getAudioContext = function() {
    if (!this._audio_context) {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!window.AudioContext) {
        return console.error("AudioContext not supported by browser"), null;
      }
      this._audio_context = new AudioContext;
      this._audio_context.onmessage = function(a) {
        console.log("msg", a);
      };
      this._audio_context.onended = function(a) {
        console.log("ended", a);
      };
      this._audio_context.oncomplete = function(a) {
        console.log("complete", a);
      };
    }
    return this._audio_context;
  };
  m.connect = function(a, b) {
    try {
      a.connect(b);
    } catch (B) {
      console.warn("LGraphAudio:", B);
    }
  };
  m.disconnect = function(a, b) {
    try {
      a.disconnect(b);
    } catch (B) {
      console.warn("LGraphAudio:", B);
    }
  };
  m.changeAllAudiosConnections = function(a, b) {
    if (a.inputs) {
      for (var f = 0; f < a.inputs.length; ++f) {
        var c = a.graph.links[a.inputs[f].link];
        if (c) {
          var d = a.graph.getNodeById(c.origin_id);
          d = d.getAudioNodeInOutputSlot ? d.getAudioNodeInOutputSlot(c.origin_slot) : d.audionode;
          c = a.getAudioNodeInInputSlot ? a.getAudioNodeInInputSlot(f) : a.audionode;
          b ? m.connect(d, c) : m.disconnect(d, c);
        }
      }
    }
    if (a.outputs) {
      for (f = 0; f < a.outputs.length; ++f) {
        for (var e = a.outputs[f], g = 0; g < e.links.length; ++g) {
          if (c = a.graph.links[e.links[g]]) {
            d = a.getAudioNodeInOutputSlot ? a.getAudioNodeInOutputSlot(f) : a.audionode;
            var l = a.graph.getNodeById(c.target_id);
            c = l.getAudioNodeInInputSlot ? l.getAudioNodeInInputSlot(c.target_slot) : l.audionode;
            b ? m.connect(d, c) : m.disconnect(d, c);
          }
        }
      }
    }
  };
  m.onConnectionsChange = function(a, b, c, d) {
    a == e.OUTPUT && (a = null, d && (a = this.graph.getNodeById(d.target_id)), a && (b = this.getAudioNodeInOutputSlot ? this.getAudioNodeInOutputSlot(b) : this.audionode, d = a.getAudioNodeInInputSlot ? a.getAudioNodeInInputSlot(d.target_slot) : a.audionode, c ? m.connect(b, d) : m.disconnect(b, d)));
  };
  m.createAudioNodeWrapper = function(a) {
    var b = a.prototype.onPropertyChanged;
    a.prototype.onPropertyChanged = function(a, c) {
      b && b.call(this, a, c);
      this.audionode && void 0 !== this.audionode[a] && (void 0 !== this.audionode[a].value ? this.audionode[a].value = c : this.audionode[a] = c);
    };
    a.prototype.onConnectionsChange = m.onConnectionsChange;
  };
  m.cached_audios = {};
  m.loadSound = function(a, b, c) {
    function d(a) {
      console.log("Audio loading sample error:", a);
      c && c(a);
    }
    if (m.cached_audios[a] && -1 == a.indexOf("blob:")) {
      b && b(m.cached_audios[a]);
    } else {
      m.onProcessAudioURL && (a = m.onProcessAudioURL(a));
      var f = new XMLHttpRequest;
      f.open("GET", a, !0);
      f.responseType = "arraybuffer";
      var e = m.getAudioContext();
      f.onload = function() {
        console.log("AudioSource loaded");
        e.decodeAudioData(f.response, function(c) {
          console.log("AudioSource decoded");
          m.cached_audios[a] = c;
          b && b(c);
        }, d);
      };
      f.send();
      return f;
    }
  };
  a["@src"] = {widget:"resource"};
  a.supported_extensions = ["wav", "ogg", "mp3"];
  a.prototype.onAdded = function(a) {
    if (a.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  a.prototype.onStart = function() {
    this._audiobuffer && this.properties.autoplay && this.playBuffer(this._audiobuffer);
  };
  a.prototype.onStop = function() {
    this.stopAllSounds();
  };
  a.prototype.onPause = function() {
    this.pauseAllSounds();
  };
  a.prototype.onUnpause = function() {
    this.unpauseAllSounds();
  };
  a.prototype.onRemoved = function() {
    this.stopAllSounds();
    this._dropped_url && URL.revokeObjectURL(this._url);
  };
  a.prototype.stopAllSounds = function() {
    for (var a = 0; a < this._audionodes.length; ++a) {
      this._audionodes[a].started && (this._audionodes[a].started = !1, this._audionodes[a].stop());
    }
    this._audionodes.length = 0;
  };
  a.prototype.pauseAllSounds = function() {
    m.getAudioContext().suspend();
  };
  a.prototype.unpauseAllSounds = function() {
    m.getAudioContext().resume();
  };
  a.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          if (void 0 !== c) {
            if ("gain" == b.name) {
              this.audionode.gain.value = c;
            } else {
              if ("playbackRate" == b.name) {
                for (this.properties.playbackRate = c, b = 0; b < this._audionodes.length; ++b) {
                  this._audionodes[b].playbackRate.value = c;
                }
              }
            }
          }
        }
      }
    }
    if (this.outputs) {
      for (a = 0; a < this.outputs.length; ++a) {
        "buffer" == this.outputs[a].name && this._audiobuffer && this.setOutputData(a, this._audiobuffer);
      }
    }
  };
  a.prototype.onAction = function(a) {
    this._audiobuffer && ("Play" == a ? this.playBuffer(this._audiobuffer) : "Stop" == a && this.stopAllSounds());
  };
  a.prototype.onPropertyChanged = function(a, b) {
    if ("src" == a) {
      this.loadSound(b);
    } else {
      if ("gain" == a) {
        this.audionode.gain.value = b;
      } else {
        if ("playbackRate" == a) {
          for (a = 0; a < this._audionodes.length; ++a) {
            this._audionodes[a].playbackRate.value = b;
          }
        }
      }
    }
  };
  a.prototype.playBuffer = function(a) {
    var b = this, c = m.getAudioContext().createBufferSource();
    this._last_sourcenode = c;
    c.graphnode = this;
    c.buffer = a;
    c.loop = this.properties.loop;
    c.playbackRate.value = this.properties.playbackRate;
    this._audionodes.push(c);
    c.connect(this.audionode);
    this._audionodes.push(c);
    c.onended = function() {
      b.trigger("ended");
      var a = b._audionodes.indexOf(c);
      -1 != a && b._audionodes.splice(a, 1);
    };
    c.started || (c.started = !0, c.start());
    return c;
  };
  a.prototype.loadSound = function(a) {
    var b = this;
    this._request && (this._request.abort(), this._request = null);
    this._audiobuffer = null;
    this._loading_audio = !1;
    a && (this._request = m.loadSound(a, function(a) {
      this.boxcolor = e.NODE_DEFAULT_BOXCOLOR;
      b._audiobuffer = a;
      b._loading_audio = !1;
      if (b.graph && b.graph.status === LGraph.STATUS_RUNNING) {
        b.onStart();
      }
    }), this._loading_audio = !0, this.boxcolor = "#AA4");
  };
  a.prototype.onConnectionsChange = m.onConnectionsChange;
  a.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["Play", e.ACTION], ["Stop", e.ACTION]];
  };
  a.prototype.onGetOutputs = function() {
    return [["buffer", "audiobuffer"], ["ended", e.EVENT]];
  };
  a.prototype.onDropFile = function(a) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    a = URL.createObjectURL(a);
    this.properties.src = a;
    this.loadSound(a);
    this._dropped_url = a;
  };
  a.title = "Source";
  a.desc = "Plays audio";
  e.registerNodeType("audio/source", a);
  h.prototype.onAdded = function(a) {
    if (a.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  h.prototype.onStart = function() {
    null != this._media_stream || this._waiting_confirmation || this.openStream();
  };
  h.prototype.onStop = function() {
    this.audionode.gain.value = 0;
  };
  h.prototype.onPause = function() {
    this.audionode.gain.value = 0;
  };
  h.prototype.onUnpause = function() {
    this.audionode.gain.value = this.properties.gain;
  };
  h.prototype.onRemoved = function() {
    this.audionode.gain.value = 0;
    this.audiosource_node && (this.audiosource_node.disconnect(this.audionode), this.audiosource_node = null);
    if (this._media_stream) {
      var a = this._media_stream.getTracks();
      a.length && a[0].stop();
    }
  };
  h.prototype.openStream = function() {
    if (navigator.mediaDevices) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!0, video:!1}).then(this.streamReady.bind(this)).catch(function(b) {
        console.log("Media rejected", b);
        a._media_stream = !1;
        a.boxcolor = "red";
      });
      var a = this;
    } else {
      console.log("getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
    }
  };
  h.prototype.streamReady = function(a) {
    this._media_stream = a;
    this.audiosource_node && this.audiosource_node.disconnect(this.audionode);
    this.audiosource_node = m.getAudioContext().createMediaStreamSource(a);
    this.audiosource_node.graphnode = this;
    this.audiosource_node.connect(this.audionode);
    this.boxcolor = "white";
  };
  h.prototype.onExecute = function() {
    null != this._media_stream || this._waiting_confirmation || this.openStream();
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && "gain" == b.name && (this.audionode.gain.value = this.properties.gain = c);
        }
      }
    }
  };
  h.prototype.onAction = function(a) {
    "Play" == a ? this.audionode.gain.value = this.properties.gain : "Stop" == a && (this.audionode.gain.value = 0);
  };
  h.prototype.onPropertyChanged = function(a, b) {
    "gain" == a && (this.audionode.gain.value = b);
  };
  h.prototype.onConnectionsChange = m.onConnectionsChange;
  h.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["Play", e.ACTION], ["Stop", e.ACTION]];
  };
  h.title = "MediaSource";
  h.desc = "Plays microphone";
  e.registerNodeType("audio/media_source", h);
  c.prototype.onPropertyChanged = function(a, b) {
    this.audionode[a] = b;
  };
  c.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.audionode.frequencyBinCount;
      this._freq_bin && this._freq_bin.length == a || (this._freq_bin = new Uint8Array(a));
      this.audionode.getByteFrequencyData(this._freq_bin);
      this.setOutputData(0, this._freq_bin);
    }
    this.isOutputConnected(1) && (a = this.audionode.frequencyBinCount, this._time_bin && this._time_bin.length == a || (this._time_bin = new Uint8Array(a)), this.audionode.getByteTimeDomainData(this._time_bin), this.setOutputData(1, this._time_bin));
    for (a = 1; a < this.inputs.length; ++a) {
      var b = this.inputs[a];
      if (null != b.link) {
        var c = this.getInputData(a);
        void 0 !== c && (this.audionode[b.name].value = c);
      }
    }
  };
  c.prototype.onGetInputs = function() {
    return [["minDecibels", "number"], ["maxDecibels", "number"], ["smoothingTimeConstant", "number"]];
  };
  c.prototype.onGetOutputs = function() {
    return [["freqs", "array"], ["samples", "array"]];
  };
  c.title = "Analyser";
  c.desc = "Audio Analyser";
  e.registerNodeType("audio/analyser", c);
  b.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.audionode[b.name].value = c);
      }
    }
  };
  m.createAudioNodeWrapper(b);
  b.title = "Gain";
  b.desc = "Audio gain";
  e.registerNodeType("audio/gain", b);
  m.createAudioNodeWrapper(l);
  l.prototype.onRemove = function() {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
  };
  l.prototype.onPropertyChanged = function(a, b) {
    "impulse_src" == a ? this.loadImpulse(b) : "normalize" == a && (this.audionode.normalize = b);
  };
  l.prototype.onDropFile = function(a) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    this._dropped_url = URL.createObjectURL(a);
    this.properties.impulse_src = this._dropped_url;
    this.loadImpulse(this._dropped_url);
  };
  l.prototype.loadImpulse = function(a) {
    var b = this;
    this._request && (this._request.abort(), this._request = null);
    this._impulse_buffer = null;
    this._loading_impulse = !1;
    a && (this._request = m.loadSound(a, function(a) {
      b._impulse_buffer = a;
      b.audionode.buffer = a;
      console.log("Impulse signal set");
      b._loading_impulse = !1;
    }), this._loading_impulse = !0);
  };
  l.title = "Convolver";
  l.desc = "Convolves the signal (used for reverb)";
  e.registerNodeType("audio/convolver", l);
  m.createAudioNodeWrapper(g);
  g.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  g.prototype.onGetInputs = function() {
    return [["threshold", "number"], ["knee", "number"], ["ratio", "number"], ["reduction", "number"], ["attack", "number"], ["release", "number"]];
  };
  g.title = "DynamicsCompressor";
  g.desc = "Dynamics Compressor";
  e.registerNodeType("audio/dynamicsCompressor", g);
  x.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      var a = this.getInputData(1);
      void 0 !== a && (this.audionode.curve = a);
    }
  };
  x.prototype.setWaveShape = function(a) {
    this.audionode.curve = a;
  };
  m.createAudioNodeWrapper(x);
  v.prototype.getAudioNodeInInputSlot = function(a) {
    if (0 == a) {
      return this.audionode1;
    }
    if (2 == a) {
      return this.audionode2;
    }
  };
  v.prototype.onPropertyChanged = function(a, b) {
    "gain1" == a ? this.audionode1.gain.value = b : "gain2" == a && (this.audionode2.gain.value = b);
  };
  v.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        null != b.link && "audio" != b.type && (b = this.getInputData(a), void 0 !== b && (1 == a ? this.audionode1.gain.value = b : 3 == a && (this.audionode2.gain.value = b)));
      }
    }
  };
  m.createAudioNodeWrapper(v);
  v.title = "Mixer";
  v.desc = "Audio mixer";
  e.registerNodeType("audio/mixer", v);
  p.prototype.onExecute = function() {
    var a = m.getAudioContext().currentTime, b = this.audionode.gain, c = this.getInputData(1), d = this.getInputOrProperty("A"), e = this.getInputOrProperty("D"), g = this.getInputOrProperty("S"), l = this.getInputOrProperty("R");
    !this.gate && c ? (b.cancelScheduledValues(0), b.setValueAtTime(0, a), b.linearRampToValueAtTime(1, a + d), b.linearRampToValueAtTime(g, a + d + e)) : this.gate && !c && (b.cancelScheduledValues(0), b.setValueAtTime(b.value, a), b.linearRampToValueAtTime(0, a + l));
    this.gate = c;
  };
  p.prototype.onGetInputs = function() {
    return [["A", "number"], ["D", "number"], ["S", "number"], ["R", "number"]];
  };
  m.createAudioNodeWrapper(p);
  p.title = "ADSR";
  p.desc = "Audio envelope";
  e.registerNodeType("audio/adsr", p);
  m.createAudioNodeWrapper(C);
  C.prototype.onExecute = function() {
    var a = this.getInputData(1);
    void 0 !== a && (this.audionode.delayTime.value = a);
  };
  C.title = "Delay";
  C.desc = "Audio delay";
  e.registerNodeType("audio/delay", C);
  w.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  w.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];
  };
  m.createAudioNodeWrapper(w);
  w.title = "BiquadFilter";
  w.desc = "Audio filter";
  e.registerNodeType("audio/biquadfilter", w);
  u.prototype.onStart = function() {
    if (!this.audionode.started) {
      this.audionode.started = !0;
      try {
        this.audionode.start();
      } catch (f) {
      }
    }
  };
  u.prototype.onStop = function() {
    this.audionode.started && (this.audionode.started = !1, this.audionode.stop());
  };
  u.prototype.onPause = function() {
    this.onStop();
  };
  u.prototype.onUnpause = function() {
    this.onStart();
  };
  u.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  u.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["type", "string"]];
  };
  m.createAudioNodeWrapper(u);
  u.title = "Oscillator";
  u.desc = "Oscillator";
  e.registerNodeType("audio/oscillator", u);
  y.prototype.onExecute = function() {
    this._last_buffer = this.getInputData(0);
    var a = this.getInputData(1);
    void 0 !== a && (this.properties.mark = a);
    this.setDirtyCanvas(!0, !1);
  };
  y.prototype.onDrawForeground = function(a) {
    if (this._last_buffer) {
      var b = this._last_buffer, c = b.length / this.size[0], d = this.size[1];
      a.fillStyle = "black";
      a.fillRect(0, 0, this.size[0], this.size[1]);
      a.strokeStyle = "white";
      a.beginPath();
      var f = 0;
      if (this.properties.continuous) {
        a.moveTo(f, d);
        for (var e = 0; e < b.length; e += c) {
          a.lineTo(f, d - b[e | 0] / 255 * d), f++;
        }
      } else {
        for (e = 0; e < b.length; e += c) {
          a.moveTo(f + 0.5, d), a.lineTo(f + 0.5, d - b[e | 0] / 255 * d), f++;
        }
      }
      a.stroke();
      0 <= this.properties.mark && (b = m.getAudioContext().sampleRate / b.length, f = this.properties.mark / b * 2 / c, f >= this.size[0] && (f = this.size[0] - 1), a.strokeStyle = "red", a.beginPath(), a.moveTo(f, d), a.lineTo(f, 0), a.stroke());
    }
  };
  y.title = "Visualization";
  y.desc = "Audio Visualization";
  e.registerNodeType("audio/visualization", y);
  r.prototype.onExecute = function() {
    if (this._freqs = this.getInputData(0)) {
      var a = this.properties.band, b = this.getInputData(1);
      void 0 !== b && (a = b);
      b = m.getAudioContext().sampleRate / this._freqs.length;
      b = a / b * 2;
      b >= this._freqs.length ? b = this._freqs[this._freqs.length - 1] : (a = b | 0, b -= a, b = this._freqs[a] * (1 - b) + this._freqs[a + 1] * b);
      this.setOutputData(0, b / 255 * this.properties.amplitude);
    }
  };
  r.prototype.onGetInputs = function() {
    return [["band", "number"]];
  };
  r.title = "Signal";
  r.desc = "extract the signal of some frequency";
  e.registerNodeType("audio/signal", r);
  z.prototype.onAdded = function(a) {
    a.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback);
  };
  z["@code"] = {widget:"code"};
  z.prototype.onStart = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  z.prototype.onStop = function() {
    this.audionode.onaudioprocess = z._bypass_function;
  };
  z.prototype.onPause = function() {
    this.audionode.onaudioprocess = z._bypass_function;
  };
  z.prototype.onUnpause = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  z.prototype.onExecute = function() {
  };
  z.prototype.onRemoved = function() {
    this.audionode.onaudioprocess = z._bypass_function;
  };
  z.prototype.processCode = function() {
    try {
      this._script = new (new Function("properties", this.properties.code))(this.properties), this._old_code = this.properties.code, this._callback = this._script.onaudioprocess;
    } catch (f) {
      console.error("Error in onaudioprocess code", f), this._callback = z._bypass_function, this.audionode.onaudioprocess = this._callback;
    }
  };
  z.prototype.onPropertyChanged = function(a, b) {
    "code" == a && (this.properties.code = b, this.processCode(), this.graph && this.graph.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback));
  };
  z.default_function = function() {
    this.onaudioprocess = function(a) {
      var b = a.inputBuffer;
      a = a.outputBuffer;
      for (var c = 0; c < a.numberOfChannels; c++) {
        for (var d = b.getChannelData(c), e = a.getChannelData(c), f = 0; f < b.length; f++) {
          e[f] = d[f];
        }
      }
    };
  };
  m.createAudioNodeWrapper(z);
  z.title = "Script";
  z.desc = "apply script to signal";
  e.registerNodeType("audio/script", z);
  d.title = "Destination";
  d.desc = "Audio output";
  e.registerNodeType("audio/destination", d);
})(this);
(function(n) {
  function a() {
    this.size = [60, 20];
    this.addInput("send", c.ACTION);
    this.addOutput("received", c.EVENT);
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.properties = {url:"", room:"lgraph", only_send_changes:!0};
    this._ws = null;
    this._last_sent_data = [];
    this._last_received_data = [];
  }
  function h() {
    this.room_widget = this.addWidget("text", "Room", "lgraph", this.setRoom.bind(this));
    this.addWidget("button", "Reconnect", null, this.connectSocket.bind(this));
    this.addInput("send", c.ACTION);
    this.addOutput("received", c.EVENT);
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.properties = {url:"tamats.com:55000", room:"lgraph", only_send_changes:!0};
    this._server = null;
    this.connectSocket();
    this._last_sent_data = [];
    this._last_received_data = [];
    "undefined" == typeof SillyClient && console.warn("remember to add SillyClient.js to your project: https://tamats.com/projects/sillyserver/src/sillyclient.js");
  }
  var c = n.LiteGraph;
  a.title = "WebSocket";
  a.desc = "Send data through a websocket";
  a.prototype.onPropertyChanged = function(a, c) {
    "url" == a && this.connectSocket();
  };
  a.prototype.onExecute = function() {
    !this._ws && this.properties.url && this.connectSocket();
    if (this._ws && this._ws.readyState == WebSocket.OPEN) {
      for (var a = this.properties.room, c = this.properties.only_send_changes, g = 1; g < this.inputs.length; ++g) {
        var h = this.getInputData(g);
        if (null != h) {
          try {
            var n = JSON.stringify({type:0, room:a, channel:g, data:h});
          } catch (p) {
            continue;
          }
          c && this._last_sent_data[g] == n || (this._last_sent_data[g] = n, this._ws.send(n));
        }
      }
      for (g = 1; g < this.outputs.length; ++g) {
        this.setOutputData(g, this._last_received_data[g]);
      }
      "#AFA" == this.boxcolor && (this.boxcolor = "#6C6");
    }
  };
  a.prototype.connectSocket = function() {
    var a = this, l = this.properties.url;
    "ws" != l.substr(0, 2) && (l = "ws://" + l);
    this._ws = new WebSocket(l);
    this._ws.onopen = function() {
      console.log("ready");
      a.boxcolor = "#6C6";
    };
    this._ws.onmessage = function(b) {
      a.boxcolor = "#AFA";
      var g = JSON.parse(b.data);
      if (!g.room || g.room == this.properties.room) {
        if (1 == b.data.type) {
          if (g.data.object_class && c[g.data.object_class]) {
            b = null;
            try {
              b = new c[g.data.object_class](g.data), a.triggerSlot(0, b);
            } catch (v) {
            }
          } else {
            a.triggerSlot(0, g.data);
          }
        } else {
          a._last_received_data[b.data.channel || 0] = g.data;
        }
      }
    };
    this._ws.onerror = function(b) {
      console.log("couldnt connect to websocket");
      a.boxcolor = "#E88";
    };
    this._ws.onclose = function(b) {
      console.log("connection closed");
      a.boxcolor = "#000";
    };
  };
  a.prototype.send = function(a) {
    this._ws && this._ws.readyState == WebSocket.OPEN && this._ws.send(JSON.stringify({type:1, msg:a}));
  };
  a.prototype.onAction = function(a, c) {
    this._ws && this._ws.readyState == WebSocket.OPEN && this._ws.send({type:1, room:this.properties.room, action:a, data:c});
  };
  a.prototype.onGetInputs = function() {
    return [["in", 0]];
  };
  a.prototype.onGetOutputs = function() {
    return [["out", 0]];
  };
  c.registerNodeType("network/websocket", a);
  h.title = "SillyClient";
  h.desc = "Connects to SillyServer to broadcast messages";
  h.prototype.onPropertyChanged = function(a, c) {
    "room" == a && (this.room_widget.value = c);
    this.connectSocket();
  };
  h.prototype.setRoom = function(a) {
    this.properties.room = a;
    this.room_widget.value = a;
    this.connectSocket();
  };
  h.prototype.onDrawForeground = function() {
    for (var a = 1; a < this.inputs.length; ++a) {
      var c = this.inputs[a];
      c.label = "in_" + a;
    }
    for (a = 1; a < this.outputs.length; ++a) {
      c = this.outputs[a], c.label = "out_" + a;
    }
  };
  h.prototype.onExecute = function() {
    if (this._server && this._server.is_connected) {
      for (var a = this.properties.only_send_changes, c = 1; c < this.inputs.length; ++c) {
        var g = this.getInputData(c), h = this._last_sent_data[c];
        if (null != g) {
          if (a) {
            var n = !0;
            if (g && g.length && h && h.length == g.length && g.constructor !== String) {
              for (var p = 0; p < g.length; ++p) {
                if (h[p] != g[p]) {
                  n = !1;
                  break;
                }
              }
            } else {
              this._last_sent_data[c] != g && (n = !1);
            }
            if (n) {
              continue;
            }
          }
          this._server.sendMessage({type:0, channel:c, data:g});
          if (g.length && g.constructor !== String) {
            if (this._last_sent_data[c]) {
              for (this._last_sent_data[c].length = g.length, p = 0; p < g.length; ++p) {
                this._last_sent_data[c][p] = g[p];
              }
            } else {
              this._last_sent_data[c] = g.constructor === Array ? g.concat() : new g.constructor(g);
            }
          } else {
            this._last_sent_data[c] = g;
          }
        }
      }
      for (c = 1; c < this.outputs.length; ++c) {
        this.setOutputData(c, this._last_received_data[c]);
      }
      "#AFA" == this.boxcolor && (this.boxcolor = "#6C6");
    }
  };
  h.prototype.connectSocket = function() {
    var a = this;
    if ("undefined" == typeof SillyClient) {
      this._error || console.error("SillyClient node cannot be used, you must include SillyServer.js"), this._error = !0;
    } else {
      if (this._server = new SillyClient, this._server.on_ready = function() {
        console.log("ready");
        a.boxcolor = "#6C6";
      }, this._server.on_message = function(b, g) {
        b = null;
        try {
          b = JSON.parse(g);
        } catch (x) {
          return;
        }
        if (1 == b.type) {
          if (b.data.object_class && c[b.data.object_class]) {
            g = null;
            try {
              g = new c[b.data.object_class](b.data), a.triggerSlot(0, g);
            } catch (x) {
              return;
            }
          } else {
            a.triggerSlot(0, b.data);
          }
        } else {
          a._last_received_data[b.channel || 0] = b.data;
        }
        a.boxcolor = "#AFA";
      }, this._server.on_error = function(b) {
        console.log("couldnt connect to websocket");
        a.boxcolor = "#E88";
      }, this._server.on_close = function(b) {
        console.log("connection closed");
        a.boxcolor = "#000";
      }, this.properties.url && this.properties.room) {
        try {
          this._server.connect(this.properties.url, this.properties.room);
        } catch (l) {
          console.error("SillyServer error: " + l);
          this._server = null;
          return;
        }
        this._final_url = this.properties.url + "/" + this.properties.room;
      }
    }
  };
  h.prototype.send = function(a) {
    this._server && this._server.is_connected && this._server.sendMessage({type:1, data:a});
  };
  h.prototype.onAction = function(a, c) {
    this._server && this._server.is_connected && this._server.sendMessage({type:1, action:a, data:c});
  };
  h.prototype.onGetInputs = function() {
    return [["in", 0]];
  };
  h.prototype.onGetOutputs = function() {
    return [["out", 0]];
  };
  c.registerNodeType("network/sillyclient", h);
})(this);

